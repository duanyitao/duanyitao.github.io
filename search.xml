<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 Chronometer 实现倒计时]]></title>
    <url>%2F2020%2F03%2F11%2F%E4%BD%BF%E7%94%A8-Chronometer-%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[使用 Chronometer 实现倒计时 在实际业务开发的场景中，经常会有要用到倒计时的功能，比如一个广告页面倒计时，比如一个超时自动关闭页面，等这些操作都离不开倒计时的概念。当然，我们完全可以自己去实现一个倒计时逻辑，例如使用 timer ，或者使用 RxJava 等各种定时策略。本文介绍一个比较简单的，系统原生提供的一个组件 Chronometer。 具体实现XML12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Chronometer android:id="@+id/chronometer" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:layout_centerHorizontal="true" /&gt;&lt;/RelativeLayout&gt; Activity12345678910111213141516171819202122232425262728public class ChronoActivity1 extends AppCompatActivity &#123; int time = 60; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Chronometer chronometer = findViewById(R.id.chronometer); chronometer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() &#123; @Override public void onChronometerTick(Chronometer chronometer) &#123; if (time == 0) &#123; chronometer.setText("0"); chronometer.stop(); finish(); &#125; else &#123; time--; chronometer.setText(time + ""); &#125; &#125; &#125;); chronometer.start(); &#125;&#125; 是不是觉得非常简单呢？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveData may lost Data]]></title>
    <url>%2F2019%2F12%2F30%2FLiveData-may-lose-Data%2F</url>
    <content type="text"><![CDATA[声明： 本文翻译自Medium 文章 LiveData可能会丢失数据。在你说“没关系”之前，请检查所有的情况。 LiveData是谷歌的Android架构中最引人注目的明星组件之一。基本上，它是一个可观察的数据持有者，并在观察者处于活动状态时将数据更改发送给观察者。在Android应用程序中，视图通常附加到生命周期感知组件，如片段或活动。然而，生命周期感知组件可能被杀死、重新创建或分离(片段)，这使得访问视图变得危险和复杂。为了使视图层操作更加友好，LiveData向它的观察者引入了生命周期感知。每个观察者可以与一个LifecycleOwner相关联，通常是一个片段或活动，并防止在其LifecycleOwner不活动时将数据更改发送给观察者。此行为可以确保在执行不是“必要的”情况下，观察者中的逻辑不会被执行。例如，如果一个片段正在分离，它的视图将很快被销毁。在分离过程中，这个片段视图上的任何视图层操作都是不可见的，也是不必要的。相反，LiveData缓冲最后的数据更改，并在片段重新连接和重新创建视图时通知观察者，这可以将新视图实例“恢复”到最新状态，并防止潜在的NPE或内存泄漏。但是，由于LiveData在主线程上分发数据，并且只缓冲一个挂起的数据更改，所以您的观察者很少会错过或没有接收到数据更改。尽管谷歌的文档从未将LiveData定义为类似于rxjava的流框架，也没有建议使用LiveData，只是在视图和VM之间建立一个薄薄的粘合层，但我们仍然有必要研究所有可能的数据丢失场景，并避免生产中可能出现的意外行为。在下一节中，我们将通过示例讨论三种数据丢失情况。 将数据发送到活动状态之外LiveData是一个支持生命周期的组件。因此，只有在其LifecycleOwner处于活动状态时，才能将数据更改交付给观察者。如下图所示，当一个LifecycleOwner切换到“STARTED”或“resume”时，它是活动的。因此，LiveData观察者只能在其LifecycleOwner“启动”或“恢复”时接收数据更改更新。如果数据源将数据发送到活动状态之外的LiveData，则观察者将不会接收发送的数据。 假设我们有一个活动，它在其生命周期回调中将数据写入MutableLiveData。一个观察者正在观察MutableLiveData并打印出接收到的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ActiveGapActivity extends BaseActivity &#123; private static MutableLiveData&lt;String&gt; mutableLiveData = new MutableLiveData&lt;&gt;(); @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mutableLiveData.observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String string) &#123; System.out.println("ActiveGapActivity Observed: " + string); &#125; &#125;); mutableLiveData.setValue("onCreate"); &#125; @Override public void onResume() &#123; super.onResume(); mutableLiveData.setValue("onResume"); &#125; @Override public void onPause() &#123; super.onPause(); mutableLiveData.setValue("onPause"); &#125; @Override public void onStop() &#123; super.onStop(); System.out.println("ActiveGapActivity onStop called"); mutableLiveData.setValue("onStop"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); mutableLiveData.setValue("onDestroy"); &#125;&#125; 如果我们旋转app并触发Activity recreation，会打印如下日志: 12345678910ActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResumeActiveGapActivity Observed: onPauseActiveGapActivity onStop called &lt;== onStop() is calledActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResumeActiveGapActivity Observed: onPauseActiveGapActivity onStop calledActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResume 如日志所示，观察者没有接收到“onStop”，这肯定是被调用的，因为“ActiveGapActivity onStop调用”被打印出来了。这种行为是由两个LiveData礼: LiveData可以缓冲一个数据实例; LiveData在其生命周期中不会通知观察者，而cleowner则处于“非活动”状态。 当我们旋转屏幕时，活动将被重新创建。将顺序调用当前活动实例的onStop()和onDestroy()。但是，由于活动不再活动，发出的数据将不会传递给观察者。而是在内部缓冲最新的数据实例，即“onDestroy”。当活动被重新创建时，第二个活动实例将发出“onCreate”，并覆盖之前的缓冲数据“onDestroy”。一旦活动(即LifecycleOwner)恢复活动，观察者将只接收缓冲的“onCreate”。onStop和onDestroy都丢失了。下图显示了在第二个活动的onCreate()中调用LiveData的setValue函数时的调试信息。显然，新的数据实例“onCreate”覆盖了先前由第一个实例的onDestroy()发出的缓冲数据实例(“mData”)。 从后台线程发出数据LiveData在主线程上调度数据。如果源从后台线程发出数据，则下游使用者不会立即收到更新。相反，发出的数据将在LiveData中进行缓冲，并等待主线程稍后进行调度。但是，由于LiveData只缓冲一个数据实例，如果数据源发出的数据比主线程分派的数据“更快”。新数据实例可能会覆盖已缓存的数据实例，从而导致数据丢失。让我们来看看下面的例子。在onResume()中启动一个AsyncTask，并向LiveData发送三个数据实例;在“onCreate”中初始化输出数据的观察者。 1234567891011121314151617181920212223242526272829303132public class PostValueSampleActivity extends BaseActivity &#123; private MutableLiveData&lt;Integer&gt; source; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); source = new MutableLiveData&lt;&gt;(); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append(integer.toString()); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; source.postValue(1); source.postValue(2); source.postValue(3); &#125; &#125;); &#125;&#125; 示例代码将只输出“3”，这是AsyncTask发出的最后一个数据。这个输出背后的魔力可以在LiveData的源代码中找到。 1234567891011protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125; 当一个后台线程向LiveData发送数据时，LiveData会将一个标记、postTask标记为true;发布一个runnable到主线程，将数据更改发送给观察者。如果后台线程发出数据“太频繁”(在主线程可运行完成之前)，新发布的数据将覆盖“mPendingData”。当主thead执行runnable并尝试分发数据更改时，它将获得最后的数据，即“mPendingData”保存的数据。 在观察者中发射数据由于LiveData在主线程上调度数据，所以在调度已经启动时，所有的事情都是(某种程度上)同步的。所有观察者将被迭代，并依次接收更新。但是，如果在观察者内部设置新的数据更改，则新的数据更改(我们称之为“B”)将覆盖当前正在调度的数据更改(我们称之为“A”)并终止当前调度周期。一些观察者可能不会永远得到“A”。假设有两个观察者。观察者2打印接收到的内容，但是如果接收到的数字是偶数，观察者1将把新值设置回LiveData。 12345678910111213141516171819202122232425262728293031323334353637public class SetValueSampleActivity extends BaseActivity &#123; private MutableLiveData&lt;Integer&gt; source; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); source = new MutableLiveData&lt;&gt;(); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append("Receiver 1: " + integer.toString()); if (integer % 2 == 0) &#123; source.setValue(integer * 10); source.setValue(integer * 10 + 1); &#125; &#125; &#125;); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append("Receiver 2: " + integer.toString()); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); source.setValue(1); source.setValue(2); source.setValue(3); &#125;&#125; 此示例的输出如下图所示。观察者1收到1 2 21 3，观察者2收到1 21 3。 这种行为背后的原因有点复杂。让我们检查LiveData中的“dispatchingValue()”函数。从第2行到第6行可以看出，如果调度已经启动，任何新的数据集都不会启动另一个调度循环。相反，新的数据更改将覆盖挂起的数据(在setValue()函数中)，将“mDispatchInvalidated”设置为true并跳过(从第2行到第5行)。在我们的示例中，当观察者1接收到“2”时，它将“20”和“21”设置回LiveData。因为“mDispatchingValue”为真，所以“20”将不会被分派，而是被“21”覆盖。观察者1的逻辑完成后，由于“mDispatchInvalidated”为真，它将中断当前调度循环(从第13行到第19行，并停止观察者2接收“2”)，并使外部while循环再运行一次(从第7行到第21行)。在这个调度循环中，所有的观察者接收最后的数据“21”。 1234567891011121314151617181920212223private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125; github code↓↓https://github.com/hanyuliu/livedata_may_lose_data]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 基础]]></title>
    <url>%2F2019%2F06%2F22%2FHTML-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基本结构12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体内容 &lt;/body&gt;&lt;/html&gt; HTML 标签语法 &lt;标签&gt;&lt;/标签&gt; 示例 “&lt;html&gt;&lt;/html&gt;” 规则 用 ‘&lt;’ 和 ‘&gt;’ 括起来 一般成对出现，分为开始标签和结束标签 结束标签比开始标签多了个 ‘/‘ 单标签没有结束标签，如 “&lt;hr/&gt;” HTML 元素从开始标签 到结束标签 的所有代码，称为 HTML 元素。 HTML 属性语法&lt;标签名 属性名1=”值” 属性名2=”值” 属性名3=”值” &gt;……&lt;/标签名&gt; 注释语法：&lt;!– 注释 –&gt; DOCTYPE&lt;!DOCTYPE html&gt; 必须放在文档第一行。 网页编码设置&lt;meta http-equiv=”Content-Type” content=”text/html;charset-utf8”&gt; 文字和段落 标题：h1 - h6 段落：p align 属性： left center right justify 换行：br 水平线：hr width px persent color rgb hex name black red … align noshade i/em b/strong sub sup ins del 特殊符号 &lt; -&gt; &amp;lt; &gt; -&gt; &amp;gt; &reg; -&gt; &amp;reg; &copy; -&gt; &amp;copy; &trade; -&gt; &amp;trade; 空格 -&gt; &amp;nbsp; 列表标签 无序列表 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 123&lt;ol&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 定义列表 123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/ol&gt; 图像标签1&lt;img src="" alt="" ../&gt; 超链接1&lt;a htef="" &gt;内容&lt;/a&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koin with ViewModel]]></title>
    <url>%2F2019%2F04%2F25%2FKoin-with-ViewModel%2F</url>
    <content type="text"><![CDATA[Architecture Components with Koin: ViewModelGradle setupChoose the koin-android-viewmodel dependency to add to your Gradle project (android or androix version): 12345678910// Add Jcenter to your repositories if neededrepositories &#123; jcenter()&#125;dependencies &#123; // ViewModel for Android implementation 'org.koin:koin-android-viewmodel:2.0.0-beta-4' // or ViewModel for AndroidX implementation 'org.koin:koin-androidx-viewmodel:2.0.0-beta-4'&#125; ViewModel DSLThe koin-android-viewmodel introduces a new viewModel DSL keyword that comes in complement of single and factory, to help declare a ViewModel component and bind it to an Android Component lifecycle. 12345678val appModule = module &#123; // ViewModel for Detail View viewModel &#123; DetailViewModel(get(), get()) &#125; // or viewModel&lt;DetailViewModel&gt;()&#125; Your declared component must at least extends the android.arch.lifecycle.ViewModel class. You can specify how you inject the constructor of the class and use the get() function to inject dependencies. The viewModel keyword helps declaring a factory instance of ViewModel. This instance will be handled by internal ViewModelFactory and reattach ViewModel instance if needed. The viewModel keyword can also let you use the injection parameters. Injecting your ViewModelTo inject a ViewModel in an Activity, Fragment or Service use: by viewModel() - lazy delegate property to inject a ViewModel into a property getViewModel() - directly get the ViewModel instance 12345class DetailActivity : AppCompatActivity() &#123; // Lazy inject ViewModel val detailViewModel: DetailViewModel by viewModel()&#125; Shared ViewModelOne ViewModel instance can be shared between Fragments and their host Activity. To inject a shared ViewModel in a Fragment use: by sharedViewModel() - lazy delegate property to inject shared ViewModel instance into a property getSharedViewModel() - directly get the shared ViewModel instance Just declare the ViewModel only once: 1234567val weatherAppModule = module &#123; // WeatherViewModel declaration for Weather View components viewModel &#123; WeatherViewModel(get(), get()) &#125; // or viewModel&lt;WeatherViewModel&gt;()&#125; And reuse it in Activity and Fragments: 1234567891011121314151617181920212223class WeatherActivity : AppCompatActivity() &#123; /* * Declare WeatherViewModel with Koin and allow constructor dependency injection */ private val weatherViewModel by viewModel&lt;WeatherViewModel&gt;()&#125;class WeatherHeaderFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125;class WeatherListFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125; ViewModel and injection parametersthe viewModel keyword and injection API is compatible with injection parameters. In the module: 12345val appModule = module &#123; // ViewModel for Detail View with id as parameter injection viewModel &#123; (id : String) -&gt; DetailViewModel(id, get(), get()) &#125;&#125; From the injection call site: 1234567class DetailActivity : AppCompatActivity() &#123; val id : String // id of the view // Lazy inject ViewModel with id parameter val detailViewModel: DetailViewModel by viewModel&#123; parametersOf(id)&#125;&#125; that’s all, thanks for your reading.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Groovy Syntax]]></title>
    <url>%2F2019%2F04%2F23%2FGroovy-Syntax%2F</url>
    <content type="text"><![CDATA[Reference: Apache GroovyThis chapter covers the syntax of the Groovy programming language. The grammar of the language derives from the Java grammar, but enhances it with specific constructs for Groovy, and allows certain simplifications. CommentsSingle line commentSingle line comments start with // and can be found at any position in the line. The characters following //, till the end of the line, are considered part of the comment. 12// a standalone single line commentprintln "hello" // a comment till the end of the line Multiline commentA multiline comment starts with / and can be found at any position in the line. The characters following / will be considered part of the comment, including new line characters, up to the first */ closing the comment. Multiline comments can thus be put at the end of a statement, or even inside a statement. 12345/* a standalone multiline comment spanning two lines */println "hello" /* a multiline comment starting at the end of a statement */println 1 /* one */ + 2 /* two */ GroovyDoc commentSimilarly to multiline comments, GroovyDoc comments are multiline, but start with /* and end with /. Lines following the first GroovyDoc comment line can optionally start with a star *. Those comments are associated with: type definitions (classes, interfaces, enums, annotations), fields and properties definitions methods definitions Although the compiler will not complain about GroovyDoc comments not being associated with the above language elements, you should prepend those constructs with the comment right before it. 1234567891011121314151617/** * A Class description */class Person &#123; /** the name of the person */ String name /** * Creates a greeting method for a certain person. * * @param otherPerson the person to greet * @return a greeting message */ String greet(String otherPerson) &#123; "Hello $&#123;otherPerson&#125;" &#125;&#125; GroovyDoc follows the same conventions as Java’s own JavaDoc. So you’ll be able to use the same tags as with JavaDoc. Shebang lineBeside the single line comment, there is a special line comment, often called the shebang line understood by UNIX systems which allows scripts to be run directly from the command-line, provided you have installed the Groovy distribution and the groovy command is available on the PATH. 12#!/usr/bin/env groovyprintln "Hello from the shebang line" The # character must be the first character of the file. Any indentation would yield a compilation error. KeywordsThe following list represents all the keywords of the Groovy language: as assert catch class break case const continue const continue def default do else enum extends false finally for goto if implements import in instanceof interface new null package return super switch this throw throws trait true try while IdentifiersNormal identifiersIdentifiers start with a letter, a dollar or an underscore. They cannot start with a number. A letter can be in the following ranges: ‘a’ to ‘z’ (lowercase ascii letter) ‘A’ to ‘Z’ (uppercase ascii letter) ‘\u00C0’ to ‘\u00D6’ ‘\u00D8’ to ‘\u00F6’ ‘\u00F8’ to ‘\u00FF’ ‘\u0100’ to ‘\uFFFE’ Then following characters can contain letters and numbers. Here are a few examples of valid identifiers (here, variable names): 1234def namedef item3def with_underscoredef $dollarStart But the following ones are invalid identifiers: 123def 3tierdef a+bdef a#b All keywords are also valid identifiers when following a dot: 12345foo.asfoo.assertfoo.breakfoo.casefoo.catch Quoted identifiersQuoted identifiers appear after the dot of a dotted expression. For instance, the name part of the person.name expression can be quoted with person.&quot;name&quot; or person.&#39;name&#39;. This is particularly interesting when certain identifiers contain illegal characters that are forbidden by the Java Language Specification, but which are allowed by Groovy when quoted. For example, characters like a dash, a space, an exclamation mark, etc. 1234567def map = [:]map."an identifier with a space and double quotes" = "ALLOWED"map.'with-dash-signs-and-single-quotes' = "ALLOWED"assert map."an identifier with a space and double quotes" == "ALLOWED"assert map.'with-dash-signs-and-single-quotes' == "ALLOWED" As we shall see in the following section on strings, Groovy provides different string literals. All kind of strings are actually allowed after the dot: 123456map.'single quote'map."double quote"map.'''triple single quote'''map."""triple double quote"""map./slashy string/map.$/dollar slashy string/$ There’s a difference between plain character strings and Groovy’s GStrings (interpolated strings), as in that the latter case, the interpolated values are inserted in the final string for evaluating the whole identifier: 1234def firstname = "Homer"map."Simpson-$&#123;firstname&#125;" = "Homer Simpson"assert map.'Simpson-Homer' == "Homer Simpson" StringsText literals are represented in the form of chain of characters called strings. Groovy lets you instantiate java.lang.String objects, as well as GStrings (groovy.lang.GString) which are also called interpolated strings in other programming languages. Single quoted stringSingle quoted strings are a series of characters surrounded by single quotes: 1'a single quoted string' Single quoted strings are plain java.lang.String and don’t support interpolation. String concatenationAll the Groovy strings can be concatenated with the + operator: 1assert 'ab' == 'a' + 'b' Triple single quoted stringTriple single quoted strings are a series of characters surrounded by triplets of single quotes: 1Triple single quoted strings are a series of characters surrounded by triplets of single quotes: Triple single quoted strings are plain java.lang.String and don’t support interpolation. Triple single quoted strings are multiline. You can span the content of the string across line boundaries without the need to split the string in several pieces, without contatenation or newline escape characters: 123def aMultilineString = '''line oneline twoline three''' If your code is indented, for example in the body of the method of a class, your string will contain the whitespace of the indentation. The Groovy Development Kit contains methods for stripping out the indentation with the String#stripIndent() method, and with the String#stripMargin() method that takes a delimiter character to identify the text to remove from the beginning of a string. When creating a string as follows: 12345def startingAndEndingWithANewline = '''line oneline twoline three''' You will notice that the resulting string contains a newline character as first character. It is possible to strip that character by escaping the newline with a backslash: 1234567def strippedFirstNewline = '''\line oneline twoline three'''assert !strippedFirstNewline.startsWith('\n') Escaping special charactersYou can escape single quotes with the the backslash character to avoid terminating the string literal: 1'an escaped single quote: \' needs a backslash' And you can escape the escape character itself with a double backslash: 1'an escaped escape character: \\ needs a double backslash' Some special characters also use the backslash as escape character: ‘\t’ tabulation ‘\b’ backspace ‘\n’ newline ‘\r’ carriage return ‘\f’ formfeed ‘\‘ backslash ‘\’’ single quote (for single quoted and triple single quoted strings) ‘\”‘ double quote (for double quoted and triple double quoted strings) Unicode escape sequenceFor characters that are not present on your keyboard, you can use unicode escape sequences: a backslash, followed by ‘u’, then 4 hexadecimal digits. For example, the Euro currency symbol can be represented with: 1'The Euro currency symbol: \u20AC' Double quoted stringDouble quoted strings are a series of characters surrounded by double quotes: 1"a double quoted string" Double quoted strings are plain java.lang.String if there’s no interpolated expression, but are groovy.lang.GString instances if interpolation is present. To escape a double quote, you can use the backslash character: “A double quote: \””. String interpolationAny Groovy expression can be interpolated in all string literals, apart from single and triple single quoted strings. Interpolation is the act of replacing a placeholder in the string with its value upon evaluation of the string. The placeholder expressions are surrounded by ${} or prefixed with $ for dotted expressions. The expression value inside the placeholder is evaluated to its string representation when the GString is passed to a method taking a String as argument by calling toString() on that expression. Here, we have a string with a placeholder referencing a local variable: 1234def name = 'Guillaume' // a plain stringdef greeting = "Hello $&#123;name&#125;"assert greeting.toString() == 'Hello Guillaume' But any Groovy expression is valid, as we can see in this example with an arithmetic expression: 12def sum = "The sum of 2 and 3 equals $&#123;2 + 3&#125;"assert sum.toString() == 'The sum of 2 and 3 equals 5' Not only are expressions allowed in between the ${} placeholder, but so are statements. However, a statement’s value is just null. So if several statements are inserted in that placeholder, the last one should somehow return a meaningful value to be inserted. For instance, “The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}” is supported and works as expected but a good practice is usually to stick to simple expressions inside GString placeholders. In addition to ${} placeholders, we can also use a lone $ sign prefixing a dotted expression: 12def person = [name: 'Guillaume', age: 36]assert "$person.name is $person.age years old" == 'Guillaume is 36 years old' But only dotted expressions of the form a.b, a.b.c, etc, are valid, but expressions that would contain parentheses like method calls, curly braces for closures, or arithmetic operators would be invalid. Given the following variable definition of a number: 1def number = 3.14 The following statement will throw a groovy.lang.MissingPropertyException because Groovy believes you’re trying to access the toString property of that number, which doesn’t exist: 123shouldFail(MissingPropertyException) &#123; println "$number.toString()"&#125; You can think of “$number.toString()” as being interpreted by the parser as “${number.toString()}”. If you need to escape the $ or ${} placeholders in a GString so they appear as is without interpolation, you just need to use a \ backslash character to escape the dollar sign: 1assert '$&#123;name&#125;' == "\$&#123;name&#125;" Special case of interpolating closure expressionsSo far, we’ve seen we could interpolate arbitrary expressions inside the ${} placeholder, but there is a special case and notation for closure expressions. When the placeholder contains an arrow, ${→}, the expression is actually a closure expression — you can think of it as a closure with a dollar prepended in front of it: 12345def sParameterLessClosure = "1 + 2 == $&#123;-&gt; 3&#125;" ①assert sParameterLessClosure == '1 + 2 == 3'def sOneParamClosure = "1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;" ②assert sOneParamClosure == '1 + 2 == 3' ① The closure is a parameterless closure which doesn’t take arguments. ② Here, the closure takes a single java.io.StringWriter argument, to which you can append content with the &lt;&lt; leftShift operator. In either case, both placeholders are embedded closures. In appearance, it looks like a more verbose way of defining expressions to be interpolated, but closures have an interesting advantage over mere expressions: lazy evaluation. Let’s consider the following sample: 1234567891011def number = 1 ①def eagerGString = "value == $&#123;number&#125;"def lazyGString = "value == $&#123; -&gt; number &#125;"assert eagerGString == "value == 1" ②assert lazyGString == "value == 1" ③number = 2 ④assert eagerGString == "value == 1" ⑤assert lazyGString == "value == 2" ⑥ ① We define a number variable containing 1 that we then interpolate within two GStrings, as an expression in eagerGString and as a closure in lazyGString. ② We expect the resulting string to contain the same string value of 1 for eagerGString. ③ Similarly for lazyGString ④ Then we change the value of the variable to a new number ⑤ With a plain interpolated expression, the value was actually bound at the time of creation of the GString. ⑥ But with a closure expression, the closure is called upon each coercion of the GString into String, resulting in an updated string containing the new number value. An embedded closure expression taking more than one parameter will generate an exception at runtime. Only closures with zero or one parameters are allowed. Interoperability with JavaWhen a method (whether implemented in Java or Groovy) expects a java.lang.String, but we pass a groovy.lang.GString instance, the toString() method of the GString is automatically and transparently called. String takeString(String message) { ④ assert message instanceof String ⑤ return message} def message = “The message is ${‘hello’}” ①assert message instanceof GString ② def result = takeString(message) ③assert result instanceof Stringassert result == ‘The message is hello’ ① We create a GString variable ② We double check it’s an instance of the GString ③ We then pass that GString to a method taking a String as parameter ④ The signature of the takeString() method explicitly says its sole parameter is a String ⑤ We also verify that the parameter is indeed a String and not a GString. GString and String hashCodesAlthough interpolated strings can be used in lieu of plain Java strings, they differ with strings in a particular way: their hashCodes are different. Plain Java strings are immutable, whereas the resulting String representation of a GString can vary, depending on its interpolated values. Even for the same resulting string, GStrings and Strings don’t have the same hashCode. 1assert "one: $&#123;1&#125;".hashCode() != "one: 1".hashCode() GString and Strings having different hashCode values, using GString as Map keys should be avoided, especially if we try to retrieve an associated value with a String instead of a GString. 1234def key = "a"def m = ["$&#123;key&#125;": "letter $&#123;key&#125;"] ①assert m["a"] == null ② ① The map is created with an initial pair whose key is a GString ② When we try to fetch the value with a String key, we will not find it, as Strings and GString have different hashCode values Triple double quoted stringTriple double quoted strings behave like double quoted strings, with the addition that they are multiline, like the triple single quoted strings. 123456789101112def name = 'Groovy'def template = """ Dear Mr $&#123;name&#125;, You're the winner of the lottery! Yours sincerly, Dave"""assert template.toString().contains('Groovy') Neither double quotes nor single quotes need be escaped in triple double quoted strings. Slashy stringBeyond the usual quoted strings, Groovy offers slashy strings, which use / as delimiters. Slashy strings are particularly useful for defining regular expressions and patterns, as there is no need to escape backslashes. Example of a slashy string: 12def fooPattern = /.*foo.*/assert fooPattern == '.*foo.*' Only forward slashes need to be escaped with a backslash: 12def escapeSlash = /The character \/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' Slashy strings are multiline: 1234def multilineSlashy = /one two three/assert multilineSlashy.contains('\n') Slashy strings can also be interpolated (ie. a GString): 1234def color = 'blue'def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == 'a blue car' There are a few gotchas to be aware of. An empty slashy string cannot be represented with a double forward slash, as it’s understood by the Groovy parser as a line comment. That’s why the following assert would actually not compile as it would look like a non-terminated statement: 1assert '' == // As slashy strings were mostly designed to make regexp easier so a few things that are errors in GStrings like $() will work with slashy strings. Dollar slashy stringDollar slashy strings are multiline GStrings delimited with an opening $/ and and a closing /$. The escaping character is the dollar sign, and it can escape another dollar, or a forward slash. But both dollar and forward slashes don’t need to be escaped, except to escape the dollar of a string subsequence that would start like a GString placeholder sequence, or if you need to escape a sequence that would start like a closing dollar slashy string delimiter. Here’s an example: 123456789101112131415161718192021222324252627def name = "Guillaume"def date = "April, 1st"def dollarSlashy = $/ Hello $name, today we're $&#123;date&#125;. $ dollar sign $$ escaped dollar sign \ backslash / forward slash $/ escaped forward slash $$$/ escaped opening dollar slashy $/$$ escaped closing dollar slashy/$assert [ 'Guillaume', 'April, 1st', '$ dollar sign', '$ escaped dollar sign', '\\ backslash', '/ forward slash', '/ escaped forward slash', '$/ escaped opening dollar slashy', '/$ escaped closing dollar slashy'].every &#123; dollarSlashy.contains(it) &#125; String summary table String name String syntax Interpolated Multiline Escape character Single quoted ‘…​’ \ Triple single quoted ‘’’…​’’’ √ \ Double quoted ‘’…​’’ √ \ Triple double quoted “””…””” √ √ \ Slashy /…​/ √ √ \ Dollar slashy \$/…​/\$ √ √ $ CharactersUnlike Java, Groovy doesn’t have an explicit character literal. However, you can be explicit about making a Groovy string an actual character, by three different means: 12345678char c1 = 'A' ①assert c1 instanceof Characterdef c2 = 'B' as char ②assert c2 instanceof Characterdef c3 = (char)'C' ③assert c3 instanceof Character ① by being explicit when declaring a variable holding the character by specifying the char type ② by using type coercion with the as operator ③ by using a cast to char operation The first option ① is interesting when the character is held in a variable, while the other two (② and ③) are more interesting when a char value must be passed as argument of a method call. NumbersIntegral literalsThe integral literal types are the same as in Java: byte char short int long java.lang.BigInteger You can create integral numbers of those types with the following declarations: 123456789// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6 If you use optional typing by using the def keyword, the type of the integral number will vary: it’ll adapt to the capacity of the type that can hold that number. For positive numbers: 123456789101112131415161718def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger As well as for negative numbers: 123456789101112131415161718def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger Alternative non-base 10 representationsNumbers can also be represented in binary, octal, hexadecimal and decimal bases. Binary literalBinary numbers start with a 0b prefix: 1234567891011121314151617int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175 Octal literalOctal numbers are specified in the typical format of 0 followed by octal digits. 1234567891011121314151617int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63 Hexadecimal literalHexadecimal numbers are specified in the typical format of 0x followed by hex digits. 1234567891011121314151617181920int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double('0x1.0p0')assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119 Decimal literalsThe decimal literal types are the same as in Java: float double java.lang.BigDecimal You can create decimal numbers of those types with the following declarations: 123456// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456 Decimals can use exponents, with the e or E exponent letter, followed by an optional sign, and a integral number representing the exponent: 12345assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04assert 5e-1 == 0.5 Conveniently for exact decimal number calculations, Groovy choses java.lang.BigDecimal as its decimal number type. In addition, both float and double are supported, but require an explicit type declaration, type coercion or suffix. Even if BigDecimal is the default for decimal numbers, such literals are accepted in methods or closures taking float or double as parameter types. Decimal numbers can’t be represented using a binary, octal or hexadecimal representation. Underscore in literalsWhen writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups: 12345678long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010 Number type suffixesWe can force a number (including binary, octals and hexadecimals) to have a specific type by giving a suffix (see table below), either uppercase or lowercase. Type Suffix BigInteger G or g Long L or l Integer I or i BigDecimal G or g Double D or d Float F or f Examples: 12345678910111213assert 42I == new Integer('42')assert 42i == new Integer('42') // lowercase i more readableassert 123L == new Long("123") // uppercase L more readableassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integerassert 456G == new BigInteger('456')assert 456g == new BigInteger('456')assert 123.45 == new BigDecimal('123.45') // default BigDecimal type usedassert 1.200065D == new Double('1.200065')assert 1.234F == new Float('1.234')assert 1.23E23D == new Double('1.23E23')assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal Math operationsAlthough operators are covered later on, it’s important to discuss the behavior of math operations and what their resulting types are. Division and power binary operations aside (covered below), binary operations between byte, char, short and int result in int binary operations involving long with byte, char, short and int result in long binary operations involving BigInteger and any other integral type result in BigInteger binary operations involving BigDecimal with byte, char, short, int and BigInteger result in BigDecimal binary operations between float, double and BigDecimal result in double binary operations between two BigDecimal result in BigDecimal The following table summarizes those rules: byte char short int long BigInteger float double BigDecimal byte byte char short int long BigInteger float double BigDecimal char char short int long BigInteger float double BigDecimal short short int long BigInteger float double BigDecimal int int long BigInteger float double BigDecimal long long BigInteger float double BigDecimal BigInteger BigInteger float double BigDecimal float float double BigDecimal double double BigDecimal BigDecimal BigDecimal Thanks to Groovy’s operator overloading, the usual arithmetic operators work as well with BigInteger and BigDecimal, unlike in Java where you have to use explicit methods for operating on those numbers. The case of the division operatorThe division operators / (and /= for division and assignment) produce a double result if either operand is a float or double, and a BigDecimal result otherwise (when both operands are any combination of an integral type short, char, byte, int, long, BigInteger or BigDecimal). BigDecimal division is performed with the divide() method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a MathContext with a precision of the maximum of the two operands’ precision plus an extra precision of 10, and a scale of the maximum of 10 and the maximum of the operands’ scale. For integer division like in Java, you should use the intdiv() method, as Groovy doesn’t provide a dedicated integer division operator symbol. The case of the power operatorThe power operation is represented by the ** operator, with two parameters: the base and the exponent. The result of the power operation depends on its operands, and the result of the operation (in particular if the result can be represented as an integral value). The following rules are used by Groovy’s power operation to determine the resulting type: If the exponent is a decimal value if the result can be represented as an Integer, then return an Integer else if the result can be represented as a Long, then return a Long otherwise return a Double If the exponent is an integral value if the exponent is strictly negative, then return an Integer, Long or Double if the result value fits in that type if the exponent is positive or zero if the base is a BigDecimal, then return a BigDecimal result value if the base is a BigInteger, then return a BigInteger result value if the base is an Integer, then return an Integer if the result value fits in it, otherwise a BigInteger if the base is a Long, then return a Long if the result value fits in it, otherwise a BigInteger We can illustrate those rules with a few examples: 12345678910111213141516171819202122232425262728293031323334353637// base and exponent are ints and the result can be represented by an Integerassert 2 ** 3 instanceof Integer // 8assert 10 ** 9 instanceof Integer // 1_000_000_000// the base is a long, so fit the result in a Long// (although it could have fit in an Integer)assert 5L ** 2 instanceof Long // 25// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger // 10e20assert 1234 ** 123 instanceof BigInteger // 170515806212727042875...// the base is a BigDecimal and the exponent a negative int// but the result can be represented as an Integerassert 0.5 ** -2 instanceof Integer // 4// the base is an int, and the exponent a negative float// but again, the result can be represented as an Integerassert 1 ** -0.3f instanceof Integer // 1// the base is an int, and the exponent a negative int// but the result will be calculated as a Double// (both base and exponent are actually converted to doubles)assert 10 ** -1 instanceof Double // 0.1// the base is a BigDecimal, and the exponent is an int, so return a BigDecimalassert 1.2 ** 10 instanceof BigDecimal // 6.1917364224// the base is a float or double, and the exponent is an int// but the result can only be represented as a Double valueassert 3.4f ** 5 instanceof Double // 454.35430372146965assert 5.6d ** 2 instanceof Double // 31.359999999999996// the exponent is a decimal value// and the result can only be represented as a Double valueassert 7.8 ** 1.9 instanceof Double // 49.542708423868476assert 2 ** 0.1f instanceof Double // 1.0717734636432956 BooleansBoolean is a special data type that is used to represent truth values: true and false. Use this data type for simple flags that track true/false conditions. Boolean values can be stored in variables, assigned into fields, just like any other data type: 123def myBooleanVariable = trueboolean untypedBooleanVar = falsebooleanField = true true and false are the only two primitive boolean values. But more complex boolean expressions can be represented using logical operators. In addition, Groovy has special rules (often referred to as Groovy Truth) for coercing non-boolean objects to a boolean value. ListsGroovy uses a comma-separated list of values, surrounded by square brackets, to denote lists. Groovy lists are plain JDK java.util.List, as Groovy doesn’t define its own collection classes. The concrete list implementation used when defining list literals are java.util.ArrayList by default, unless you decide to specify otherwise, as we shall see later on. 1234def numbers = [1, 2, 3] ①assert numbers instanceof List assert numbers.size() == 3 ② ① We define a list numbers delimited by commas and surrounded by square brackets, and we assign that list into a variable ② The list is an instance of Java’s java.util.List interface ③ The size of the list can be queried with the size() method, and shows our list contains 3 elements In the above example, we used a homogeneous list, but you can also create lists containing values of heterogeneous types: 1def heterogeneous = [1, "a", true] ① ① Our list here contains a number, a string and a boolean value We mentioned that by default, list literals are actually instances of java.util.ArrayList, but it is possible to use a different backing type for our lists, thanks to using type coercion with the as operator, or with explicit type declaration for your variables: 12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList ①assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] ②assert otherLinked instanceof java.util.LinkedList ① We use coercion with the as operator to explicitly request a java.util.LinkedList implementation ② We can say that the variable holding the list literal is of type java.util.LinkedList You can access elements of the list with the [] subscript operator (both for reading and setting values) with positive indices or negative indices to access elements from the end of the list, as well as with ranges, and use the &lt;&lt; leftShift operator to append elements to a list: 1234567891011121314151617def letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a' ①assert letters[1] == 'b'assert letters[-1] == 'd' ②assert letters[-2] == 'c'letters[2] = 'C' ③assert letters[2] == 'C'letters &lt;&lt; 'e' ④assert letters[ 4] == 'e'assert letters[-1] == 'e'assert letters[1, 3] == ['b', 'd'] ⑤assert letters[2..4] == ['C', 'd', 'e'] ⑥ ① Access the first element of the list (zero-based counting) ② Access the last element of the list with a negative index: -1 is the first element from the end of the list ③ Use an assignment to set a new value for the third element of the list ④ Use the &lt;&lt; leftShift operator to append an element at the end of the list ⑤ Access two elements at once, returning a new list containing those two elements ⑥ Use a range to access a range of values from the list, from a start to an end element position As lists can be heterogeneous in nature, lists can also contain other lists to create multi-dimensional lists: 12def multi = [[0, 1], [2, 3]] ①assert multi[1][0] == 2 ② ① Define a list of list of numbers ② Access the second element of the top-most list, and the first element of the inner list ArraysGroovy reuses the list notation for arrays, but to make such literals arrays, you need to explicitely define the type of the array through coercion or type declaration. 123456789String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] ①assert arrStr instanceof String[] ②assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] ③assert numArr instanceof int[] ④assert numArr.size() == 3 ① Define an array of strings using explicit variable type declaration ② Assert that we created an array of strings ③ Create an array of ints with the as operator ④ Assert that we created an array of primitive ints You can also create multi-dimensional arrays: 123456def matrix3 = new Integer[3][3] ①assert matrix3.size() == 3Integer[][] matrix2 ②matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][] ① You can define the bounds of a new array ② Or declare an array without specifying its bounds Access to elements of an array follows the same notation as for lists: 12345String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']assert names[0] == 'Cédric' ①names[2] = 'Blackdrag' ②assert names[2] == 'Blackdrag' ① Retrieve the first element of the array ② Set the value of the third element of the array to a new value Java’s array initializer notation is not supported by Groovy, as the curly braces can be misinterpreted with the notation of Groovy closures. MapsSometimes called dictionaries or associative arrays in other languages, Groovy features maps. Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets. 123456789101112def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']①assert colors['red'] == '#FF0000' ②assert colors.green == '#00FF00' ③colors['pink'] = '#FF00FF' ④colors.yellow = '#FFFF00' ⑤assert colors.pink == '#FF00FF'assert colors['yellow'] == '#FFFF00'assert colors instanceof java.util.LinkedHashMap ① We define a map of string color names, associated with their hexadecimal-coded html colors ② We use the subscript notation to check the content associated with the red key ③ We can also use the property notation to assert the color green’s hexadecimal representation ④ Similarly, we can use the subscript notation to add a new key/value pair ⑤ Or the property notation, to add the yellow color When using names for the keys, we actually define string keys in the map.Groovy creates maps that are actually instances of java.util.LinkedHashMap. If you try to access a key which is not present in the map: 1assert colors.unknown == null You will retrieve a null result. In the examples above, we used string keys, but you can also use values of other types as keys: 123def numbers = [1: 'one', 2: 'two']assert numbers[1] == 'one' Here, we used numbers as keys, as numbers can unambiguously be recognized as numbers, so Groovy will not create a string key like in our previous examples. But consider the case you want to pass a variable in lieu of the key, to have the value of that variable become the key: 12345def key = 'name'def person = [key: 'Guillaume'] ①assert !person.containsKey('name') ②assert person.containsKey('key') ③ ① The key associated with the ‘Guillaume’ name will actually be the “key” string, not the value associated with the key variable ② The map doesn’t contain the ‘name’ key ③Instead, the map contains a ‘key’ key You can also pass quoted strings as well as keys: [“name”: “Guillaume”]. This is mandatory if your key string isn’t a valid identifier, for example if you wanted to create a string key containing a hash like in: [“street-name”: “Main street”]. When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses: 1234person = [(key): 'Guillaume'] ①assert person.containsKey('name') ②assert !person.containsKey('key') ③ ① This time, we surround the key variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key ② The map does contain the name key ③ But the map doesn’t contain the key key as before that’s all, thanks for your reading.]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译] 高级 DataBinding: 绑定到 LiveData (单向绑定 & 双向绑定)]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AF%91-%E9%AB%98%E7%BA%A7-DataBinding-%E7%BB%91%E5%AE%9A%E5%88%B0-LiveData-%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[声明： 本文翻译自Medium 文章 数据绑定库在 Android 应用程序的生产中越来越受欢迎，因为它扩大了 MVVM 架构的优势。它允许您使用声明性格式而不是以编程方式将布局中的UI组件绑定到应用程序中的数据源。自动通知UI关于数据的变化并获得传播回来的UI属性的变化，这不是很好吗？那么让我们看看我们如何通过单向和双向绑定绑定到 LiveData ！ 为什么绑定到 LiveData？使用生命周期感知组件（如LiveData）的优点包括： 没有因停止活动而崩溃。如果观察者的生命周期处于非活动状态，例如活动位于后台堆栈中，则它不会收到任何 LiveData 事件。 自适应的配置更改。如果由于配置更改（例如，设备旋转）而重新创建 Fragment 或 Activity ，则会立即接收最新的可用数据。 没有内存泄漏。无需手动处理订阅。当相关的生命周期被破坏时，观察者会自行清理。 LiveData VS ObservableFields与实现 Observable 的对象 （例如可观察字段）不同 ， LiveData 对象知道订阅数据更改的观察者的生命周期。无论 LiveData 和 ObservableFields， 他们都可以实现其观察数据变化，但是在其他方面，LiveData 有它特殊的优势： 手动生命周期处理。UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些，因为它在观察时意识到相关的生命周期状态变化。 Transformations 和 MediatorLiveData 的更多功能。使用 LiveData 将使您受益于转换的强大功能，并且还可以向 MediatorLiveData 添加多个源。因此，如果布局中有5个 EditText 视图，则无需从 Activity 或 Fragment 中观察全部 5个 视图。您只能观察一个 MediatorLiveData，这将为您节省一些代码和逻辑复杂性。 共享资源。创建扩展 LiveData 的自定义对象将允许您连接到系统服务一次，然后任何需要该资源的观察者只能观察该对象。 开始使用带数据绑定的 LiveData要将 LiveData 对象与绑定类一起使用，需要指定生命周期所有者以定义 LiveData 对象的范围。以下示例说明如何在实例化绑定类之后将活动设置为生命周期所有者： 1234// Inflate view and obtain an instance of the binding class.val binding: MainBinding = DataBindingUtil.setContentView(this, R.layout.main)// Specify the current activity as the lifecycle owner.binding.setLifecycleOwner(this) 所以现在我们可以在布局文件 main.xml 中使用 LiveData 对象，如下所示，commentText 的值将设置到 text 属性上： 12&lt;android.support.design.widget.TextInputEditText android:text="@&#123;viewModel.commentText&#125;" /&gt; 在某些情况下，在数据绑定中使用 LiveData 时，可能会出现警告“…是一个盒装字段但需要取消装箱以执行…”。这表示使用可空类型作为 LiveData 对象值。要禁止警告，建议使用原语（ ObservableInt 而不是 MutableLiveData ）或使用safeUnbox，如下所示： 1android:text="@&#123;safeUnbox(viewModel.commentText)&#125;" 实现双向绑定在预期从 UI 更新 LiveData 值的情况下，双向绑定变得非常方便。在代码中访问它时，我们希望收到更新的值。为了能够做到这一点，我们将在绑定表达式的花括号之前添加“=”： 12&lt;android.support.design.widget.TextInputEditText android:text="@=&#123;viewModel.commentText&#125;" /&gt; 现在，只要用户在屏幕上的视图中键入新文本，LiveData 对象就会更新，当访问其值时，我们将收到最新的更新。 创建自定义绑定适配器为了更进一步，让我们想一个不那么通用的案例。想象一下，我们希望通过使用 LiveData 对象的数据绑定在 ViewPager 中设置当前选项卡。为此，我们需要在 BindingAdapter 的帮助下为 ViewPager 创建自定义属性 currentTab ： 123456789101112companion object &#123; @BindingAdapter("currentTab") @JvmStatic fun setNewTab(pager: ViewPager, newTab: MutableLiveData&lt;Int&gt;) &#123; newTab.value?.let &#123; //don't forget to break possible infinite loops! if (pager.currentItem != itemLiveData.value) &#123; pager.setCurrentItem(newTab.value, true) &#125; &#125; &#125;&#125; 所以现在我们可以将新属性添加到布局文件中，并从 LiveData 对象值设置 ViewPager 的当前项： 12&lt;android.support.v4.view.ViewPager app:currentTab="@&#123;viewModel.pagerCurrentTab&#125;"/&gt; 当新值设置为 pagerCurrentTab 对象时，将执行 BindingAdapter 正文中的代码。 使用自定义属性的双向绑定现在，在更新我们创建的 LivaData 对象中的值时，ViewPager 会滚动到新位置。这很好，除了在我们的用例中，用户还与 UI 交互并更改ViewPager 的位置，但 LiveData 对象仍保留“旧”值。我们希望收到有关此属性更改的通知，以便基于它实现某些逻辑或只检查当前值。这可以通过实现双向绑定来实现。 我们将要对布局文件进行以下更改： 12&lt;android.support.v4.view.ViewPager app:currentTab="@=&#123;viewModel.pagerCurrentTab&#125;"/&gt; BindingAdapter我们已经有了，另外需要创建一个 InverseBindingAdapter。此时，数据绑定知道在数据更改时要做什么（它调用使用了 @BindingAdapter 注释的方法）以及在 view 属性更改时调用的内容（它调用使用了 InverseBindingListener 注释的方法）。因此，如果用户滑动 ViewPager 选项卡，LiveData 对象将使用新值进行更新。但是，为了知道属性何时或如何更改，我们引入了自定义事件。事件的命名默认为具有后缀“AttrChanged”的属性名称。在这个场景里就是 currentTabAttrChanged。 1234567891011121314companion object &#123; @BindingAdapter("currentTab") @JvmStatic fun setTab(pager: ViewPager, itemLiveData: MutableLiveData&lt;Int&gt;)&#123; itemLiveData.value?.let &#123; //don't forget to break possible infinite loops! if (pager.currentItem != itemLiveData.value) &#123; pager.setCurrentItem(itemLiveData.value, true) &#125; &#125; &#125; @InverseBindingAdapter(attribute = "currentTab", event = "currentTabAttrChanged") @JvmStatic fun getTab(pager: ViewPager) = pager.currentItem 一句警告使用双向数据绑定时，请注意不要引入无限循环。当用户更改属性时，将调用注释@InverseBindingAdapter 的方法。反过来，这将调用注释 @BindingAdapter 的方法，这将触发对注释 @InverseBindingAdapter 的方法的另一个调用，依此类推。 因此，通过比较注释 @BindingAdapter 的方法中的新旧值来打破可能的无限循环非常重要。 一些最后的想法Android 组件的生命周期很复杂，手动管理可能很麻烦，因为保持 UI 与数据源保持同步，因此引入 LiveData 是生命周期管理中的一大步。将数据绑定添加到项目中可以使代码更加简洁和反应，因为数据源中的更改可以自动传播到 UI，同时考虑了到配置和生命周期状态。但是，使用数据绑定库不应仅限于将数据模型的属性设置为文本字段。使用单向和双向绑定绑定到 LiveData 将允许您充分利用 Observer 模式和生命周期感知。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Databinding</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 MVVM]]></title>
    <url>%2F2019%2F04%2F12%2FJetpack-%E4%B9%8B-MVVM%2F</url>
    <content type="text"><![CDATA[前置储备：LiveData可以说 MVVM 的好处那是相当多了😁，至少我个人使用来说，是方便了不少❤。 什么是 MVVM 说起 MVVM ，那就要大概提一提 MVC ,MVP 。当然，本文的重点并非 MVC &amp; MVP。 先来说说 MVC 直接贴上维基百科的解释(https://zh.wikipedia.org/wiki/MVC) 即 模型（Model）-视图（View）-控制器（Controller）。MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式最早由Trygve Reenskaug在1978年提出[1]，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 专业人员可以通过自身的专长分组： 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 MVP 维基解释(https://zh.wikipedia.org/wiki/Model-view-presenter) Model-view-presenter，简称MVP，是计算机软件设计工程中一种对针对MVC模式，再审议后所延伸提出的一种软件设计模式。 Model-View-Presenter (MVP) 是用户界面设计模式的一种，被广泛用于便捷自动化单元测试和在呈现逻辑中改良分离关注点（separation of concerns）。 Model 定义用户界面所需要被显示的数据模型，一个模型包含着相关的业务逻辑。 View 视图为呈现用户界面的终端，用以表现来自 Model 的数据，和用户命令路由再经过 Presenter 对事件处理后的数据。 Presenter 包含着组件的事件处理，负责检索 Model 获取数据，和将获取的数据经过格式转换与 View 进行沟通。 MVP 设计模式通常会再加上 Controller 做为整体应用程序的后端程序工作。 MVVM 维基(https://zh.wikipedia.org/wiki/MVVM) MVVM 概述 MVVM（Model–view–viewmodel）是一种软件架构模式。 MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。 MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。MVVM以相同的方式抽象出视图的状态和行为，但PM以不依赖于特定用户界面平台的方式抽象出视图（创建了视图模型）。 MVVM和PM都来自MVC模式。 MVVM由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用派生品）的特性来简化用户界面的事件驱动程序设计。微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。 MVVM也被称为model-view-binder，特别是在不涉及.NET平台的实现中。ZK（Java写的一个Web应用框架）和KnockoutJS（一个JavaScript库）使用model-view-binder。 MVVM模式的组成部分 模型 模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 视图 就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 视图模型 视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。 绑定器 声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。 理论基础 MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。 MVVM模式试图获得MVC提供的功能性开发分离的两个优点，同时利用数据绑定的优势和通过绑定数据的框架尽可能接近纯应用程序模型。它使用绑定器、视图模型和任何业务层的数据检查功能来验证传入的数据。结果是模型和框架驱动尽可能多的操作，消除或最小化直接操纵视图的应用程序逻辑（如代码隐藏）。 MVVM 特点在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层： 本节参考自 https://juejin.im/post/58cf2d791b69e6006b851605 a 、View: 视图层，对应xml文件与Activity/Fragment； b 、Presenter: 逻辑控制层，同时持有View和Model对象； c 、Model: 实体层，负责获取实体数据。 MVP模式有其很大的优点： 1.解耦合，业务逻辑和视图分离； 2.项目代码结构（文件夹）清晰，一看就知道什么类干什么事情； 3.便于单元测试（其实还是第一点）； 4.协同工作（例如在设计师没出图之前可以先写一些业务逻辑代码或者其他人接手代码改起来比较容易）； 但是也有美中不足的部分，MVP模式的缺点如下： 1.Presente层与View层是通过接口进行交互的，接口粒度不好控制。粒度太小，就会存在大量接口的情况，使代码太过碎版化;粒度太大，解耦效果不好。因为View定义的方法并不一定全部要用到，可能只是后面要用到先定义出来（后面要不要删也未知），而且如果后面有些方法要删改，Presenter和Activity都要删改，比较麻烦； 2.V层与P层还是有一定的耦合度。一旦V层某个UI元素更改，那么对应的接口就必须得改，数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。如果这一层也能解耦就更好了。 3.复杂的业务同时也可能会导致P层太大，代码臃肿的问题依然不能解决，这已经不是接口粒度把控的问题了，一旦业务逻辑越来越多，View定义的方法越来越多，会造成Activity和Fragment实现的方法越来越多，依然臃肿。 MVVM 的优点View和Model进行了双向绑定，两者之间有一方发生变化则会反应在另一方 MVP和MVC的主要区别是，MVP的View不能直接访问Model，需要通过Presenter发送请求，View和Model 不能直接通信。 MVP和MVVM的主要区别是，MVP 的View更新需要通过Presenter，而MVVM不需要，因为View 和Model进行了双向绑定，数据的修改会直接反应在View上，而View的修改也会导致数据变更，此时ViewModel需要做的是业务逻辑处理，以及修改View和Model的状态 原文：https://blog.csdn.net/Ghost_tal/article/details/82052377 MVVM &amp; LiveData使用 LiveData 的好处 UI 和数据保持一致性 LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。 没有内存泄漏 观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。 不会因 UI 暂停而崩溃 如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。 不再需要手动管理生命周期 UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。 始终保持最新数据 如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。 配置更改自动处理 如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。 共享资源 您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。 MVVM 每一层的处理Model show me the code as flowing：12345678910111213141516class MainRepository : BaseRepository() &#123; val loadSuccess = MutableLiveData&lt;FirstCategoryResp&gt;() fun loadData() &#123; compositeDisposable.add(Flowable.just(Any()) .doOnNext &#123; showLoading() &#125; .subscribeOn(Schedulers.io()) .flatMap &#123; WebApiService.getFirstCategories(FirstCategoryReq()) &#125; .doOnNext &#123; loadSuccess.postValue(it) &#125; .doFinally &#123; dismissLoading() &#125; .subscribe(&#123; &#125;, &#123; throwable -&gt; LogUtils.e(throwable, "获取一级分类信息失败") &#125;) ) &#125;&#125; 如上所示： Repository 持有 WebApiService, 同时，持有需要发射的后台数据。比如进行网络请求，数据库操作等。 ViewModel1234567891011class MainViewModel : BaseViewModel&lt;MainRepository&gt;() &#123; override fun initRepo(): MainRepository &#123; return MainRepository() &#125; val loadSuccess: LiveData&lt;FirstCategoryResp&gt; = Transformations.map(repository.loadSuccess) &#123; it &#125; fun loadData() &#123; repository.loadData() &#125;&#125; ViewModel 持有需要发射的 LiveData 数据对象，这里比较特殊，通过 Transformations.map 直接转发来发射自 Repository 的数据 ，同时提供加载数据的方法给 View 调用。方法内部没有任何逻辑，直接转发调用 Repository 的方法进行数据加载。 View123override fun initLiveDataObserver() &#123; viewModel.loadSuccess.observe(this, androidx.lifecycle.Observer &#123; refreshUI(it) &#125;)&#125; 在 View 层，持有 ViewModel，并观察 ViewMode 的数据变化。当有新的数据发射出来时，直接调用更新 UI。 综上，可以看出，从 View -&gt; ViewModel -&gt; Repository,即代表了 V -&gt; VM -&gt; M 这样的单向引用。统一标准为上层直接依赖下层，上传简介观察下层的数据变化，并非下层调用上层的业务逻辑，每一层之间的数据转发都是通过观察者的模式来连接。 Repository 结合 RxJava 使用在上面的示例中，已经展示过在 Repository 里使用 RxJava 进行网络请求的流封装，并且在 BaseViewModel 的 onCleared 方法中，调用 CompositeDisable 的 clear 方法进行后台任务的取消和清除。 而且可以看到，在进行网络数据请求或者任何耗时操作的时候，不需要进行主动的线程切换，因为所有的数据发射，我们都是使用了 postValue 方法，在其内部已经帮我们进行了现场的切换。 LiveData &amp; RxJava 比较两者有很多相似的地方，但是侧重点有所不同。 LiveData 侧重于生命周期的管理。 RxJava 侧重于流式 API 的支持。 总结总体来说，MVVM 是非常值得一试的。就目前的使用情况来看，没发现什么严重的问题。推荐一试。当然，任何东西也都不可能是完美的，始终要抱着辩证的思维去看待一个事情，但是也要保持积极地心态去拥抱新技术的不断涌现，才不至于被潮流所抛弃。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 LiveData]]></title>
    <url>%2F2019%2F04%2F12%2FJetpack-%E4%B9%8B-LiveData%2F</url>
    <content type="text"><![CDATA[什么是 LiveData LiveData是一个可观察的数据持有者类。与常规 observable 不同，LiveData 是生命周期感知的，这意味着它遵从其他应用程序组件的生命周期，例如 Activity，Fragment 或 Service。此感知确保 LiveData 仅更新处于 Activity 生命周期状态应用程序组件的观察者。 使用 LiveData 的好处 既然有了 observable 系列的支持，那为什么还有 LiveData 存在的意义？正所谓存在的就是合理的，也当然就有它存在的理由，下面我们来看看 LiveData 相较于 Observable 有哪些优点： UI 和数据保持一致性 LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。 没有内存泄漏 观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。 不会因 UI 暂停而崩溃 如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。 不再需要手动管理生命周期 UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。 始终保持最新数据 如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。 配置更改自动处理 如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。 共享资源 您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。 如何使用 LiveDate 对象 包括以下步骤： 创建一个 LiveData 用于保存特定类型数据的实例。这通常在您的 ViewModel 内完成 。 创建一个 Observer 定义 onChanged() 方法的对象，该对象负责处理 LiveData 对象数据更改时发出的数据。通常Observer 在 UI 控制器中创建，例如 Activity 或 Fragment 。 使用 LiveData 的 observe 方法将 Observer 绑定到 LiveData 对象。通常在UI控制器中完成绑定，例如 Activity 或 Fragment 。 创建 LiveData 对象 在 ViewModel 中创建 LiveData 对象： 1234567class NameViewModel : ViewModel() &#123; // Create a LiveData with a String val currentName: MutableLiveData&lt;String&gt; by lazy &#123; MutableLiveData&lt;String&gt;() &#125;&#125; 观察 LiveData 对象 在 UI 中观察 LiveData: 1234567891011121314151617181920212223class NameActivity : AppCompatActivity() &#123; private lateinit var model: NameViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // Other code to setup the activity... // Get the ViewModel. model = ViewModelProviders.of(this).get(NameViewModel::class.java) // Create the observer which updates the UI. val nameObserver = Observer&lt;String&gt; &#123; newName -&gt; // Update the UI, in this case, a TextView. nameTextView.text = newName &#125; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.currentName.observe(this, nameObserver) &#125;&#125; 更新 LiveData 对象 如果是在非主线程中更新数据，使用 postValue 方法 1234button.setOnClickListener &#123; val anotherName = "John Doe" model.currentName.postValue(anotherName)&#125; 如果是在主线程中更新数据，使用 setValue 方法 1234button.setOnClickListener &#123; val anotherName = "John Doe" model.currentName.setValue(anotherName)&#125; LiveData 高级部分在 Room 中使用 LiviDataRoom 持久库支持可观察的查询操作，返回 LiveData 对象，可观察的查询写在 DAO 中并成为 DAO 的一部分。Room 将自动生成所有需要的中间代码，以达到数据库被更新时自动发出通知，所生成的中间代码运行在异步线程中，如果你的界面显示的数据源来自 Room，这个特性将显得非常有用。 扩展 LiviData123456789101112131415class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123; private val stockManager = StockManager(symbol) private val listener = &#123; price: BigDecimal -&gt; value = price &#125; override fun onActive() &#123; stockManager.requestPriceUpdates(listener) &#125; override fun onInactive() &#123; stockManager.removeUpdates(listener) &#125;&#125; 如上所示，如果需要扩展一个 LiveData 对象，我们需要实现以下方法： onActive() 当 LiveData 对象的观察者处于活动状态时调用该方法。 onInactive() 当 LiveData 对象的所有观察者都处于非活动状态时调用该方法。 setValue(T) 此方法 LiveData 实例的值发生更新时调用，并通知所有活动的观察者。 可以像下面这样使用上面扩展的 LiveData 对象： 1234567override fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) val myPriceListener: LiveData&lt;BigDecimal&gt; = ... myPriceListener.observe(this, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt; // Update the UI. &#125;)&#125; 转换 LiveData 有时候希望在将 LiveData 对象分发给观察者之前对其中存储的值进行更改 ，或者可能需要此 LiveData 根据另一个实例的值返回其他实例。在这种场景下，Lifecycle 中包提供的 Transformations 包含支持这些方案的辅助方法和类。 Transformations.map() 对存储在 LiveData 对象中的值应用一个转换函数，并将结果传播到下游。 1234val userLiveData: LiveData&lt;User&gt; = UserLiveData()val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;user -&gt; "$&#123;user.name&#125; $&#123;user.lastName&#125;"&#125; Transformations.switchMap() 类似于 map()，将一个函数应用于存储在 LiveData 对象中的值，并将结果解包并调度到下游。传递给 switchMap() 参数的这个函数，必须返回一个LiveData对象，如下例所示： 12345private fun getUser(id: String): LiveData&lt;User&gt; &#123; ...&#125;val userId: LiveData&lt;String&gt; = ...val user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125; 合并多个 LiveData 源 MediatorLiveData MediatorLiveData 是一个 LiveData 的子类，允许合并多个 LiveData 源。MediatorLiveData 只要其中任何一个原始 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。 例如，如果一个 LiveData 可以从本地数据库或网络更新的对象，则可以将以下源添加到该 MediatorLiveData 对象： 一个与存储在数据库中的数据关联的 LiveData 对象。 一个与从网络访问的数据关联的 LiveData 对象。 此时，UI 中只需要观察 MediatorLiveData 对象，就可以做到观察两个数据源的更新。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding - 使用可观察的数据对象]]></title>
    <url>%2F2019%2F04%2F09%2FDataBinding%20-%20%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是可观察对象 注：本文参考并翻译自官网链接 可观察性是指对象具备通知外部其数据发生变化的能力。Databinding 支持对象、字段或集合的可观察。 当其中一个可观察数据对象绑定到UI并且数据对象的属性发生更改时，UI将自动更新。 可观察的类型 任何普通对象都可用于数据绑定，但修改对象不会自动导致UI更新。Databinding 可用于为数据对象提供在数据更改时通知其他对象（称为侦听器）的能力。有三种不同类型的可观察类： 对象，字段和 集合。 可观察字段 有时候你的类中如果有一些需要更新的字段，并且只包含以下这些属性，那么可以直接使用系统的实现，而不需要重新实现。这时候，你字需要使用可观察对象作为其字段，或者直接使用可观察字段。 ObservableBoolean ObservableByte ObservableChar ObservableShort ObservableInt ObservableLong ObservableFloat ObservableDouble ObservableParcelable 可观察字段是具有单个字段的自包含可观察对象。原始版本在访问操作期间避免装箱和拆箱。要使用此机制，请public final在 Java 编程语言中创建属性或在 Kotlin 中创建只读属性，如以下示例所示： 12345class User &#123; val firstName = ObservableField&lt;String&gt;() val lastName = ObservableField&lt;String&gt;() val age = ObservableInt()&#125; 要访问字段值，请使用 set() and get() 方法，如下所示 12user.firstName = "Google"val age = user.age Note: Android Studio 3.1 and higher allow you to replace observable fields with LiveData objects, which provide additional benefits to your app. For more information, see Use LiveData to notify the UI about data changes. 可观察集合 可以使用可观察的集合，来存放一些列的数据。通过示例来使用 ObservableArrayMap 类： 12345ObservableArrayMap&lt;String, Any&gt;().apply &#123; put("firstName", "Google") put("lastName", "Inc.") put("age", 17)&#125; 在布局文件中，可以直接使用 key 去拿到这个存储的值： 12345678910111213&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&lt;String, Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text="@&#123;user.lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text="@&#123;String.valueOf(1 + (Integer)user.age)&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 如果 Key 是无序的 int 时，可以使用 ObservableArrayList 类。 12345ObservableArrayList&lt;Any&gt;().apply &#123; add("Google")add("Inc.")add(17)&#125; 在 layout 文件中，可以直接通过索引的方式获取： 1234567891011121314&lt;data&gt; &lt;import type="android.databinding.ObservableList"/&gt; &lt;import type="com.example.my.app.Fields"/&gt; &lt;variable name="user" type="ObservableList&lt;Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text='@&#123;user[Fields.LAST_NAME]&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 可观察的对象 实现 Observable 接口的类，允许注册对象属性更改的侦听器。该 Observable 接口具有添加和删除侦听器的机制，但您必须决定何时发送通知。为了使开发更容易，Databinding 库提供了 BaseObservable 实现侦听器注册机制的类。实现了 BaseObservable 的类，负责在属性更改时发出通知。这是通过 Bindable 为 getter 添加注解，并在 setter 中调用 notifyPropertyChanged() 方法来完成的，如以下示例所示： 12345678910111213141516class User : BaseObservable() &#123; @get:Bindable var firstName: String = "" set(value) &#123; field = value notifyPropertyChanged(BR.firstName) &#125; @get:Bindable var lastName: String = "" set(value) &#123; field = value notifyPropertyChanged(BR.lastName) &#125;&#125; Databinding 在模块包中生成BR命名的类，该类包含用于 Databinding 的资源的ID。 Bindable 注解会在编译期生成一个 BR类 中的的条目。如果无法更改数据类的基类，则 Observable可以使用PropertyChangeRegistry 对象来实现接口， 以便有效地注册和通知侦听器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Databinding</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 Databinding]]></title>
    <url>%2F2019%2F04%2F04%2FJetpack-%E4%B9%8B-Databinding%2F</url>
    <content type="text"><![CDATA[关于DataBinding解释 DataBinding 是一个支持库，允许使用声明格式(而不是编程方式)将布局中的UI组件绑定到应用程序中的数据源。 问题描述 布局通常在 Activity 中定义。例如，下面的代码调用findViewById()查找TextView并将其绑定到 viewModel 变量的 userName 属性: 123findViewById&lt;TextView&gt;(R.id.sample_text).apply &#123; text = viewModel.userName&#125; 以下示例说明如何使用 DataBinding 直接在布局文件中将 text 赋值为 viewmodel.userName。这消除了上面显示调用任何Java代码的需要。注意@{}在赋值表达式中使用语法： 12&lt;TextView android:text="@&#123;viewmodel.userName&#125;" /&gt; 优点 在布局文件中进行数据绑定可以删除在 Activity 中许多的UI框架调用，使其更简单，更易于维护。这还可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常。 缺点 当然任何东西都不是完美无缺的，DataBinding 在使用的时候，因为 APT 会帮助我们生产很多中间模板代码，所在开发调试过程中、以及线上问题跟踪时，有可能定位不到准确的错误点。当然，你要是熟练使用 DataBinding 的话，这些缺点在优点面前就显得微不足道了。所以在这里还是要墙裂推荐这个库的使用。能大量减少繁琐的模板代码。 环境配置 仅支持 Android 4.0（API级别14）或更高版本的设备。 推荐使用最新的 Gradle 插件版本 Android Plugin。因为 DataBinding 支持 1.5.0 或更高版本。 设置构建环境 在 moudule 级别的 build 脚本中，adnroid 节点下配置如下： 123456android &#123; ... dataBinding &#123; enabled = true &#125;&#125; Android Studio 支持数据绑定 Android Studio支持许多用于数据绑定代码的编辑功能。例如，它支持数据绑定表达式的以下功能： 语法突出显示 标记表达式语言语法错误 XML代码补全 如果使用了 Navigation，那么在视图设计中可以直接预览默认值效果： 123&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName, default=my_default&#125;"/&gt; 如果只需要在项目的设计阶段显示默认值，则可以使用tools属性而不是默认表达式值。 在布局中使用编写布局文件并绑定表达式123456789&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewmodel" type="com.myapp.data.ViewModel" /&gt; &lt;/data&gt; &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;&lt;/layout&gt; 如上所示，不同于以往的常规布局方式，在最外层嵌套了一个 layout ,然后下面有一个 data 节点，再下面一个节点才是我们以往的布局根节点。 其中，data 节点下可以做很多事情，包括： 数据声明 使用 import 导包 在根布局节点下面，可以直接使用 data 中声明的变量、使用表达式等很多强大的功能。 使用可观察数据对象 DataBinding 提供了一些列的类和方法，可以轻松地观察数据变更以进行 UI 更改。不再担心在基础数据源发生更改时需要手动刷新UI。您可以观察变量或其属性。该库允许您使对象，字段或集合可观察。 生成绑定数据类 DataBinding 生成用于访问布局中变量和视图的绑定类。 生成的绑定类将布局变量与布局中的视图链接起来，绑定类的名称和包可以自定义。 所有生成的绑定类都继承自 ViewDataBinding类。 默认情况下，生成绑定数据类的名称基于布局文件的名称，将其转换为Pascal大小写并向其添加Binding后缀。 例如 activity_main.xml 生成的目标类名是：ActivityMainBinding]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Databinding</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 框架研究计划]]></title>
    <url>%2F2019%2F04%2F02%2FJetpack-%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[最近一直在做框架方面得预研工作，工作中使用的 MVP 框架到目前为止已经一年多，确实发现 MVP 框架在某些情况下看来，代码冗余量还是比较严重的。 目前公司的项目基本都是一两个人维护并进行迭代，所以 MVP 的分层架构在开发阶段并没有突出多少优势来。 加上 MVP 的接口太多太冗余，这个问题确实是非常突出了。一个项目里面，基本上打开都是接口类。有的甚至都没任何实现的空页面，但是为了遵循 MVP 的设计原则，不得不产生很多类似的模板代码类。 另外一点也是极为重要的，就是 MVP 继承体系，如果抽取多个 Base 类的话，一大堆的泛型传递也是非常繁琐的事情了。 在 2018 年 Google 全新推出的 Jetpack 框架集合，其中就包含了对 MVVM 架构的支持。如下图所示： 基于以上存在的问题和现状，是时候好好研究一下 google 强大的开发框架集合了。 后续会陆续更新一系列的文章，来记录学习的路径。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 Navigation]]></title>
    <url>%2F2019%2F03%2F31%2FJetpack-%E4%B9%8B-Navigation%2F</url>
    <content type="text"><![CDATA[Navigation 是 Jetpack 组件中用于页面路由导航。在 Fragment 应用场景下，特别适合把各种页面逻辑调转和传参等繁琐无畏的模板代码交给 Navigation 来处理，同时能大幅度减少代码的数量和出错的问题。 类比 iOS 的 storyboard 有着很多相似的地方，下面就让我来看看具体如何来实现 Navigation 在项目中的应用。 配置环境module 中的 build 脚本：def nav_version = &quot;2.0.0&quot; implementation &quot;androidx.navigation:navigation-fragment:$nav_version&quot; // For Kotlin use navigation-fragment-ktx implementation &quot;androidx.navigation:navigation-ui:$nav_version&quot; // For Kotlin use navigation-ui-ktx root 的 build 脚本：buildscript { ... dependencies { ... classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0&quot; } } 概念解释导航容器（navigation container） 系统已经为我们实现了一个导航容器，androidx.navigation.fragment.NavHostFragment。 使用方式:将以下代码加入到 Activity 中的 layout 文件内 1234567&lt;fragment android:id=&quot;@+id/nav_host_fragment&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:defaultNavHost=&quot;true&quot; app:navGraph=&quot;@navigation/nav_graph&quot;/&gt; 导航控制器（navigation controller） 通过导航容器，即可拿到导航控制器对象。获取方式见 3.4。 目标页面（destination）App 中所有的 Fragment 都可作为目标页面。 跳转动作（action）App 中任意两个目标页面之间的逻辑跳转，都称作一个跳转动作。 导航视图（navigation graph）导航控制器需要指定一个导航视图，导航视图包括了所有的目标页面以及跳转动作。 FAQ如何创建导航视图（navigation graph）？res -&gt; 右键 -&gt; new -&gt; Android Resources File，在 Resource Type 中选择 Navigation。 如何创建一个目标页面（destination）？res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 点击导航视图面板中的加号（New Destination) -&gt;（Create new destination) -&gt; 输入目标页面名称 注：取消勾选 「Include fragment factory methods」 和 「Include interface callbacks」这两个选项,一般用不到。 如何创建一个跳转动作（action）？res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 选中一个目标页面 -&gt; 目标页面右侧会有一个圆点 -&gt; 拖动这个圆点链接到另一个目标页面 这样一个跳转动作就完成了。 如何获取导航控制器（navigation controller）？有三种方式可以获取到导航控制器 通过 View 获取 KotlinView.findNavController() JavaNavigation.findNavController(View) 通过 Fragment 获取 KotlinFragment.findNavController() JavaNavHostFragment.findNavController(Fragment) 通过 Activity 获取 KotlinActivity.findNavController(viewId: Int) JavaNavigation.findNavController(Activity, @IdRes int viewId) 如何执行跳转？ 首先，所有的跳转都是通过导航控制器（navigation controller）来完成的，所以，我们先要拿到 navigation controller 对象，见 3.4。 拿到 navigation controller 对象之后，我们就可以执行它的 navigate 方法，传入跳转动作的 int 类型 ID，进行相应的跳转。 示例：findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment ) 传递参数：只需要添加参数即可： val args = Bundle() args.putString(ARG,&quot;TEST DATA....&quot;) findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment ,args) 如何控制页面的栈？ 正常情况下，每次导航一个新的目标页面，都把目标页面置为栈顶。 如果某一个跳转（action）执行之后，希望把它的目标页面（destination）置顶并清除原来的栈，就需要在它对应的 action 上加入下面两个属性： app:popUpToInclusive=&quot;true&quot; app:popUpTo=&quot;@+id/page1Fragment&quot; 控制栈的回退 调用 findNavController().navigateUp() 执行一次栈顶出栈操作。 跳转动画可以自定义么？可以的。在 action 节点下添加以下属性指定页面跳转动画：、 app:enterAnim=&quot;@anim/nav_default_enter_anim&quot; app:exitAnim=&quot;@anim/nav_default_exit_anim&quot; app:popEnterAnim=&quot;@anim/nav_default_pop_enter_anim&quot; app:popExitAnim=&quot;@anim/nav_default_pop_exit_anim&quot; 如何设置启动页？每一个导航视图，都必须有且只有一个启动页（start destination） res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 选中一个目标页面 -&gt; 点击导航编辑器面板上的 「小房子」图标即可设置当前页面为启动页。 如何传递参数可以参考我的Github示例代码https://github.com/duanyitao/NavigationDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
</search>
