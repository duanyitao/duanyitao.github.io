<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dart 语法(2)]]></title>
    <url>%2F2020%2F03%2F12%2FDart-%E8%AF%AD%E6%B3%95-2%2F</url>
    <content type="text"><![CDATA[Dart 语法(2)函数Dart 是一门真正面向对象的语言， 甚至其中的函数也是对象，并且有它的类型 Function 。 这也意味着函数可以被赋值给变量或者作为参数传递给其他函数。 也可以把 Dart 类的实例当做方法来调用。 已下是函数实现的示例： 123bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125; 虽然在 Effective Dart 中推荐 公共API中声明类型, 但是省略了类型声明，函数依旧是可以正常使用的： 123isNoble(atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125; 如果函数中只有一句表达式，可以使用简写语法： bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null; =&gt; expr 语法是 { return expr; } 的简写。 =&gt; 符号 有时也被称为 箭头 语法。 提示： 在箭头 (=&gt;) 和分号 (;) 之间只能使用一个 表达式 ，不能是 语句 。 例如：不能使用 if 语句 ，但是可以是用 条件表达式. 函数有两种参数类型: required 和 optional。 required 类型参数在参数最前面， 随后是 optional 类型参数。 命名的可选参数也可以标记为 “@ required” 。 可选参数可选参数可以是命名参数或者位置参数，但一个参数只能选择其中一种方式修饰。 命名可选参数调用函数时，可以使用指定命名参数 paramName: value。 例如： enableFlags(bold: true, hidden: false); 定义函数时，使用 {param1, param2, …} 来指定命名参数： 12/// Sets the [bold] and [hidden] flags ...void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125; Flutter 创建实例的表达式可能很复杂， 因此窗口小部件构造函数仅使用命名参数。 这样创建实例的表达式更易于阅读。 使用 @required 注释表示参数是 required 性质的命名参数， 该方式可以在任何 Dart 代码中使用（不仅仅是Flutter）。 const Scrollbar({Key key, @required Widget child}) 此时 Scrollbar 是一个构造函数， 当 child 参数缺少时，分析器会提示错误。 位置可选参数将参数放到 [] 中来标记参数是可选的： 1234567String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125; 下面是不使用可选参数调用上面方法 的示例： assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) == &#39;Bob says Howdy&#39;); 下面是使用可选参数调用上面方法的示例： 12assert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal'); 默认参数值在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。 下面是设置可选参数默认值示例： 12345/// 设置 [bold] 和 [hidden] 标志 ...void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;// bold 值为 true; hidden 值为 false.enableFlags(bold: true); 不推荐： 旧版本代码中可能使用的是冒号 (:) 而不是 = 来设置参数默认值。 原因是起初命名参数只支持 : 。 这种支持可能会被弃用。 建议 使用 = 指定默认值。 下面示例演示了如何为位置参数设置默认值： 1234567891011121314String say(String from, String msg, [String device = 'carrier pigeon', String mood]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; if (mood != null) &#123; result = '$result (in a $mood mood)'; &#125; return result;&#125;assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon'); list 或 map 可以作为默认值传递。 下面的示例定义了一个方法 doStuff()， 并分别指定参数 list 和 gifts 的默认值。 12345678910void doStuff( &#123;List&lt;int&gt; list = const [1, 2, 3], Map&lt;String, String&gt; gifts = const &#123; 'first': 'paper', 'second': 'cotton', 'third': 'leather' &#125;&#125;) &#123; print('list: $list'); print('gifts: $gifts');&#125; main() 函数任何应用都必须有一个顶级 main() 函数，作为应用服务的入口。 main() 函数返回值为空，参数为一个可选的 List 。 下面是 web 应用的 main() 函数： 12345void main() &#123; querySelector('#sample_text_id') ..text = 'Click me!' ..onClick.listen(reverseText);&#125; 提示： 以上代码中的 .. 语法为 级联调用 （cascade）。 使用级联调用， 可以简化在一个对象上执行的多个操作。 下面是一个命令行应用的 main() 方法，并且使用了输入参数： 12345678// 这样运行应用： dart args.dart 1 testvoid main(List&lt;String&gt; arguments) &#123; print(arguments); assert(arguments.length == 2); assert(int.parse(arguments[0]) == 1); assert(arguments[1] == 'test');&#125; 使用 args library 可以定义和解析命令行参数。 函数是一等对象一个函数可以作为另一个函数的参数。 例如： 12345678void printElement(int element) &#123; print(element);&#125;var list = [1, 2, 3];// 将 printElement 函数作为参数传递。list.forEach(printElement); 同样可以将一个函数赋值给一个变量，例如： 12var loudify = (msg) =&gt; '!!! $&#123;msg.toUpperCase()&#125; !!!';assert(loudify('hello') == '!!! HELLO !!!'); 示例中使用了匿名函数。 下一章节会有更多介绍。 匿名函数多数函数是有名字的， 比如 main() 和 printElement()。 也可以创建没有名字的函数，这种函数被称为 匿名函数， 有时候也被称为 lambda 或者 closure 。 匿名函数可以赋值到一个变量中， 举个例子，在一个集合中可以添加或者删除一个匿名函数。 匿名函数和命名函数看起来类似— 在括号之间可以定义一些参数或可选参数，参数使用逗号分割。 后面大括号中的代码为函数体： 123([[Type] param1[, …]]) &#123; codeBlock;&#125;; 下面例子中定义了一个包含一个无类型参数 item 的匿名函数。 list 中的每个元素都会调用这个函数，打印元素位置和值的字符串。 1234var list = ['apples', 'bananas', 'oranges'];list.forEach((item) &#123; print('$&#123;list.indexOf(item)&#125;: $item');&#125;); 12list.forEach( (item) =&gt; print('$&#123;list.indexOf(item)&#125;: $item')); 词法作用域Dart 是一门词法作用域的编程语言，就意味着变量的作用域是固定的， 简单说变量的作用域在编写代码的时候就已经确定了。 花括号内的是变量可见的作用域。 下面示例关于多个嵌套函数的变量作用域： 123456789101112131415161718bool topLevel = true;void main() &#123; var insideMain = true; void myFunction() &#123; var insideFunction = true; void nestedFunction() &#123; var insideNestedFunction = true; assert(topLevel); assert(insideMain); assert(insideFunction); assert(insideNestedFunction); &#125; &#125;&#125; 注意 nestedFunction() 可以访问所有的变量， 一直到顶级作用域变量。 词法闭包闭包 即一个函数对象，即使函数对象的调用在它原始作用域之外， 依然能够访问在它词法作用域内的变量。 函数可以封闭定义到它作用域内的变量。 接下来的示例中， makeAdder() 捕获了变量 addBy。 无论在什么时候执行返回函数，函数都会使用捕获的 addBy 变量。 123456789101112131415/// 返回一个函数，返回的函数参数与 [addBy] 相加。Function makeAdder(num addBy) &#123; return (num i) =&gt; addBy + i;&#125;void main() &#123; // 创建一个加 2 的函数。 var add2 = makeAdder(2); // 创建一个加 4 的函数。 var add4 = makeAdder(4); assert(add2(3) == 5); assert(add4(3) == 7);&#125; 测试函数是否相等下面是顶级函数，静态方法和示例方法相等性的测试示例： 1234567891011121314151617181920212223242526272829303132void foo() &#123;&#125; // 顶级函数class A &#123; static void bar() &#123;&#125; // 静态方法 void baz() &#123;&#125; // 示例方法&#125;void main() &#123; var x; // 比较顶级函数。 x = foo; assert(foo == x); // 比较静态方法。 x = A.bar; assert(A.bar == x); // 比较实例方法。 var v = A(); // A的1号实例 var w = A(); // A的2号实例 var y = w; x = w.baz; // 两个闭包引用的同一实例（2号）, // 所以它们相等。 assert(y.baz == x); // 两个闭包引用的非同一个实例， // 所以它们不相等。 assert(v.baz != w.baz);&#125; 返回值所有函数都会返回一个值。 如果没有明确指定返回值， 函数体会被隐式的添加 return null; 语句。 123foo() &#123;&#125;assert(foo() == null); 控制流程语句你可以通过下面任意一种方式来控制 Dart 程序流程： 1234567891011if and elsefor loopswhile and do-while loopsbreak and continueswitch and caseassert 使用 try-catch 和 throw 也可以改变程序流程， 详见 Exceptions。 if 和 elseDart 支持 if - else 语句，其中 else 是可选的， 比如下面的例子， 另参考 conditional expressions. 1234567if (isRaining()) &#123; you.bringRainCoat();&#125; else if (isSnowing()) &#123; you.wearJacket();&#125; else &#123; car.putTopDown();&#125; 和 JavaScript 不同， Dart 的判断条件必须是布尔值，不能是其他类型。 for 循环进行迭代操作，可以使用标准 for 语句。 例如： 1234var message = StringBuffer('Dart is fun');for (var i = 0; i &lt; 5; i++) &#123; message.write('!');&#125; 闭包在 Dart 的 for 循环中会捕获循环的 index 索引值， 来避免 JavaScript 中常见的陷阱。 请思考示例代码： 12345var callbacks = [];for (var i = 0; i &lt; 2; i++) &#123; callbacks.add(() =&gt; print(i));&#125;callbacks.forEach((c) =&gt; c()); 和期望一样，输出的是 0 和 1。 但是示例中的代码在 JavaScript 中会连续输出两个 2 。 如果要迭代一个实现了 Iterable 接口的对象， 可以使用 forEach() 方法， 如果不需要使用当前计数值， 使用 forEach() 是非常棒的选择； candidates.forEach((candidate) =&gt; candidate.interview()); 实现了 Iterable 的类（比如， List 和 Set）同样也支持使用 for-in 进行迭代操作 iteration ： 123456789101112131415var collection = [0, 1, 2];for (var x in collection) &#123; print(x); // 0 1 2&#125;while 和 do-whilewhile 循环在执行前判断执行条件：while (!isDone()) &#123; doSomething();&#125;do-while 循环在执行后判断执行条件：do &#123; printLine();&#125; while (!atEndOfPage()); break 和 continue使用 break 停止程序循环： 1234while (true) &#123; if (shutDownRequested()) break; processIncomingRequests();&#125; 使用 continue 跳转到下一次迭代： 1234567for (int i = 0; i &lt; candidates.length; i++) &#123; var candidate = candidates[i]; if (candidate.yearsExperience &lt; 5) &#123; continue; &#125; candidate.interview();&#125; 如果对象实现了 Iterable 接口 （例如，list 或者 set）。 那么上面示例完全可以用另一种方式来实现： 123candidates .where((c) =&gt; c.yearsExperience &gt;= 5) .forEach((c) =&gt; c.interview()); switch 和 case在 Dart 中 switch 语句使用 == 比较整数，字符串，或者编译时常量。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 == 重写。 枚举类型 可以用于 switch 语句。 提示： 在 Dart 中 Switch 语句仅适用于有限的情况下， 例如在 interpreter 或 scanner 中。 在 case 语句中，每个非空的 case 语句结尾需要跟一个 break 语句。 除 break 以外，还有可以使用 continue, throw，者 return。 当没有 case 语句匹配时，执行 default 代码： 1234567891011121314151617181920var command = 'OPEN';switch (command) &#123; case 'CLOSED': executeClosed(); break; case 'PENDING': executePending(); break; case 'APPROVED': executeApproved(); break; case 'DENIED': executeDenied(); break; case 'OPEN': executeOpen(); break; default: executeUnknown();&#125; 下面的 case 程序示例中缺省了 break 语句，导致错误： 12345678910var command = 'OPEN';switch (command) &#123; case 'OPEN': executeOpen(); // ERROR: 丢失 break case 'CLOSED': executeClosed(); break;&#125; 但是， Dart 支持空 case 语句， 允许程序以 fall-through 的形式执行。 12345678var command = 'CLOSED';switch (command) &#123; case 'CLOSED': // Empty case falls through. case 'NOW_CLOSED': // Runs for both CLOSED and NOW_CLOSED. executeNowClosed(); break;&#125; 在非空 case 中实现 fall-through 形式， 可以使用 continue 语句结合 lable 的方式实现: 12345678910111213var command = 'CLOSED';switch (command) &#123; case 'CLOSED': executeClosed(); continue nowClosed; // Continues executing at the nowClosed label. nowClosed: case 'NOW_CLOSED': // Runs for both CLOSED and NOW_CLOSED. executeNowClosed(); break;&#125; case 语句可以拥有局部变量， 这些局部变量只能在这个语句的作用域中可见。 assert如果 assert 语句中的布尔条件为 false ， 那么正常的程序执行流程会被中断。 在本章中包含部分 assert 的使用， 下面是一些示例： 12345678// 确认变量值不为空。assert(text != null);// 确认变量值小于100。assert(number &lt; 100);// 确认 URL 是否是 https 类型。assert(urlString.startsWith('https')); 提示： assert 语句只在开发环境中有效， 在生产环境是无效的； Flutter 中的 assert 只在 debug 模式 中有效。 开发用的工具，例如 dartdevc 默认是开启 assert 功能。 其他的一些工具， 例如 dart 和 dart2js, 支持通过命令行开启 assert ： –enable-asserts。 assert 的第二个参数可以为其添加一个字符串消息。 12assert(urlString.startsWith('https'), 'URL ($urlString) should start with "https".'); assert 的第一个参数可以是解析为布尔值的任何表达式。 如果表达式结果为 true ， 则断言成功，并继续执行。 如果表达式结果为 false ， 则断言失败，并抛出异常 (AssertionError) 。 异常Dart 代码可以抛出和捕获异常。 异常表示一些未知的错误情况。 如果异常没有被捕获， 则异常会抛出， 导致抛出异常的代码终止执行。 和 Java 有所不同， Dart 中的所有异常是非检查异常。 方法不会声明它们抛出的异常， 也不要求捕获任何异常。 Dart 提供了 Exception 和 Error 类型， 以及一些子类型。 当然也可以定义自己的异常类型。 但是，此外 Dart 程序可以抛出任何非 null 对象， 不仅限 Exception 和 Error 对象。 throw下面是关于抛出或者 引发 异常的示例： throw FormatException(&#39;Expected at least 1 section&#39;); 也可以抛出任意的对象： throw &#39;Out of llamas!&#39;; 提示： 高质量的生产环境代码通常会实现 Error 或 Exception 类型的异常抛出。 因为抛出异常是一个表达式， 所以可以在 =&gt; 语句中使用，也可以在其他使用表达式的地方抛出异常： void distanceTo(Point other) =&gt; throw UnimplementedError(); catch捕获异常可以避免异常继续传递（除非重新抛出（ rethrow ）异常）。 可以通过捕获异常的机会来处理该异常： 12345try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; buyMoreLlamas();&#125; 通过指定多个 catch 语句，可以处理可能抛出多种类型异常的代码。 与抛出异常类型匹配的第一个 catch 语句处理异常。 如果 catch 语句未指定类型， 则该语句可以处理任何类型的抛出对象： 123456789101112try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; // 一个特殊的异常 buyMoreLlamas();&#125; on Exception catch (e) &#123; // 其他任何异常 print('Unknown exception: $e');&#125; catch (e) &#123; // 没有指定的类型，处理所有异常 print('Something really unknown: $e');&#125; 如上述代码所示，捕获语句中可以同时使用 on 和 catch ，也可以单独分开使用。 使用 on 来指定异常类型， 使用 catch 来 捕获异常对象。 catch() 函数可以指定1到2个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息 ( 一个 StackTrace 对象 )。 12345678try &#123; // ···&#125; on Exception catch (e) &#123; print('Exception details:\n $e');&#125; catch (e, s) &#123; print('Exception details:\n $e'); print('Stack trace:\n $s');&#125; 如果仅需要部分处理异常， 那么可以使用关键字 rethrow 将异常重新抛出。 1234567891011121314151617void misbehave() &#123; try &#123; dynamic foo = true; print(foo++); // Runtime error &#125; catch (e) &#123; print('misbehave() partially handled $&#123;e.runtimeType&#125;.'); rethrow; // Allow callers to see the exception. &#125;&#125;void main() &#123; try &#123; misbehave(); &#125; catch (e) &#123; print('main() finished handling $&#123;e.runtimeType&#125;.'); &#125;&#125; finally不管是否抛出异常， finally 中的代码都会被执行。 如果 catch 没有匹配到异常， 异常会在 finally 执行完成后，再次被抛出： 123456try &#123; breedMoreLlamas();&#125; finally &#123; // Always clean up, even if an exception is thrown. cleanLlamaStalls();&#125; 任何匹配的 catch 执行完成后，再执行 finally ： 1234567try &#123; breedMoreLlamas();&#125; catch (e) &#123; print('Error: $e'); // Handle the exception first.&#125; finally &#123; cleanLlamaStalls(); // Then clean up.&#125; 类Dart 是一种基于类和 mixin 继承机制的面向对象的语言。 每个对象都是一个类的实例，所有的类都继承于 Object. 。 基于 Mixin 继承 意味着每个类（除 Object 外） 都只有一个超类， 一个类中的代码可以在其他多个继承类中重复使用。 使用类的成员变量对象的由函数和数据（即方法和实例变量）组成。 方法的调用要通过对象来完成： 调用的方法可以访问其对象的其他函数和数据。 使用 (.) 来引用实例对象的变量和方法： 1234567891011var p = Point(2, 2);// 为实例的变量 y 设置值。p.y = 3;// 获取变量 y 的值。assert(p.y == 3);// 调用 p 的 distanceTo() 方法。num distance = p.distanceTo(Point(4, 4)); 使用 ?. 来代替 . ， 可以避免因为左边对象可能为 null ， 导致的异常： 12// 如果 p 为 non-null，设置它变量 y 的值为 4。p?.y = 4; 使用构造函数通过 构造函数 创建对象。 构造函数的名字可以是 ClassName 或者 ClassName.identifier。例如， 以下代码使用 Point 和 Point.fromJson() 构造函数创建 Point 对象： 12var p1 = Point(2, 2);var p2 = Point.fromJson(&#123;'x': 1, 'y': 2&#125;); 以下代码具有相同的效果， 但是构造函数前面的的 new 关键字是可选的： 12var p1 = new Point(2, 2);var p2 = new Point.fromJson(&#123;'x': 1, 'y': 2&#125;); 版本提示： 在 Dart 2 中 new 关键字变成了可选的。 一些类提供了常量构造函数。 使用常量构造函数，在构造函数名之前加 const 关键字，来创建编译时常量时： var p = const ImmutablePoint(2, 2); 构造两个相同的编译时常量会产生一个唯一的， 标准的实例： 1234var a = const ImmutablePoint(1, 1);var b = const ImmutablePoint(1, 1);assert(identical(a, b)); // 它们是同一个实例。 在 常量上下文 中， 构造函数或者字面量前的 const 可以省略。 例如，下面代码创建了一个 const 类型的 map 对象： 12345// 这里有很多的 const 关键字。const pointAndLine = const &#123; 'point': const [const ImmutablePoint(0, 0)], 'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],&#125;; 保留第一个 const 关键字，其余的全部省略： 12345// 仅有一个 const ，由该 const 建立常量上下文。const pointAndLine = &#123; 'point': [ImmutablePoint(0, 0)], 'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],&#125;; 如果常量构造函数在常量上下文之外， 且省略了 const 关键字， 此时创建的对象是非常量对象： 1234var a = const ImmutablePoint(1, 1); // 创建一个常量对象var b = ImmutablePoint(1, 1); // 创建一个非常量对象assert(!identical(a, b)); // 两者不是同一个实例! 版本提示： 在 Dart 2 中，一个常量上下文中的 const 关键字可以被省略。 获取对象的类型使用对象的 runtimeType 属性， 可以在运行时获取对象的类型， runtimeType 属性回返回一个 Type 对象。 1print('The type of a is $&#123;a.runtimeType&#125;'); 到目前为止，我们已经解了如何_使用类。 本节的其余部分将介绍如何实现_一个类。 实例变量下面是声明实例变量的示例： 12345class Point &#123; num x; // 声明示例变量 x，初始值为 null 。 num y; // 声明示例变量 y，初始值为 null 。 num z = 0; // 声明示例变量 z，初始值为 0 。&#125; 未初始化实例变量的默认人值为 “null” 。 所有实例变量都生成隐式 getter 方法。 非 final 的实例变量同样会生成隐式 setter 方法。 1234567891011class Point &#123; num x; num y;&#125;void main() &#123; var point = Point(); point.x = 4; // Use the setter method for x. assert(point.x == 4); // Use the getter method for x. assert(point.y == null); // Values default to null.&#125; 如果在声明时进行了示例变量的初始化， 那么初始化值会在示例创建时赋值给变量， 该赋值过程在构造函数及其初始化列表执行之前。 构造函数通过创建一个与其类同名的函数来声明构造函数 （另外，还可以附加一个额外的可选标识符，如 命名构造函数 中所述）。 下面通过最常见的构造函数形式， 即生成构造函数， 创建一个类的实例： 123456789class Point &#123; num x, y; Point(num x, num y) &#123; // 还有更好的方式来实现下面代码，敬请关注。 this.x = x; this.y = y; &#125;&#125; 使用 this 关键字引用当前实例。 提示： 近当存在命名冲突时，使用 this 关键字。 否则，按照 Dart 风格应该省略 this 。 通常模式下，会将构造函数传入的参数的值赋值给对应的实例变量， Dart 自身的语法糖精简了这些代码： 1234567class Point &#123; num x, y; // 在构造函数体执行前， // 语法糖已经设置了变量 x 和 y。 Point(this.x, this.y);&#125; 默认构造函数在没有声明构造函数的情况下， Dart 会提供一个默认的构造函数。 默认构造函数没有参数并会调用父类的无参构造函数。 构造函数不被继承子类不会继承父类的构造函数。 子类不声明构造函数，那么它就只有默认构造函数 (匿名，没有参数) 。 命名构造函数使用命名构造函数可为一个类实现多个构造函数， 也可以使用命名构造函数来更清晰的表明函数意图： 1234567891011class Point &#123; num x, y; Point(this.x, this.y); // 命名构造函数 Point.origin() &#123; x = 0; y = 0; &#125;&#125; 切记，构造函数不能够被继承， 这意味着父类的命名构造函数不会被子类继承。 如果希望使用父类中定义的命名构造函数创建子类， 就必须在子类中实现该构造函数。 调用父类非默认构造函数默认情况下，子类的构造函数会自动调用父类的默认构造函数（匿名，无参数）。 父类的构造函数在子类构造函数体开始执行的位置被调用。 如果提供了一个 initializer list （初始化参数列表）， 则初始化参数列表在父类构造函数执行之前执行。 总之，执行顺序如下： 123initializer list （初始化参数列表）superclass’s no-arg constructor （父类的无名构造函数）main class’s no-arg constructor （主类的无名构造函数） 如果父类中没有匿名无参的构造函数， 则需要手工调用父类的其他构造函数。 在当前构造函数冒号 (:) 之后，函数体之前，声明调用父类构造函数。 由于父类的构造函数参数在构造函数执行之前执行， 所以参数可以是一个表达式或者一个方法调用： 1234class Employee extends Person &#123; Employee() : super.fromJson(getDefaultData()); // ···&#125; 警告： 调用父类构造函数的参数无法访问 this 。 例如，参数可以为静态函数但是不能是实例函数。 初始化列表除了调用超类构造函数之外， 还可以在构造函数体执行之前初始化实例变量。 各参数的初始化用逗号分隔。 1234567// 在构造函数体执行之前，// 通过初始列表设置实例变量。Point.fromJson(Map&lt;String, num&gt; json) : x = json['x'], y = json['y'] &#123; print('In Point.fromJson(): ($x, $y)');&#125; 警告： 初始化程序的右侧无法访问 this 。 在开发期间， 可以使用 assert 来验证输入的初始化列表。 123Point.withAssert(this.x, this.y) : assert(x &gt;= 0) &#123; print('In Point.withAssert(): ($x, $y)');&#125; 使用初始化列表可以很方便的设置 final 字段。 下面示例演示了，如何使用初始化列表初始化设置三个 final 字段。 点击运行按钮 执行示例代码。 重定向构造函数有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。 重定向构造函数的函数体为空， 构造函数的调用在冒号 (:) 之后。 123456789class Point &#123; num x, y; // 类的主构造函数。 Point(this.x, this.y); // 指向主构造函数 Point.alongXAxis(num x) : this(x, 0);&#125; 常量构造函数如果该类生成的对象是固定不变的， 那么就可以把这些对象定义为编译时常量。 为此，需要定义一个 const 构造函数， 并且声明所有实例变量为 final。 12345678class ImmutablePoint &#123; static final ImmutablePoint origin = const ImmutablePoint(0, 0); final num x, y; const ImmutablePoint(this.x, this.y);&#125; 常量构造函数创建的实例并不总是常量。 更多内容，查看 使用构造函数 章节。 工厂构造函数当执行构造函数并不总是创建这个类的一个新实例时，则使用 factory 关键字。 例如，一个工厂构造函数可能会返回一个 cache 中的实例， 或者可能返回一个子类的实例。 以下示例演示了从缓存中返回对象的工厂构造函数： 12345678910111213141516171819202122232425class Logger &#123; final String name; bool mute = false; // 从命名的 _ 可以知， // _cache 是私有属性。 static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;&#123;&#125;; factory Logger(String name) &#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125; else &#123; final logger = Logger._internal(name); _cache[name] = logger; return logger; &#125; &#125; Logger._internal(this.name); void log(String msg) &#123; if (!mute) print(msg); &#125;&#125; 提示： 工厂构造函数无法访问 this。 工厂构造函的调用方式与其他构造函数一样： 12var logger = Logger('UI');logger.log('Button clicked'); 方法方法是为对象提供行为的函数。 实例方法对象的实例方法可以访问 this 和实例变量。 以下示例中的 distanceTo() 方法就是实例方法： 12345678910111213import 'dart:math';class Point &#123; num x, y; Point(this.x, this.y); num distanceTo(Point other) &#123; var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); &#125;&#125; Getter 和 SetterGetter 和 Setter 是用于对象属性读和写的特殊方法。 回想之前的例子，每个实例变量都有一个隐式 Getter ，通常情况下还会有一个 Setter 。 使用 get 和 set 关键字实现 Getter 和 Setter ，能够为实例创建额外的属性。 123456789101112131415161718class Rectangle &#123; num left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // 定义两个计算属性： right 和 bottom。 num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;&#125;void main() &#123; var rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);&#125; 最开始实现 Getter 和 Setter 也许是直接返回成员变量； 随着需求变化， Getter 和 Setter 可能需要进行计算处理而使用方法来实现； 但是，调用对象的代码不需要做任何的修改。 提示： 类似 (++) 之类操作符不管是否定义了 getter 方法，都能够正确的执行。 为了避免一些问题，操作符只调用一次 getter 方法， 然后把值保存到一个临时的变量中。 抽象方法实例方法， getter， 和 setter 方法可以是抽象的， 只定义接口不进行实现，而是留给其他类去实现。 抽象方法只存在于 抽象类 中。 定义一个抽象函数，使用分号 (;) 来代替函数体： 1234567891011abstract class Doer &#123; // 定义实例变量和方法 ... void doSomething(); // 定义一个抽象方法。&#125;class EffectiveDoer extends Doer &#123; void doSomething() &#123; // 提供方法实现，所以这里的方法就不是抽象方法了... &#125;&#125; 调用抽象方法会导致运行时错误。 抽象类使用 abstract 修饰符来定义 抽象类 — 抽象类不能实例化。 抽象类通常用来定义接口，以及部分实现。 如果希望抽象类能够被实例化，那么可以通过定义一个 工厂构造函数 来实现。 抽象类通常具有 抽象方法。 下面是一个声明具有抽象方法的抽象类示例： 1234567// 这个类被定义为抽象类，// 所以不能被实例化。abstract class AbstractContainer &#123; // 定义构造行数，字段，方法... void updateChildren(); // 抽象方法。&#125; 隐式接口每个类都隐式的定义了一个接口，接口包含了该类所有的实例成员及其实现的接口。 如果要创建一个 A 类，A 要支持 B 类的 API ，但是不需要继承 B 的实现， 那么可以通过 A 实现 B 的接口。 一个类可以通过 implements 关键字来实现一个或者多个接口， 并实现每个接口要求的 API。 例如： 12345678910111213141516171819202122232425// person 类。 隐式接口里面包含了 greet() 方法声明。class Person &#123; // 包含在接口里，但只在当前库中可见。 final _name; // 不包含在接口里，因为这是一个构造函数。 Person(this._name); // 包含在接口里。 String greet(String who) =&gt; 'Hello, $who. I am $_name.';&#125;// person 接口的实现。class Impostor implements Person &#123; get _name =&gt; ''; String greet(String who) =&gt; 'Hi $who. Do you know who I am?';&#125;String greetBob(Person person) =&gt; person.greet('Bob');void main() &#123; print(greetBob(Person('Kathy'))); print(greetBob(Impostor()));&#125; 下面示例演示一个类如何实现多个接口： Here’s an example of specifying that a class implements multiple interfaces: 1class Point implements Comparable, Location &#123;...&#125; 扩展类（继承）使用 extends 关键字来创建子类， 使用 super 关键字来引用父类： 1234567891011121314151617class Television &#123; void turnOn() &#123; _illuminateDisplay(); _activateIrSensor(); &#125; // ···&#125;class SmartTelevision extends Television &#123; void turnOn() &#123; super.turnOn(); _bootNetworkInterface(); _initializeMemory(); _upgradeApps(); &#125; // ···&#125; 重写类成员子类可以重写实例方法，getter 和 setter。 可以使用 @override 注解指出想要重写的成员： 12345class SmartTelevision extends Television &#123; @override void turnOn() &#123;...&#125; // ···&#125; To narrow the type of a method parameter or instance variable in code that is type safe, you can use the covariant keyword. 重写运算符下标的运算符可以被重写。 例如，想要实现两个向量对象相加，可以重写 + 方法。 12345&lt; + | []&gt; / ^ []=&lt;= ~/ &amp; ~&gt;= * &lt;&lt; ==– % &gt;&gt; 提示： 你可能会被提示 != 运算符为非可重载运算符。 因为 e1 != e2 表达式仅仅是 !(e1 == e2) 的语法糖。 下面示例演示一个类重写 + 和 - 操作符： 12345678910111213141516171819class Vector &#123; final int x, y; Vector(this.x, this.y); Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y); Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y); // 运算符 == 和 hashCode 部分没有列出。 有关详情，请参考下面的注释。 // ···&#125;void main() &#123; final v = Vector(2, 3); final w = Vector(2, 2); assert(v + w == Vector(4, 5)); assert(v - w == Vector(0, 1));&#125; 如果要重写 == 操作符，需要重写对象的 hashCode getter 方法。 重写 == 和 hashCode 的实例，参考 Implementing map keys. 有关重写的更多介绍，请参考 扩展类（继承）. noSuchMethod()当代码尝试使用不存在的方法或实例变量时， 通过重写 noSuchMethod() 方法，来实现检测和应对处理： 123456789class A &#123; // 如果不重写 noSuchMethod，访问 // 不存在的实例变量时会导致 NoSuchMethodError 错误。 @override void noSuchMethod(Invocation invocation) &#123; print('You tried to use a non-existent member: ' + '$&#123;invocation.memberName&#125;'); &#125;&#125; 除非符合下面的任意一项条件， 否则没有实现的方法不能够被调用： receiver 具有 dynamic 的静态类型 。 receiver 具有静态类型，用于定义为实现的方法 (可以是抽象的), 并且 receiver 的动态类型具有 noSuchMethod() 的实现， 该实现与 Object 类中的实现不同。 枚举类型枚举类型也称为 enumerations 或 enums ， 是一种特殊的类，用于表示数量固定的常量值。 使用枚举使用 enum 关键字定义一个枚举类型： 1enum Color &#123; red, green, blue &#125; 枚举中的每个值都有一个 index getter 方法， 该方法返回值所在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的索引是 0 ， 第二个枚举值的索引是 1。 123assert(Color.red.index == 0);assert(Color.green.index == 1);assert(Color.blue.index == 2); 使用枚举的 values 常量， 获取所有枚举值列表（ list ）。 12List&lt;Color&gt; colors = Color.values;assert(colors[2] == Color.blue); 可以在 switch 语句 中使用枚举， 如果不处理所有枚举值，会收到警告： 123456789101112var aColor = Color.blue;switch (aColor) &#123; case Color.red: print('Red as roses!'); break; case Color.green: print('Green as grass!'); break; default: // 没有这个，会看到一个警告。 print(aColor); // 'Color.blue'&#125; 枚举类型具有以下限制： 枚举不能被子类化，混合或实现。 枚举不能被显式实例化。 为类添加功能： MixinMixin 是复用类代码的一种途径， 复用的类可以在不同层级，之间可以不存在继承关系。 通过 with 后面跟一个或多个混入的名称，来使用 Mixin ， 下面的示例演示了两个使用 Mixin 的类： 1234567891011class Musician extends Performer with Musical &#123; // ···&#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125;&#125; 通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 例如： 123456789101112131415mixin Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 指定只有某些类型可以使用的 Mixin - 比如， Mixin 可以调用 Mixin 自身没有定义的方法 - 使用 on 来指定可以使用 Mixin 的父类类型： 123mixin MusicalPerformer on Musician &#123; // ···&#125; 版本提示： mixin 关键字在 Dart 2.1 中被引用支持。 早期版本中的代码通常使用 abstract class 代替。 更多有关 Mixin 在 2.1 中的变更信息，请参见 Dart SDK changelog 和 2.1 mixin specification 。 提示： 对 Mixin 的一些限制正在被移除。 类变量和方法使用 static 关键字实现类范围的变量和方法。 静态变量静态变量（类变量）对于类级别的状态是非常有用的： 12345678class Queue &#123; static const initialCapacity = 16; // ···&#125;void main() &#123; assert(Queue.initialCapacity == 16);&#125; 静态变量只到它们被使用的时候才会初始化。 提示： 代码准守风格推荐指南 中的命名规则， 使用 lowerCamelCase 来命名常量。 静态方法静态方法（类方法）不能在实例上使用，因此它们不能访问 this 。 例如： 1234567891011121314151617181920import 'dart:math';class Point &#123; num x, y; Point(this.x, this.y); static num distanceBetween(Point a, Point b) &#123; var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); &#125;&#125;void main() &#123; var a = Point(2, 2); var b = Point(4, 4); var distance = Point.distanceBetween(a, b); assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9); print(distance);&#125; 提示： 对于常见或广泛使用的工具和函数， 应该考虑使用顶级函数而不是静态方法。 静态函数可以当做编译时常量使用。 例如，可以将静态方法作为参数传递给常量构造函数。 泛型在 API 文档中你会发现基础数组类型 List 的实际类型是 List 。 &lt;…&gt; 符号将 List 标记为 泛型 (或 参数化) 类型。 这种类型具有形式化的参数。 通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。 为什么使用泛型在类型安全上通常需要泛型支持， 它的好处不仅仅是保证代码的正常运行： 正确指定泛型类型可以提高代码质量。使用泛型可以减少重复的代码。如果想让 List 仅仅支持字符串类型， 可以将其声明为 List （读作“字符串类型的 list ”）。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。 例如： 123var names = List&lt;String&gt;();names.addAll(['Seth', 'Kathy', 'Lars']);names.add(42); // 错误 另外一个使用泛型的原因是减少重复的代码。 泛型可以在多种类型之间定义同一个实现， 同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。 例如，假设你创建了一个用于缓存对象的接口： 1234abstract class ObjectCache &#123; Object getByKey(String key); void setByKey(String key, Object value);&#125; 后来发现需要一个相同功能的字符串类型接口，因此又创建了另一个接口： 1234abstract class StringCache &#123; String getByKey(String key); void setByKey(String key, String value);&#125; 后来，又发现需要一个相同功能的数字类型接口 … 这里你应该明白了。 泛型可以省去创建所有这些接口的麻烦。 通过创建一个带有泛型参数的接口，来代替上述接口： 1234abstract class Cache&lt;T&gt; &#123; T getByKey(String key); void setByKey(String key, T value);&#125; 在上面的代码中，T 是一个备用类型。 这是一个类型占位符，在开发者调用该接口的时候会指定具体类型。 使用集合字面量List , Set 和 Map 字面量也是可以参数化的。 参数化字面量和之前的字面量定义类似， 对于 List 或 Set 只需要在声明语句前加 前缀， 对于 Map 只需要在声明语句前加 &lt;keyType, valueType&gt; 前缀， 下面是参数化字面量的示例： 1234567var names = &lt;String&gt;['Seth', 'Kathy', 'Lars'];var uniqueNames = &lt;String&gt;&#123;'Seth', 'Kathy', 'Lars'&#125;;var pages = &lt;String, String&gt;&#123; 'index.html': 'Homepage', 'robots.txt': 'Hints for web robots', 'humans.txt': 'We are people, not machines'&#125;; 使用泛型类型的构造函数在调用构造函数的时，在类名字后面使用尖括号（&lt;…&gt;）来指定泛型类型。 例如： 1var nameSet = Set&lt;String&gt;.from(names); 下面代码创建了一个 key 为 integer， value 为 View 的 map 对象： var views = Map&lt;int, View&gt;(); 运行时中的泛型集合Dart 中泛型类型是 固化的，也就是说它们在运行时是携带着类型信息的。 例如， 在运行时检测集合的类型： 123var names = List&lt;String&gt;();names.addAll(['Seth', 'Kathy', 'Lars']);print(names is List&lt;String&gt;); // true 提示： 相反，Java中的泛型会被 擦除 ，也就是说在运行时泛型类型参数的信息是不存在的。 在Java中，可以测试对象是否为 List 类型， 但无法测试它是否为 List 。 限制泛型类型使用泛型类型的时候， 可以使用 extends 实现参数类型的限制。 123456class Foo&lt;T extends SomeBaseClass&gt; &#123; // Implementation goes here... String toString() =&gt; "Instance of 'Foo&lt;$T&gt;'";&#125;class Extender extends SomeBaseClass &#123;...&#125; 可以使用 SomeBaseClass 或其任意子类作为通用参数： 12var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();var extenderFoo = Foo&lt;Extender&gt;(); 也可以不指定泛型参数： 12var foo = Foo();print(foo); // Instance of 'Foo&lt;SomeBaseClass&gt;' 指定任何非 SomeBaseClass 类型会导致错误： 1var foo = Foo&lt;Object&gt;(); 使用泛型函数最初，Dart 的泛型只能用于类。 新语法泛型方法，允许在方法和函数上使用类型参数： 123456T first&lt;T&gt;(List&lt;T&gt; ts) &#123; // Do some initial work or error checking, then... T tmp = ts[0]; // Do some additional checking or processing... return tmp;&#125; 这里的 first () 泛型可以在如下地方使用参数 T ： 函数的返回值类型 (T). 参数的类型 (List). 局部变量的类型 (T tmp). 库和可见性import 和 library 指令可以用来创建一个模块化的，可共享的代码库。 库不仅提供了 API ，而且对代码起到了封装的作用： 以下划线 (_) 开头的标识符仅在库内可见。 每个 Dart 应用程序都是一个库 ，虽然没有使用 library 指令。 库可以通过包来分发。有关 pub（集成在SDK中的包管理器）的信息，请参考 Pub Package 和 Asset Manager。 使用库通过 import 指定一个库命名空间中的内如如何在另一个库中使用。 例如，Dart Web应用程序通常使用 dart:html 库，它们可以像这样导入： import &#39;dart:html&#39;; import 参数只需要一个指向库的 URI。 对于内置库，URI 拥有自己特殊的dart: 方案。 对于其他的库，使用系统文件路径或者 package: 方案 。 package: 方案指定由包管理器（如 pub 工具）提供的库。例如： import &#39;package:test/test.dart&#39;; 提示： URI 代表统一资源标识符。 URL（统一资源定位符）是一种常见的URI。 指定库前缀如果导入两个存在冲突标识符的库， 则可以为这两个库，或者其中一个指定前缀。 例如，如果 library1 和 library2 都有一个 Element 类， 那么可以通过下面的方式处理： 12345678import 'package:lib1/lib1.dart';import 'package:lib2/lib2.dart' as lib2;// 使用 lib1 中的 Element。Element element1 = Element();// 使用 lib2 中的 Element。lib2.Element element2 = lib2.Element(); 导入库的一部分如果你只使用库的一部分功能，则可以选择需要导入的 内容。例如： 12345// Import only foo.import 'package:lib1/lib1.dart' show foo;// Import all names EXCEPT foo.import 'package:lib2/lib2.dart' hide foo; 延迟加载库Deferred loading (也称之为 lazy loading) 可以让应用在需要的时候再加载库。 下面是一些使用延迟加载库的场景： 减少 APP 的启动时间。 执行 A/B 测试，例如 尝试各种算法的 不同实现。 加载很少使用的功能，例如可选的屏幕和对话框。 要延迟加载一个库，需要先使用 deferred as 来导入： 12345678910import 'package:greetings/hello.dart' deferred as hello;···当需要使用的时候，使用库标识符调用 loadLibrary() 函数来加载库：```dartFuture greet() async &#123; await hello.loadLibrary(); hello.printGreeting();&#125; 在前面的代码，使用 await 关键字暂停代码执行一直到库加载完成。 关于 async 和 await 的更多信息请参考 异步支持。 在一个库上你可以多次调用 loadLibrary() 函数。但是该库只是载入一次。 使用延迟加载库的时候，请注意一下问题： 延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用。在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库。Dart 隐含的把 loadLibrary() 函数导入到使用 deferred as 的命名空间 中。 loadLibrary() 方法返回一个 Future。Dart VM difference: The Dart VM allows access to members of deferred libraries even before the call to loadLibrary(). This behavior might change, so don’t depend on the current VM behavior. For details, see issue #33118. 实现库有关如何实现库包的建议，请参考 Create Library Packages 这里面包括： 如何组织库的源文件。 如何使用 export 命令。 何时使用 part 命令。 何时使用 library 命令。 异步支持Dart 库中包含许多返回 Future 或 Stream 对象的函数. 这些函数在设置完耗时任务（例如 I/O 曹组）后， 就立即返回了，不会等待耗任务完成。 使用 async 和 await 关键字实现异步编程。 可以让你像编写同步代码一样实现异步操作。 处理 Future可以通过下面两种方式，获得 Future 执行完成的结果： 使用 async 和 await. 使用 Future API，具体描述，参考 库概览. 使用 async 和 await 关键字的代码是异步的。 虽然看起来有点想同步代码。 例如，下面的代码使用 await 等待异步函数的执行结果。 await lookUpVersion(); 要使用 await ， 代码必须在 异步函数（使用 async 标记的函数）中： 1234Future checkVersion() async &#123; var version = await lookUpVersion(); // Do something with version&#125; 提示： 虽然异步函数可能会执行耗时的操作， 但它不会等待这些操作。 相反，异步函数只有在遇到第一个 await 表达式（详情见）时才会执行。 也就是说，它返回一个 Future 对象， 仅在await表达式完成后才恢复执行。 使用 try， catch， 和 finally 来处理代码中使用 await 导致的错误。 12345try &#123; version = await lookUpVersion();&#125; catch (e) &#123; // React to inability to look up the version&#125; 在一个异步函数中可以多次使用 await 。 例如，下面代码中等待了三次函数结果： 123var entrypoint = await findEntrypoint();var exitCode = await runExecutable(entrypoint, args);await flushThenExit(exitCode); 在 await 表达式 中， 表达式 的值通常是一个 Future 对象； 如果不是，这是表达式的值会被自动包装成一个 Future 对象。 Future 对象指明返回一个对象的承诺（promise）。 await 表达式 执行的结果为这个返回的对象。 await 表达式会阻塞代码的执行，直到需要的对象返回为止。 如果在使用 await 导致编译时错误， 确认 await 是否在一个异步函数中。 例如，在应用的 main() 函数中使用 await ， main() 函数的函数体必须被标记为 async ： 1234Future main() async &#123; checkVersion(); print('In main: version is $&#123;await lookUpVersion()&#125;');&#125; 声明异步函数函数体被 async 标示符标记的函数，即是一个异步函数。 将 async 关键字添加到函数使其返回Future。 例如，考虑下面的同步函数，它返回一个 String ： String lookUpVersion() =&gt; &#39;1.0.0&#39;; 例如，将来的实现将非常耗时，将其更改为异步函数，返回值是 Future 。 Future&lt;String&gt; lookUpVersion() async =&gt; &#39;1.0.0&#39;; 注意，函数体不需要使用Future API。 如有必要， Dart 会创建 Future 对象。 如果函数没有返回有效值， 需要设置其返回类型为 Future 。 处理 Stream当需要从 Stream 中获取数据值时， 可以通过一下两种方式： 使用 async 和 一个 异步循环 （await for）。 使用 Stream API, 更多详情，参考 in the library tour。 提示： 在使用 await for 前，确保代码清晰， 并且确实希望等待所有流的结果。 例如，通常不应该使用 await for 的UI事件侦听器， 因为UI框架会发送无穷无尽的事件流。 以下是异步for循环的使用形式： 123await for (varOrType identifier in expression) &#123; // Executes each time the stream emits a value.&#125; 上面 表达式 返回的值必须是 Stream 类型。 执行流程如下： 等待，直到流发出一个值。 执行 for 循环体，将变量设置为该发出的值 重复1和2，直到关闭流。 使用 break 或者 return 语句可以停止接收 stream 的数据， 这样就跳出了 for 循环， 并且从 stream 上取消注册。 如果在实现异步 for 循环时遇到编译时错误， 请检查确保 await for 处于异步函数中。 例如，要在应用程序的 main() 函数中使用异步 fo r循环， main() 函数体必须标记为 async` ： 1234567Future main() async &#123; // ... await for (var request in requestServer) &#123; handleRequest(request); &#125; // ...&#125; 生成器当您需要延迟生成( lazily produce )一系列值时， 可以考虑使用生成器函数。 Dart 内置支持两种生成器函数： Synchronous 生成器： 返回一个 Iterable 对象。 Asynchronous 生成器： 返回一个 Stream 对象。通过在函数体标记 sync*， 可以实现一个同步生成器函数。 使用 yield 语句来传递值： 1234Iterable&lt;int&gt; naturalsTo(int n) sync* &#123; int k = 0; while (k &lt; n) yield k++;&#125; 通过在函数体标记 async*， 可以实现一个异步生成器函数。 使用 yield 语句来传递值： 1234Stream&lt;int&gt; asynchronousNaturalsTo(int n) async* &#123; int k = 0; while (k &lt; n) yield k++;&#125; 如果生成器是递归的，可以使用 yield* 来提高其性能： 123456Iterable&lt;int&gt; naturalsDownFrom(int n) sync* &#123; if (n &gt; 0) &#123; yield n; yield* naturalsDownFrom(n - 1); &#125;&#125; 可调用类通过实现类的 call() 方法， 能够让类像函数一样被调用。 在下面的示例中，WannabeFunction 类定义了一个 call() 函数， 函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号。 单击运行按钮 执行代码。 Isolates大多数计算机中，甚至在移动平台上，都在使用多核CPU。 为了有效利用多核性能，开发者一般使用共享内存数据来保证多线程的正确执行。 然而， 多线程共享数据通常会导致很多潜在的问题，并导致代码运行出错。 所有 Dart 代码都在隔离区（ isolates ）内运行，而不是线程。 每个隔离区都有自己的内存堆，确保每个隔离区的状态都不会被其他隔离区访问。 Typedefs在 Dart 中，函数也是对象，就想字符和数字对象一样。 使用 typedef ，或者 function-type alias 为函数起一个别名， 别名可以用来声明字段及返回值类型。 当函数类型分配给变量时，typedef会保留类型信息。 请考虑以下代码，代码中未使用 typedef ： 123456789101112131415161718class SortedCollection &#123; Function compare; SortedCollection(int f(Object a, Object b)) &#123; compare = f; &#125;&#125;// Initial, broken implementation. // broken ？int sort(Object a, Object b) =&gt; 0;void main() &#123; SortedCollection coll = SortedCollection(sort); // 虽然知道 compare 是函数， // 但是函数是什么类型 ？ assert(coll.compare is Function);&#125; 当把 f 赋值给 compare 的时候，类型信息丢失了。 f 的类型是 (Object, Object) → int (这里 → 代表返回值类型)， 但是 compare 得到的类型是 Function 。如果我们使用显式的名字并保留类型信息， 这样开发者和工具都可以使用这些信息： 12345678910111213141516typedef Compare = int Function(Object a, Object b);class SortedCollection &#123; Compare compare; SortedCollection(this.compare);&#125;// Initial, broken implementation.int sort(Object a, Object b) =&gt; 0;void main() &#123; SortedCollection coll = SortedCollection(sort); assert(coll.compare is Function); assert(coll.compare is Compare);&#125; 提示： 目前，typedefs 只能使用在函数类型上， 我们希望将来这种情况有所改变。 由于 typedefs 只是别名， 他们还提供了一种方式来判断任意函数的类型。例如： 1234567typedef Compare&lt;T&gt; = int Function(T a, T b);int sort(int a, int b) =&gt; a - b;void main() &#123; assert(sort is Compare&lt;int&gt;); // True!&#125; 元数据使用元数据可以提供有关代码的其他信息。 元数据注释以字符 @ 开头， 后跟对编译时常量 (如 deprecated) 的引用或对常量构造函数的调用。 对于所有 Dart 代码有两种可用注解：@deprecated 和 @override。 关于 @override 的使用， 参考 扩展类（继承）。 下面是使用 @deprecated 注解的示例： 12345678910class Television &#123; /// _Deprecated: Use [turnOn] instead._ @deprecated void activate() &#123; turnOn(); &#125; /// Turns the TV's power on. void turnOn() &#123;...&#125;&#125; 可以自定义元数据注解。 下面的示例定义了一个带有两个参数的 @todo 注解： 12345678library todo;class Todo &#123; final String who; final String what; const Todo(this.who, this.what);&#125; 使用 @todo 注解的示例： 123456import 'todo.dart';@Todo('seth', 'make this do something')void doSomething() &#123; print('do something');&#125; 元数据可以在 library、 class、 typedef、 type parameter、 constructor、 factory、 function、 field、 parameter 或者 variable 声明之前使用，也可以在 import 或者 export 指令之前使用。 使用反射可以在运行时获取元数据信息。 注释Dart 支持单行注释、多行注释和文档注释。 单行注释单行注释以 // 开始。 所有在 // 和改行结尾之间的内容被编译器忽略。 1234void main() &#123; // TODO: refactor into an AbstractLlamaGreetingFactory? print('Welcome to my Llama farm!');&#125; 多行注释多行注释以 / 开始， 以 / 结尾。 所有在 / 和 / 之间的内容被编译器忽略 （不会忽略文档注释）。 多行注释可以嵌套。 12345678910void main() &#123; /* * This is a lot of work. Consider raising chickens. Llama larry = Llama(); larry.feed(); larry.exercise(); larry.clean(); */&#125; 文档注释文档注释可以是多行注释，也可以是单行注释， 文档注释以 /// 或者 /** 开始。 在连续行上使用 /// 与多行文档注释具有相同的效果。 在文档注释中，除非用中括号括起来，否则Dart 编译器会忽略所有文本。 使用中括号可以引用类、 方法、 字段、 顶级变量、 函数、 和参数。 括号中的符号会在已记录的程序元素的词法域中进行解析。 下面是一个引用其他类和成员的文档注释： 1234567891011121314151617181920/// A domesticated South American camelid (Lama glama).////// 自从西班牙时代以来，/// 安第斯文化就将骆驼当做肉食类和运输类动物。class Llama &#123; String name; /// 喂养骆驼 [Food]. /// /// 典型的美洲驼每周吃一捆干草。 void feed(Food food) &#123; // ... &#125; /// 使用 [activity] 训练骆驼 /// [timeLimit] 分钟。 void exercise(Activity activity, int timeLimit) &#123; // ... &#125;&#125; 在生成的文档中，[Food] 会成为一个链接， 指向 Food 类的 API 文档。 解析 Dart 代码并生成 HTML 文档，可以使用 SDK 中的 documentation generation tool. 关于生成文档的实例，请参考 Dart API documentation. 关于文档结构的建议，请参考 Guidelines for Dart Doc Comments. 总结本页概述了 Dart 语言中常用的功能。 还有更多特性有待实现，但我们希望它们不会破坏现有代码。 有关更多信息，请参考 Dart language specification 和 Effective Dart.]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 风格指南]]></title>
    <url>%2F2020%2F03%2F12%2FDart-%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Dart 风格指南好的代码令人惊讶的重要部分是好的样式。一致的命名，排序和格式有助于代码是相同的外观相同。它利用了我们大多数人在眼系统中拥有的强大的模式匹配硬件。如果我们在整个Dart生态系统中使用一致的样式，那么这将使我们所有人更容易学习彼此的代码并做出贡献。 风格类型标识符在Dart中具有三种风格。 UpperCamelCase 大驼峰名称将每个单词的首字母大写，包括第一个。 lowerCamelCase 小驼峰名称为每个字的第一个字母，除了 第一它总是小写，即使它是一个缩写。 lowercase_with_underscores 小写字母+下划线。仅使用小写字母（即使是首字母缩写词），并使用下划线分隔单词。 类型使用大驼峰法Classes, enums, typedefs, 和 Type parameters 使用大驼峰，并且不使用分隔符。 12345class SliderMenu &#123; ... &#125;class HttpRequest &#123; ... &#125;typedef Predicate&lt;T&gt; = bool Function(T value); 包括注解类型也使用大驼峰： 123456789class Foo &#123; const Foo([arg]);&#125;@Foo(anArg)class A &#123; ... &#125;@Foo()class B &#123; ... &#125; 如果注解类的构造函数不接受参数，您可能希望为它创建一个单独的lowerCamelCase常量。 1234const foo = Foo();@fooclass C &#123; ... &#125; 子类使用大驼峰法123extension MyFancyList&lt;T&gt; on List&lt;T&gt; &#123; ... &#125;extension SmartIterable&lt;T&gt; on Iterable&lt;T&gt; &#123; ... &#125; Version note: Extensions are a Dart 2.7 language feature libraries, packages, directories, and source files using 小写字母+下划线12345/// goodlibrary peg_parser.source_scanner;import 'file_system.dart';import 'slider_menu.dart'; 12345/// badlibrary pegparser.SourceScanner;import 'file-system.dart';import 'SliderMenu.dart'; import 别名使用小写字母+下划线12345/// goodimport 'dart:math' as math;import 'package:angular_components/angular_components' as angular_components;import 'package:js/js.dart' as js; 12345/// badimport 'dart:math' as Math;import 'package:angular_components/angular_components' as angularComponents;import 'package:js/js.dart' as JS; 标识符使用小驼峰法1234567var item;HttpRequest httpRequest;void align(bool clearItems) &#123; // ...&#125; 常量标识符优先使用小驼峰12345678/// goodconst pi = 3.14;const defaultTimeout = 1000;final urlScheme = RegExp('^([a-z]+):');class Dice &#123; static final numberGenerator = Random();&#125; 12345678/// badconst PI = 3.14;const DefaultTimeout = 1000;final URL_SCHEME = RegExp('^([a-z]+):');class Dice &#123; static final NUMBER_GENERATOR = Random();&#125; 您可以使用 SCREAMING_CAPS 来保持与现有代码的一致性 当往已经使用了 SCREAMING_CAPS 风格的代码中新增时，继续使用 SCREAMING_CAPS 风格。 当生成与Java代码并行的Dart代码时——例如，在由protobufs生成的枚举类型中，继续使用 SCREAMING_CAPS 风格。 提示： 最开始版本使用的是 Java 的 SCREAMING_CAPS 风格，由于以下原因，改为小驼峰： SCREAMING_CAPS在很多情况下看起来都很糟糕，特别是对于CSS颜色之类的东西来说，它的enum值就更糟糕了。 常量经常被更改为最终的非const变量，这就需要频繁更改名称。 在enum类型上自动定义的值属性是const和小写的。 首字母缩写词和缩写词的首字母都要大写首字母缩写词很难读懂，而且多个相邻的首字母缩写词会导致名称模糊。例如，给定一个以HTTPSFTP开头的名称，就无法判断它是引用HTTPSFTP还是HTTPSFTP。 为了避免这种情况，首字母缩略词和缩写词要像普通单词一样大写，只有两个字母的首字母缩略词除外。(ID和Mr.等两个字母的缩写仍然像单词一样大写。) 1234567/// goodHttpConnectionInfouiHandlerIOStreamHttpRequestIdDB 1234567/// badHTTPConnectionUiHandlerIoStreamHTTPRequestIDDb 不要为非私有的标识符使用前导下划线默认下划线开头的都是私有成员。 不要使用前缀字母匈牙利符号和其他方案出现在BCPL时代，那时编译器并没有帮助您理解代码。因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码到标识符名称中。 12/// gooddefaultTimeout 12/// badkDefaultTimeout 顺序为了保持你的文件的前言整洁，我们有一个规定的顺序，指示的部分应该出现在该出现的位置上。每个“部分”之间应该用空行隔开。 使用 improt 时，优先将 dart 系统包放在第三方包之前BAD: 12345import 'package:bar/bar.dart';import 'package:foo/foo.dart';import 'dart:async'; // LINTimport 'dart:html'; // LINT BAD: 12345import 'dart:html'; // OKimport 'package:bar/bar.dart';import 'dart:async'; // LINTimport 'package:foo/foo.dart'; GOOD: 12345import 'dart:async'; // OKimport 'dart:html'; // OKimport 'package:bar/bar.dart';import 'package:foo/foo.dart'; 将“package:”导入放在相对路径导入之前BAD: 12345import 'a.dart';import 'b.dart';import 'package:bar/bar.dart'; // LINTimport 'package:foo/foo.dart'; // LINT BAD: 12345import 'package:bar/bar.dart'; // OKimport 'a.dart';import 'package:foo/foo.dart'; // LINTimport 'b.dart'; GOOD: 12345import 'package:bar/bar.dart'; // OKimport 'package:foo/foo.dart'; // OKimport 'a.dart';import 'b.dart'; 优先将“第三方”“包”导入放在其他导入之前BAD: 12345import 'package:myapp/io.dart';import 'package:myapp/util.dart';import 'package:bar/bar.dart'; // LINTimport 'package:foo/foo.dart'; // LINT GOOD: 12345import 'package:bar/bar.dart'; // OKimport 'package:foo/foo.dart'; // OKimport 'package:myapp/io.dart';import 'package:myapp/util.dart'; 在所有导入之后，请在单独的部分中指定导出BAD: 123import 'src/error.dart';export 'src/error.dart'; // LINTimport 'src/string_source.dart'; GOOD: 1234import 'src/error.dart';import 'src/string_source.dart';export 'src/error.dart'; // OK 按字母顺序对各部分进行排序BAD: 12345import 'package:foo/bar.dart'; // OKimport 'package:bar/bar.dart'; // LINTimport 'a/b.dart'; // OKimport 'a.dart'; // LINT GOOD: 12345import 'package:bar/bar.dart'; // OKimport 'package:foo/bar.dart'; // OKimport 'a.dart'; // OKimport 'a/b.dart'; // OK 格式化与许多语言一样，Dart忽略空白。然而,人类没有。具有一致的空白样式有助于确保人类读者以与编译器相同的方式查看代码。 使用 dartfmt 工具格式化你的代码格式化是一项繁琐的工作，在重构过程中尤其耗费时间。幸运的是，你不必为此担心。我们提供了一种复杂的自动代码格式化程序，称为dartfmt，它可以为您完成这项工作。我们有一些关于它所适用的规则的文档，但是dart的官方空格处理规则是由dartfmt生成的。 剩下的格式化指导方针是针对一些dartfmt无法为您解决的问题手动处理。 考虑更改你的代码，使其对格式更友好格式化程序尽其所能地处理你扔给它的任何代码，但它不能创造奇迹。如果您的代码有特别长的标识符、深度嵌套的表达式、不同类型的操作符的混合等，格式化的输出可能仍然难以阅读。 当这种情况发生时，重新组织或简化您的代码。考虑缩短局部变量名或将表达式提升为新的局部变量。换句话说，进行与手工格式化代码并使其更具可读性相同的修改。可以将dartmt看作是一种伙伴关系，在这种关系中，您可以一起工作，有时是迭代地工作，以生成漂亮的代码。 避免行超过80个字符易读性研究表明，长行文字很难阅读，因为当你移动到下一行的开头时，你的眼睛不得不走得更远。这就是报纸和杂志使用多栏文本的原因。 如果您真的希望行长度超过80个字符，我们的经验是，您的代码可能太过冗长，而且可能更紧凑一些。最主要的冒犯者通常是很长的名字。问问自己，“该类型名称中的每个单词都告诉了我一些重要的信息，还是防止了名称冲突?”如果不是，那就考虑忽略它。 注意，dartfmt为你做了99%的事情，但剩下的1%是你自己。它不会分割长字符串来容纳80个列，所以您必须手动进行分割。 例外:当URI或文件路径出现在注释或字符串中(通常在导入或导出中)，即使它导致行超过80个字符，它也可能保持完整。这使得在源文件中搜索路径变得更加容易。 例外:多行字符串可以包含超过80个字符的行，因为换行在字符串中很重要，将行分割成更短的行可以改变程序。 对所有流控制语句使用大括号这样做可以避免悬空else问题。 12345if (isWeekDay) &#123; print('Bike to work!');&#125; else &#123; print('Go dancing or read a book!');&#125; 例外:当你有一个没有else子句的if语句，并且整个if语句适合在一行，你可以省略大括号，如果你喜欢: if (arg == null) return defaultValue; 如果正文换行，则使用大括号: 1234/// goodif (overflowChars != other.overflowChars) &#123; return overflowChars &lt; other.overflowChars;&#125; 123/// badif (overflowChars != other.overflowChars) return overflowChars &lt; other.overflowChars;]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart 语法(1)]]></title>
    <url>%2F2020%2F03%2F11%2FDart-%E8%AF%AD%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[Dart 语法(1)一个简单的 Dart 程序下面的代码用到了很多 Dart 的基本功能： 12345678910// 定义一个函数printInteger(int aNumber) &#123; print('The number is $aNumber.'); // 打印到控制台。&#125;// 应用从这里开始执行。main() &#123; var number = 42; // 声明并初始化一个变量。 printInteger(number); // 调用函数。&#125; // 单行注释。 int 数据类型。一些其他 内置类型 包括 String , List , 和 bool 。 42 字面量。字面量是一种编译型常量。 print() 便利输出方式。 ‘…’ (or “…”) 字符串常量。 $variableName (或 ${expression}) 字符串插值： 包括字符串文字内部的变量或表达式的字符串。 main() 程序开始执行函数，该函数是特定的、必须的、顶级函数。 var 定义变量，通过这种方式定义变量不需要指定变量类型。 重要的概念在学习 Dart 语言时, 应该基于以下事实和概念： 任何保存在变量中的都是一个 对象 ， 并且所有的对象都是对应一个 类 的实例。 无论是数字，函数和 null 都是对象。所有对象继承自 Object 类。 尽管 Dart 是强类型的，但是 Dart 可以推断类型，所以类型注释是可选的。 在上面的代码中， number 被推断为 int 类型。 如果要明确说明不需要任何类型， 需要使用特殊类型 dynamic 。 Dart 支持泛型，如 List （整数列表）或 List （任何类型的对象列表）。 Dart 支持顶级函数（例如 main（） ）， 同样函数绑定在类或对象上（分别是 静态函数 和 实例函数 ）。 以及支持函数内创建函数 （ 嵌套 或 局部函数 ） 。 类似地， Dart 支持顶级 变量 ， 同样变量绑定在类或对象上（静态变量和实例变量）。 实例变量有时称为字段或属性。 与 Java 不同，Dart 没有关键字 “public” ， “protected” 和 “private” 。 如果标识符以下划线（_）开头，则它相对于库是私有的。 标识符 以字母或下划线（_）开头，后跟任意字母和数字组合。 Dart 语法中包含 表达式（ expressions ）（有运行时值）和 语句（ statements ）（没有运行时值）。 例如，条件表达式 condition ? expr1 : expr2 的值可能是 expr1 或 expr2 。 将其与 if-else 语句 相比较，if-else 语句没有值。 一条语句通常包含一个或多个表达式，相反表达式不能直接包含语句。 Dart 工具提示两种类型问题：警告_和_错误。 警告只是表明代码可能无法正常工作，但不会阻止程序的执行。 错误可能是编译时错误或者运行时错误。 编译时错误会阻止代码的执行; 运行时错误会导致代码在执行过程中引发 [异常]（#exception）。 关键字Dart 语言关键字列表。 abstract2 dynamic2 implements2 show1 as2 else import2 static2 assert enum in super async1 export2 interface2 switch await3 extends is sync1 break external2 library2 this case factory2 mixin2 throw catch false new true class final null try const finally on1 typedef2 continue for operator2 var covariant2 Function2 part2 void default get2 rethrow while deferred2 hide1 return with do if set2 yield3 避免使用这些单词作为标识符。 但是，如有必要，标有上标的关键字可以用作标识符： 带有 1 上标的单词为 上下文关键字， 仅在特定位置具有含义。 他们在任何地方都是有效的标识符。 带有 2 上标的单词为 内置标识符， 为了简化将 JavaScript 代码移植到 Dart 的工作， 这些关键字在大多数地方都是有效的标识符， 但它们不能用作类或类型名称，也不能用作 import 前缀。 带有 3 上标的单词是与 Dart 1.0 发布后添加的异步支持相关的更新，作为限制类保留字。不能在标记为 async ，async 或 sync 的任何函数体中使用 await 或 yield 作为标识符。 关键字表中的剩余单词都是保留字。 不能将保留字用作标识符。 变量创建一个变量并进行初始化: var name = &#39;Bob&#39;; 变量仅存储对象引用，这里的变量是 name 存储了一个 String 类型的对象引用。 “Bob” 是这个 String 类型对象的值。 name 变量的类型被推断为 String 。 但是也可以通过指定类型的方式，来改变变量类型。 如果对象不限定为单个类型，可以指定为 对象类型 或 动态类型。 dynamic name = &#39;Bob&#39;; 另一种方式是显式声明可以推断出的类型： String name = &#39;Bob&#39;; 提示： 本地局部变量遵守 风格建议指南 使用 var。 没有使用指定类型的方式。 默认值未初始化的变量默认值是 null。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型 也不例外。 12int lineCount;assert(lineCount == null); 提示： 在生产环境代码中 assert() 函数会被忽略，不会被调用。 在开发过程中, assert(condition) 会在非 true 的条件下抛出异常. Final 和 Const使用过程中从来不会被修改的变量， 可以使用 final 或 const, 而不是 var 或者其他类型， Final 变量的值只能被设置一次； Const 变量在编译时就已经固定 (Const 变量 是隐式 Final 的类型.) 最高级 final 变量或类变量在第一次使用时被初始化。 提示： 实例变量可以是 final 类型但不能是 const 类型。 必须在构造函数体执行之前初始化 final 实例变量 —— 在变量声明中，参数构造函数中或构造函数的初始化列表中进行初始化。 创建和设置一个 Final 变量： 12final name = 'Bob'; // Without a type annotationfinal String nickname = 'Bobby'; final 不能被修改: name = &#39;Alice&#39;; // Error: 一个 final 变量只能被设置一次。 如果需要在编译时就固定变量的值，可以使用 const 类型变量。 如果 Const 变量是类级别的，需要标记为 static const。 在这些地方可以使用在编译时就已经固定不变的值，字面量的数字和字符串， 固定的变量，或者是用于计算的固定数字： 12const bar = 1000000; // 压力单位 (dynes/cm2)const double atm = 1.01325 * bar; // 标准气压 Const 关键字不仅可以用于声明常量变量。 还可以用来创建常量值，以及声明创建常量值的构造函数。 任何变量都可以拥有常量值。 123var foo = const [];final bar = const [];const baz = []; // Equivalent to `const []` 声明 const 的初始化表达式中 const 可以被省略。 比如上面的 baz。 非 Final ， 非 const 的变量是可以被修改的，即使这些变量 曾经引用过 const 值。 foo = [1, 2, 3]; // 曾经引用过 const [] 常量值。 Const 变量的值不可以修改： baz = [42]; // Error: 常量变量不能赋值修改。 内建类型Dart 语言支持以下内建类型： Number String Boolean List (也被称为 Array) Map Set Rune (用于在字符串中表示 * Unicode 字符) Symbol 这些类型都可以被初始化为字面量。 例如, ‘this is a string’ 是一个字符串的字面量， true 是一个布尔的字面量。 因为在 Dart 所有的变量终究是一个对象（一个类的实例）， 所以变量可以使用 构造涵数 进行初始化。 一些内建类型拥有自己的构造函数。 例如， 通过 Map() 来构造一个 map 变量。 NumberDart 语言的 Number 有两种类型: int 整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -253 到 253 - 1. double 64位（双精度）浮点数，依据 IEEE 754 标准。 int 和 double 都是 num. 的子类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 abs()， ceil()， 和 floor()， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及其亚类型找不到你想要的方法， 尝试查找使用 dart:math 库。 整数类型不包含小数点。 下面是定义整数类型字面量的例子: 12var x = 1;var hex = 0xDEADBEEF; 如果一个数字包含小数点，那么就是小数类型。 下面是定义小数类型字面量的例子: 12var y = 1.1;var exponents = 1.42e5; 从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。 double z = 1; // 相当于 double z = 1.0. 版本提示： 在 2.1 之前，在 double 上下文中使用 int 字面量是错误的。 以下是将字符串转换为数字的方法，反之亦然： 123456789101112131415// String -&gt; intvar one = int.parse('1');assert(one == 1);// String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1);// int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1');// double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14'); int 特有的传统按位运算操作，移位（&lt;&lt;， &gt;&gt;），按位与（&amp;）以及 按位或（|）。 例如： 123assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001assert((3 | 4) == 7); // 0011 | 0100 == 0111 数字类型字面量是编译时常量。 在算术表达式中，只要参与计算的因子是编译时常量， 那么算术表达式的结果也是编译时常量。 123const msPerSecond = 1000;const secondsUntilRetry = 5;const msUntilRetry = secondsUntilRetry * msPerSecond; StringDart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。 1234var s1 = 'Single quotes work well for string literals.';var s2 = "Double quotes work just as well.";var s3 = 'It\'s easy to escape the string delimiter.';var s4 = "It's even easier to use the other delimiter."; 字符串可以通过 ${expression} 的方式内嵌表达式。 如果表达式是一个标识符，则 {} 可以省略。 在 Dart 中通过调用就对象的 toString() 方法来得到对象相应的字符串。 123456789var s = 'string interpolation';assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' + 'which is very handy.');assert('That deserves all caps. ' + '$&#123;s.toUpperCase()&#125; is very handy!' == 'That deserves all caps. ' + 'STRING INTERPOLATION is very handy!'); 提示： == 运算符用来测试两个对象是否相等。 在字符串中，如果两个字符串包含了相同的编码序列，那么这两个字符串相等。 可以使用 + 运算符来把多个字符串连接为一个，也可以把多个字面量字符串写在一起来实现字符串连接： 123456789var s1 = 'String ' 'concatenation' " works even over line breaks.";assert(s1 == 'String concatenation works even over ' 'line breaks.');var s2 = 'The + operator ' + 'works, as well.';assert(s2 == 'The + operator works, as well.'); 使用连续三个单引号或者三个双引号实现多行字符串对象的创建： 1234567var s1 = '''You can createmulti-line strings like this one.''';var s2 = """This is also amulti-line string."""; 使用 r 前缀，可以创建 “原始 raw” 字符串： var s = r&quot;In a raw string, even \n isn&#39;t special.&quot;; 一个编译时常量的字面量字符串中，如果存在插值表达式，表达式内容也是编译时常量， 那么该字符串依旧是编译时常量。 插入的常量值类型可以是 null，数值，字符串或布尔值。 12345678910111213// const 类型数据const aConstNum = 0;const aConstBool = true;const aConstString = 'a constant string';// 非 const 类型数据var aNum = 0;var aBool = true;var aString = 'a string';const aConstList = [1, 2, 3];const validConstString = '$aConstNum $aConstBool $aConstString'; //const 类型数据// const invalidConstString = '$aNum $aBool $aString $aConstList'; //非 const 类型数据 BooleanDart 使用 bool 类型表示布尔值。 Dart 只有字面量 true and false 是布尔类型， 这两个对象都是编译时常量。 Dart 的类型安全意味着不能使用 if (nonbooleanValue) 或者 assert (nonbooleanValue)。 而是应该像下面这样，明确的进行值检查： 123456789101112131415// 检查空字符串。var fullName = '';assert(fullName.isEmpty);// 检查 0 值。var hitPoints = 0;assert(hitPoints &lt;= 0);// 检查 null 值。var unicorn;assert(unicorn == null);// 检查 NaN 。var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List几乎每种编程语言中最常见的集合可能是 array 或有序的对象集合。 在 Dart 中的 Array 就是 List 对象， 通常称之为 List 。 Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例： var list = [1, 2, 3]; 提示： Dart 推断 list 的类型为 List 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。 Lists 的下标索引从 0 开始，第一个元素的索引是 0。 list.length - 1 是最后一个元素的索引。 访问 List 的长度和元素与 JavaScript 中的用法一样： 123456var list = [1, 2, 3];assert(list.length == 3);assert(list[1] == 2);list[1] = 1;assert(list[1] == 1); 在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量： 12var constantList = const [1, 2, 3];// constantList[1] = 1; // 取消注释会引起错误。 List 类型包含了很多 List 的操作函数。 Set在 Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 Set 类型。 版本提示： 虽然 Set 类型 一直是 Dart 的核心部分， 但在 Dart2.2 中才引入了 Set 字面量 。 下面是通过字面量创建 Set 的一个简单示例： var halogens = {&#39;fluorine&#39;, &#39;chlorine&#39;, &#39;bromine&#39;, &#39;iodine&#39;, &#39;astatine&#39;}; Note: Dart 推断 halogens 类型为 Set 。如果尝试为它添加一个 错误类型的值，分析器或执行时会抛出错误。 要创建一个空集，使用前面带有类型参数的 {} ，或者将 {} 赋值给 Set 类型的变量： 123var names = &lt;String&gt;&#123;&#125;;// Set&lt;String&gt; names = &#123;&#125;; // 这样也是可以的。// var names = &#123;&#125;; // 这样会创建一个 Map ，而不是 Set 。 是 Set 还是 Map ？ Map 字面量语法同 Set 字面量语法非常相似。 因为先有的 Map 字母量语法，所以 {} 默认是 Map 类型。 如果忘记在 {} 上注释类型或赋值到一个未声明类型的变量上， 那么 Dart 会创建一个类型为 Map&lt;dynamic, dynamic&gt; 的对象。 使用 add() 或 addAll() 为已有的 Set 添加元素： 123var elements = &lt;String&gt;&#123;&#125;;elements.add('fluorine');elements.addAll(halogens); 使用 .length 来获取 Set 中元素的个数： 1234var elements = &lt;String&gt;&#123;&#125;;elements.add('fluorine');elements.addAll(halogens);assert(elements.length == 5); 在 Set 字面量前增加 const ，来创建一个编译时 Set 常量： 12345678final constantSet = const &#123; 'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine',&#125;;// constantSet.add('helium'); // Uncommenting this causes an error. Map通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。 下面是使用 Map 字面量的两个简单例子： 123456789101112var gifts = &#123; // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings'&#125;;var nobleGases = &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;; 提示： Dart 会将 gifts 的类型推断为 Map&lt;String, String&gt;， nobleGases 的类型推断为 Map&lt;int, String&gt; 。 如果尝试在上面的 map 中添加错误类型，那么分析器或者运行时会引发错误。 以上 Map 对象也可以使用 Map 构造函数创建： 123456789var gifts = Map();gifts['first'] = 'partridge';gifts['second'] = 'turtledoves';gifts['fifth'] = 'golden rings';var nobleGases = Map();nobleGases[2] = 'helium';nobleGases[10] = 'neon';nobleGases[18] = 'argon'; 提示: 这里为什么只有 Map() ，而不是使用 new Map()。 因为在 Dart 2 中，new 关键字是可选的。 类似 JavaScript ，添加 key-value 对到已有的 Map 中： 12var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds'; // Add a key-value pair 类似 JavaScript ，从一个 Map 中获取一个 value： 12var gifts = &#123;'first': 'partridge'&#125;;assert(gifts['first'] == 'partridge'); 如果 Map 中不包含所要查找的 key，那么 Map 返回 null： 12var gifts = &#123;'first': 'partridge'&#125;;assert(gifts['fifth'] == null); 使用 .length 函数获取当前 Map 中的 key-value 对数量： 123var gifts = &#123;'first': 'partridge'&#125;;gifts['fourth'] = 'calling birds';assert(gifts.length == 2); 创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。 1234567final constantMap = const &#123; 2: 'helium', 10: 'neon', 18: 'argon',&#125;;// constantMap[2] = 'Helium'; // 取消注释会引起错误。 Rune在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。 Unicode 定义了一个全球的书写系统编码， 系统中使用的所有字母，数字和符号都对应唯一的数值编码。 由于 Dart 字符串是一系列 UTF-16 编码单元， 因此要在字符串中表示32位 Unicode 值需要特殊语法支持。 表示 Unicode 编码的常用方法是， \uXXXX, 这里 XXXX 是一个4位的16进制数。 例如，心形符号 (♥) 是 \u2665。 对于特殊的非 4 个数值的情况， 把编码值放到大括号中即可。 例如，emoji 的笑脸 (�) 是 \u{1f600}。 String 类有一些属性可以获得 rune 数据。 属性 codeUnitAt 和 codeUnit 返回16位编码数据。 属性 runes 获取字符串中的 Rune 。 Symbol一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。 12#radix#bar Symbol 字面量是编译时常量。]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview Http Https]]></title>
    <url>%2F2020%2F03%2F11%2FWebview-Http-Https%2F</url>
    <content type="text"><![CDATA[原文地址： https://blog.csdn.net/jinshitou2012/article/details/80307428]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Webview</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Chronometer 实现倒计时]]></title>
    <url>%2F2020%2F03%2F11%2F%E4%BD%BF%E7%94%A8-Chronometer-%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[使用 Chronometer 实现倒计时 在实际业务开发的场景中，经常会有要用到倒计时的功能，比如一个广告页面倒计时，比如一个超时自动关闭页面，等这些操作都离不开倒计时的概念。当然，我们完全可以自己去实现一个倒计时逻辑，例如使用 timer ，或者使用 RxJava 等各种定时策略。本文介绍一个比较简单的，系统原生提供的一个组件 Chronometer。 具体实现XML12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Chronometer android:id="@+id/chronometer" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:layout_centerHorizontal="true" /&gt;&lt;/RelativeLayout&gt; Activity12345678910111213141516171819202122232425262728public class ChronoActivity1 extends AppCompatActivity &#123; int time = 60; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Chronometer chronometer = findViewById(R.id.chronometer); chronometer.setOnChronometerTickListener(new Chronometer.OnChronometerTickListener() &#123; @Override public void onChronometerTick(Chronometer chronometer) &#123; if (time == 0) &#123; chronometer.setText("0"); chronometer.stop(); finish(); &#125; else &#123; time--; chronometer.setText(time + ""); &#125; &#125; &#125;); chronometer.start(); &#125;&#125; 是不是觉得非常简单呢？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveData may lost Data]]></title>
    <url>%2F2019%2F12%2F30%2FLiveData-may-lose-Data%2F</url>
    <content type="text"><![CDATA[声明： 本文翻译自Medium 文章 LiveData可能会丢失数据。在你说“没关系”之前，请检查所有的情况。 LiveData是谷歌的Android架构中最引人注目的明星组件之一。基本上，它是一个可观察的数据持有者，并在观察者处于活动状态时将数据更改发送给观察者。在Android应用程序中，视图通常附加到生命周期感知组件，如片段或活动。然而，生命周期感知组件可能被杀死、重新创建或分离(片段)，这使得访问视图变得危险和复杂。为了使视图层操作更加友好，LiveData向它的观察者引入了生命周期感知。每个观察者可以与一个LifecycleOwner相关联，通常是一个片段或活动，并防止在其LifecycleOwner不活动时将数据更改发送给观察者。此行为可以确保在执行不是“必要的”情况下，观察者中的逻辑不会被执行。例如，如果一个片段正在分离，它的视图将很快被销毁。在分离过程中，这个片段视图上的任何视图层操作都是不可见的，也是不必要的。相反，LiveData缓冲最后的数据更改，并在片段重新连接和重新创建视图时通知观察者，这可以将新视图实例“恢复”到最新状态，并防止潜在的NPE或内存泄漏。但是，由于LiveData在主线程上分发数据，并且只缓冲一个挂起的数据更改，所以您的观察者很少会错过或没有接收到数据更改。尽管谷歌的文档从未将LiveData定义为类似于rxjava的流框架，也没有建议使用LiveData，只是在视图和VM之间建立一个薄薄的粘合层，但我们仍然有必要研究所有可能的数据丢失场景，并避免生产中可能出现的意外行为。在下一节中，我们将通过示例讨论三种数据丢失情况。 将数据发送到活动状态之外LiveData是一个支持生命周期的组件。因此，只有在其LifecycleOwner处于活动状态时，才能将数据更改交付给观察者。如下图所示，当一个LifecycleOwner切换到“STARTED”或“resume”时，它是活动的。因此，LiveData观察者只能在其LifecycleOwner“启动”或“恢复”时接收数据更改更新。如果数据源将数据发送到活动状态之外的LiveData，则观察者将不会接收发送的数据。 假设我们有一个活动，它在其生命周期回调中将数据写入MutableLiveData。一个观察者正在观察MutableLiveData并打印出接收到的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ActiveGapActivity extends BaseActivity &#123; private static MutableLiveData&lt;String&gt; mutableLiveData = new MutableLiveData&lt;&gt;(); @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mutableLiveData.observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String string) &#123; System.out.println("ActiveGapActivity Observed: " + string); &#125; &#125;); mutableLiveData.setValue("onCreate"); &#125; @Override public void onResume() &#123; super.onResume(); mutableLiveData.setValue("onResume"); &#125; @Override public void onPause() &#123; super.onPause(); mutableLiveData.setValue("onPause"); &#125; @Override public void onStop() &#123; super.onStop(); System.out.println("ActiveGapActivity onStop called"); mutableLiveData.setValue("onStop"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); mutableLiveData.setValue("onDestroy"); &#125;&#125; 如果我们旋转app并触发Activity recreation，会打印如下日志: 12345678910ActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResumeActiveGapActivity Observed: onPauseActiveGapActivity onStop called &lt;== onStop() is calledActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResumeActiveGapActivity Observed: onPauseActiveGapActivity onStop calledActiveGapActivity Observed: onCreateActiveGapActivity Observed: onResume 如日志所示，观察者没有接收到“onStop”，这肯定是被调用的，因为“ActiveGapActivity onStop调用”被打印出来了。这种行为是由两个LiveData礼: LiveData可以缓冲一个数据实例; LiveData在其生命周期中不会通知观察者，而cleowner则处于“非活动”状态。 当我们旋转屏幕时，活动将被重新创建。将顺序调用当前活动实例的onStop()和onDestroy()。但是，由于活动不再活动，发出的数据将不会传递给观察者。而是在内部缓冲最新的数据实例，即“onDestroy”。当活动被重新创建时，第二个活动实例将发出“onCreate”，并覆盖之前的缓冲数据“onDestroy”。一旦活动(即LifecycleOwner)恢复活动，观察者将只接收缓冲的“onCreate”。onStop和onDestroy都丢失了。下图显示了在第二个活动的onCreate()中调用LiveData的setValue函数时的调试信息。显然，新的数据实例“onCreate”覆盖了先前由第一个实例的onDestroy()发出的缓冲数据实例(“mData”)。 从后台线程发出数据LiveData在主线程上调度数据。如果源从后台线程发出数据，则下游使用者不会立即收到更新。相反，发出的数据将在LiveData中进行缓冲，并等待主线程稍后进行调度。但是，由于LiveData只缓冲一个数据实例，如果数据源发出的数据比主线程分派的数据“更快”。新数据实例可能会覆盖已缓存的数据实例，从而导致数据丢失。让我们来看看下面的例子。在onResume()中启动一个AsyncTask，并向LiveData发送三个数据实例;在“onCreate”中初始化输出数据的观察者。 1234567891011121314151617181920212223242526272829303132public class PostValueSampleActivity extends BaseActivity &#123; private MutableLiveData&lt;Integer&gt; source; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); source = new MutableLiveData&lt;&gt;(); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append(integer.toString()); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; source.postValue(1); source.postValue(2); source.postValue(3); &#125; &#125;); &#125;&#125; 示例代码将只输出“3”，这是AsyncTask发出的最后一个数据。这个输出背后的魔力可以在LiveData的源代码中找到。 1234567891011protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125; 当一个后台线程向LiveData发送数据时，LiveData会将一个标记、postTask标记为true;发布一个runnable到主线程，将数据更改发送给观察者。如果后台线程发出数据“太频繁”(在主线程可运行完成之前)，新发布的数据将覆盖“mPendingData”。当主thead执行runnable并尝试分发数据更改时，它将获得最后的数据，即“mPendingData”保存的数据。 在观察者中发射数据由于LiveData在主线程上调度数据，所以在调度已经启动时，所有的事情都是(某种程度上)同步的。所有观察者将被迭代，并依次接收更新。但是，如果在观察者内部设置新的数据更改，则新的数据更改(我们称之为“B”)将覆盖当前正在调度的数据更改(我们称之为“A”)并终止当前调度周期。一些观察者可能不会永远得到“A”。假设有两个观察者。观察者2打印接收到的内容，但是如果接收到的数字是偶数，观察者1将把新值设置回LiveData。 12345678910111213141516171819202122232425262728293031323334353637public class SetValueSampleActivity extends BaseActivity &#123; private MutableLiveData&lt;Integer&gt; source; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); source = new MutableLiveData&lt;&gt;(); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append("Receiver 1: " + integer.toString()); if (integer % 2 == 0) &#123; source.setValue(integer * 10); source.setValue(integer * 10 + 1); &#125; &#125; &#125;); source.observe(this, new Observer&lt;Integer&gt;() &#123; @Override public void onChanged(@Nullable Integer integer) &#123; append("Receiver 2: " + integer.toString()); &#125; &#125;); &#125; @Override protected void onResume() &#123; super.onResume(); source.setValue(1); source.setValue(2); source.setValue(3); &#125;&#125; 此示例的输出如下图所示。观察者1收到1 2 21 3，观察者2收到1 21 3。 这种行为背后的原因有点复杂。让我们检查LiveData中的“dispatchingValue()”函数。从第2行到第6行可以看出，如果调度已经启动，任何新的数据集都不会启动另一个调度循环。相反，新的数据更改将覆盖挂起的数据(在setValue()函数中)，将“mDispatchInvalidated”设置为true并跳过(从第2行到第5行)。在我们的示例中，当观察者1接收到“2”时，它将“20”和“21”设置回LiveData。因为“mDispatchingValue”为真，所以“20”将不会被分派，而是被“21”覆盖。观察者1的逻辑完成后，由于“mDispatchInvalidated”为真，它将中断当前调度循环(从第13行到第19行，并停止观察者2接收“2”)，并使外部while循环再运行一次(从第7行到第21行)。在这个调度循环中，所有的观察者接收最后的数据“21”。 1234567891011121314151617181920212223private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; considerNotify(initiator); initiator = null; &#125; else &#123; for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false; &#125; github code↓↓https://github.com/hanyuliu/livedata_may_lose_data]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>LiveData</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 基础]]></title>
    <url>%2F2019%2F06%2F22%2FHTML-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基本结构12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体内容 &lt;/body&gt;&lt;/html&gt; HTML 标签语法 &lt;标签&gt;&lt;/标签&gt; 示例 “&lt;html&gt;&lt;/html&gt;” 规则 用 ‘&lt;’ 和 ‘&gt;’ 括起来 一般成对出现，分为开始标签和结束标签 结束标签比开始标签多了个 ‘/‘ 单标签没有结束标签，如 “&lt;hr/&gt;” HTML 元素从开始标签 到结束标签 的所有代码，称为 HTML 元素。 HTML 属性语法&lt;标签名 属性名1=”值” 属性名2=”值” 属性名3=”值” &gt;……&lt;/标签名&gt; 注释语法：&lt;!– 注释 –&gt; DOCTYPE&lt;!DOCTYPE html&gt; 必须放在文档第一行。 网页编码设置&lt;meta http-equiv=”Content-Type” content=”text/html;charset-utf8”&gt; 文字和段落 标题：h1 - h6 段落：p align 属性： left center right justify 换行：br 水平线：hr width px persent color rgb hex name black red … align noshade i/em b/strong sub sup ins del 特殊符号 &lt; -&gt; &amp;lt; &gt; -&gt; &amp;gt; &reg; -&gt; &amp;reg; &copy; -&gt; &amp;copy; &trade; -&gt; &amp;trade; 空格 -&gt; &amp;nbsp; 列表标签 无序列表 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 123&lt;ol&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 定义列表 123456&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/ol&gt; 图像标签1&lt;img src="" alt="" ../&gt; 超链接1&lt;a htef="" &gt;内容&lt;/a&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koin with ViewModel]]></title>
    <url>%2F2019%2F04%2F25%2FKoin-with-ViewModel%2F</url>
    <content type="text"><![CDATA[Architecture Components with Koin: ViewModelGradle setupChoose the koin-android-viewmodel dependency to add to your Gradle project (android or androix version): 12345678910// Add Jcenter to your repositories if neededrepositories &#123; jcenter()&#125;dependencies &#123; // ViewModel for Android implementation 'org.koin:koin-android-viewmodel:2.0.0-beta-4' // or ViewModel for AndroidX implementation 'org.koin:koin-androidx-viewmodel:2.0.0-beta-4'&#125; ViewModel DSLThe koin-android-viewmodel introduces a new viewModel DSL keyword that comes in complement of single and factory, to help declare a ViewModel component and bind it to an Android Component lifecycle. 12345678val appModule = module &#123; // ViewModel for Detail View viewModel &#123; DetailViewModel(get(), get()) &#125; // or viewModel&lt;DetailViewModel&gt;()&#125; Your declared component must at least extends the android.arch.lifecycle.ViewModel class. You can specify how you inject the constructor of the class and use the get() function to inject dependencies. The viewModel keyword helps declaring a factory instance of ViewModel. This instance will be handled by internal ViewModelFactory and reattach ViewModel instance if needed. The viewModel keyword can also let you use the injection parameters. Injecting your ViewModelTo inject a ViewModel in an Activity, Fragment or Service use: by viewModel() - lazy delegate property to inject a ViewModel into a property getViewModel() - directly get the ViewModel instance 12345class DetailActivity : AppCompatActivity() &#123; // Lazy inject ViewModel val detailViewModel: DetailViewModel by viewModel()&#125; Shared ViewModelOne ViewModel instance can be shared between Fragments and their host Activity. To inject a shared ViewModel in a Fragment use: by sharedViewModel() - lazy delegate property to inject shared ViewModel instance into a property getSharedViewModel() - directly get the shared ViewModel instance Just declare the ViewModel only once: 1234567val weatherAppModule = module &#123; // WeatherViewModel declaration for Weather View components viewModel &#123; WeatherViewModel(get(), get()) &#125; // or viewModel&lt;WeatherViewModel&gt;()&#125; And reuse it in Activity and Fragments: 1234567891011121314151617181920212223class WeatherActivity : AppCompatActivity() &#123; /* * Declare WeatherViewModel with Koin and allow constructor dependency injection */ private val weatherViewModel by viewModel&lt;WeatherViewModel&gt;()&#125;class WeatherHeaderFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125;class WeatherListFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125; ViewModel and injection parametersthe viewModel keyword and injection API is compatible with injection parameters. In the module: 12345val appModule = module &#123; // ViewModel for Detail View with id as parameter injection viewModel &#123; (id : String) -&gt; DetailViewModel(id, get(), get()) &#125;&#125; From the injection call site: 1234567class DetailActivity : AppCompatActivity() &#123; val id : String // id of the view // Lazy inject ViewModel with id parameter val detailViewModel: DetailViewModel by viewModel&#123; parametersOf(id)&#125;&#125; that’s all, thanks for your reading.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>Koin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Groovy Syntax]]></title>
    <url>%2F2019%2F04%2F23%2FGroovy-Syntax%2F</url>
    <content type="text"><![CDATA[Reference: Apache GroovyThis chapter covers the syntax of the Groovy programming language. The grammar of the language derives from the Java grammar, but enhances it with specific constructs for Groovy, and allows certain simplifications. CommentsSingle line commentSingle line comments start with // and can be found at any position in the line. The characters following //, till the end of the line, are considered part of the comment. 12// a standalone single line commentprintln "hello" // a comment till the end of the line Multiline commentA multiline comment starts with / and can be found at any position in the line. The characters following / will be considered part of the comment, including new line characters, up to the first */ closing the comment. Multiline comments can thus be put at the end of a statement, or even inside a statement. 12345/* a standalone multiline comment spanning two lines */println "hello" /* a multiline comment starting at the end of a statement */println 1 /* one */ + 2 /* two */ GroovyDoc commentSimilarly to multiline comments, GroovyDoc comments are multiline, but start with /* and end with /. Lines following the first GroovyDoc comment line can optionally start with a star *. Those comments are associated with: type definitions (classes, interfaces, enums, annotations), fields and properties definitions methods definitions Although the compiler will not complain about GroovyDoc comments not being associated with the above language elements, you should prepend those constructs with the comment right before it. 1234567891011121314151617/** * A Class description */class Person &#123; /** the name of the person */ String name /** * Creates a greeting method for a certain person. * * @param otherPerson the person to greet * @return a greeting message */ String greet(String otherPerson) &#123; "Hello $&#123;otherPerson&#125;" &#125;&#125; GroovyDoc follows the same conventions as Java’s own JavaDoc. So you’ll be able to use the same tags as with JavaDoc. Shebang lineBeside the single line comment, there is a special line comment, often called the shebang line understood by UNIX systems which allows scripts to be run directly from the command-line, provided you have installed the Groovy distribution and the groovy command is available on the PATH. 12#!/usr/bin/env groovyprintln "Hello from the shebang line" The # character must be the first character of the file. Any indentation would yield a compilation error. KeywordsThe following list represents all the keywords of the Groovy language: as assert catch class break case const continue const continue def default do else enum extends false finally for goto if implements import in instanceof interface new null package return super switch this throw throws trait true try while IdentifiersNormal identifiersIdentifiers start with a letter, a dollar or an underscore. They cannot start with a number. A letter can be in the following ranges: ‘a’ to ‘z’ (lowercase ascii letter) ‘A’ to ‘Z’ (uppercase ascii letter) ‘\u00C0’ to ‘\u00D6’ ‘\u00D8’ to ‘\u00F6’ ‘\u00F8’ to ‘\u00FF’ ‘\u0100’ to ‘\uFFFE’ Then following characters can contain letters and numbers. Here are a few examples of valid identifiers (here, variable names): 1234def namedef item3def with_underscoredef $dollarStart But the following ones are invalid identifiers: 123def 3tierdef a+bdef a#b All keywords are also valid identifiers when following a dot: 12345foo.asfoo.assertfoo.breakfoo.casefoo.catch Quoted identifiersQuoted identifiers appear after the dot of a dotted expression. For instance, the name part of the person.name expression can be quoted with person.&quot;name&quot; or person.&#39;name&#39;. This is particularly interesting when certain identifiers contain illegal characters that are forbidden by the Java Language Specification, but which are allowed by Groovy when quoted. For example, characters like a dash, a space, an exclamation mark, etc. 1234567def map = [:]map."an identifier with a space and double quotes" = "ALLOWED"map.'with-dash-signs-and-single-quotes' = "ALLOWED"assert map."an identifier with a space and double quotes" == "ALLOWED"assert map.'with-dash-signs-and-single-quotes' == "ALLOWED" As we shall see in the following section on strings, Groovy provides different string literals. All kind of strings are actually allowed after the dot: 123456map.'single quote'map."double quote"map.'''triple single quote'''map."""triple double quote"""map./slashy string/map.$/dollar slashy string/$ There’s a difference between plain character strings and Groovy’s GStrings (interpolated strings), as in that the latter case, the interpolated values are inserted in the final string for evaluating the whole identifier: 1234def firstname = "Homer"map."Simpson-$&#123;firstname&#125;" = "Homer Simpson"assert map.'Simpson-Homer' == "Homer Simpson" StringsText literals are represented in the form of chain of characters called strings. Groovy lets you instantiate java.lang.String objects, as well as GStrings (groovy.lang.GString) which are also called interpolated strings in other programming languages. Single quoted stringSingle quoted strings are a series of characters surrounded by single quotes: 1'a single quoted string' Single quoted strings are plain java.lang.String and don’t support interpolation. String concatenationAll the Groovy strings can be concatenated with the + operator: 1assert 'ab' == 'a' + 'b' Triple single quoted stringTriple single quoted strings are a series of characters surrounded by triplets of single quotes: 1Triple single quoted strings are a series of characters surrounded by triplets of single quotes: Triple single quoted strings are plain java.lang.String and don’t support interpolation. Triple single quoted strings are multiline. You can span the content of the string across line boundaries without the need to split the string in several pieces, without contatenation or newline escape characters: 123def aMultilineString = '''line oneline twoline three''' If your code is indented, for example in the body of the method of a class, your string will contain the whitespace of the indentation. The Groovy Development Kit contains methods for stripping out the indentation with the String#stripIndent() method, and with the String#stripMargin() method that takes a delimiter character to identify the text to remove from the beginning of a string. When creating a string as follows: 12345def startingAndEndingWithANewline = '''line oneline twoline three''' You will notice that the resulting string contains a newline character as first character. It is possible to strip that character by escaping the newline with a backslash: 1234567def strippedFirstNewline = '''\line oneline twoline three'''assert !strippedFirstNewline.startsWith('\n') Escaping special charactersYou can escape single quotes with the the backslash character to avoid terminating the string literal: 1'an escaped single quote: \' needs a backslash' And you can escape the escape character itself with a double backslash: 1'an escaped escape character: \\ needs a double backslash' Some special characters also use the backslash as escape character: ‘\t’ tabulation ‘\b’ backspace ‘\n’ newline ‘\r’ carriage return ‘\f’ formfeed ‘\‘ backslash ‘\’’ single quote (for single quoted and triple single quoted strings) ‘\”‘ double quote (for double quoted and triple double quoted strings) Unicode escape sequenceFor characters that are not present on your keyboard, you can use unicode escape sequences: a backslash, followed by ‘u’, then 4 hexadecimal digits. For example, the Euro currency symbol can be represented with: 1'The Euro currency symbol: \u20AC' Double quoted stringDouble quoted strings are a series of characters surrounded by double quotes: 1"a double quoted string" Double quoted strings are plain java.lang.String if there’s no interpolated expression, but are groovy.lang.GString instances if interpolation is present. To escape a double quote, you can use the backslash character: “A double quote: \””. String interpolationAny Groovy expression can be interpolated in all string literals, apart from single and triple single quoted strings. Interpolation is the act of replacing a placeholder in the string with its value upon evaluation of the string. The placeholder expressions are surrounded by ${} or prefixed with $ for dotted expressions. The expression value inside the placeholder is evaluated to its string representation when the GString is passed to a method taking a String as argument by calling toString() on that expression. Here, we have a string with a placeholder referencing a local variable: 1234def name = 'Guillaume' // a plain stringdef greeting = "Hello $&#123;name&#125;"assert greeting.toString() == 'Hello Guillaume' But any Groovy expression is valid, as we can see in this example with an arithmetic expression: 12def sum = "The sum of 2 and 3 equals $&#123;2 + 3&#125;"assert sum.toString() == 'The sum of 2 and 3 equals 5' Not only are expressions allowed in between the ${} placeholder, but so are statements. However, a statement’s value is just null. So if several statements are inserted in that placeholder, the last one should somehow return a meaningful value to be inserted. For instance, “The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}” is supported and works as expected but a good practice is usually to stick to simple expressions inside GString placeholders. In addition to ${} placeholders, we can also use a lone $ sign prefixing a dotted expression: 12def person = [name: 'Guillaume', age: 36]assert "$person.name is $person.age years old" == 'Guillaume is 36 years old' But only dotted expressions of the form a.b, a.b.c, etc, are valid, but expressions that would contain parentheses like method calls, curly braces for closures, or arithmetic operators would be invalid. Given the following variable definition of a number: 1def number = 3.14 The following statement will throw a groovy.lang.MissingPropertyException because Groovy believes you’re trying to access the toString property of that number, which doesn’t exist: 123shouldFail(MissingPropertyException) &#123; println "$number.toString()"&#125; You can think of “$number.toString()” as being interpreted by the parser as “${number.toString()}”. If you need to escape the $ or ${} placeholders in a GString so they appear as is without interpolation, you just need to use a \ backslash character to escape the dollar sign: 1assert '$&#123;name&#125;' == "\$&#123;name&#125;" Special case of interpolating closure expressionsSo far, we’ve seen we could interpolate arbitrary expressions inside the ${} placeholder, but there is a special case and notation for closure expressions. When the placeholder contains an arrow, ${→}, the expression is actually a closure expression — you can think of it as a closure with a dollar prepended in front of it: 12345def sParameterLessClosure = "1 + 2 == $&#123;-&gt; 3&#125;" ①assert sParameterLessClosure == '1 + 2 == 3'def sOneParamClosure = "1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;" ②assert sOneParamClosure == '1 + 2 == 3' ① The closure is a parameterless closure which doesn’t take arguments. ② Here, the closure takes a single java.io.StringWriter argument, to which you can append content with the &lt;&lt; leftShift operator. In either case, both placeholders are embedded closures. In appearance, it looks like a more verbose way of defining expressions to be interpolated, but closures have an interesting advantage over mere expressions: lazy evaluation. Let’s consider the following sample: 1234567891011def number = 1 ①def eagerGString = "value == $&#123;number&#125;"def lazyGString = "value == $&#123; -&gt; number &#125;"assert eagerGString == "value == 1" ②assert lazyGString == "value == 1" ③number = 2 ④assert eagerGString == "value == 1" ⑤assert lazyGString == "value == 2" ⑥ ① We define a number variable containing 1 that we then interpolate within two GStrings, as an expression in eagerGString and as a closure in lazyGString. ② We expect the resulting string to contain the same string value of 1 for eagerGString. ③ Similarly for lazyGString ④ Then we change the value of the variable to a new number ⑤ With a plain interpolated expression, the value was actually bound at the time of creation of the GString. ⑥ But with a closure expression, the closure is called upon each coercion of the GString into String, resulting in an updated string containing the new number value. An embedded closure expression taking more than one parameter will generate an exception at runtime. Only closures with zero or one parameters are allowed. Interoperability with JavaWhen a method (whether implemented in Java or Groovy) expects a java.lang.String, but we pass a groovy.lang.GString instance, the toString() method of the GString is automatically and transparently called. String takeString(String message) { ④ assert message instanceof String ⑤ return message} def message = “The message is ${‘hello’}” ①assert message instanceof GString ② def result = takeString(message) ③assert result instanceof Stringassert result == ‘The message is hello’ ① We create a GString variable ② We double check it’s an instance of the GString ③ We then pass that GString to a method taking a String as parameter ④ The signature of the takeString() method explicitly says its sole parameter is a String ⑤ We also verify that the parameter is indeed a String and not a GString. GString and String hashCodesAlthough interpolated strings can be used in lieu of plain Java strings, they differ with strings in a particular way: their hashCodes are different. Plain Java strings are immutable, whereas the resulting String representation of a GString can vary, depending on its interpolated values. Even for the same resulting string, GStrings and Strings don’t have the same hashCode. 1assert "one: $&#123;1&#125;".hashCode() != "one: 1".hashCode() GString and Strings having different hashCode values, using GString as Map keys should be avoided, especially if we try to retrieve an associated value with a String instead of a GString. 1234def key = "a"def m = ["$&#123;key&#125;": "letter $&#123;key&#125;"] ①assert m["a"] == null ② ① The map is created with an initial pair whose key is a GString ② When we try to fetch the value with a String key, we will not find it, as Strings and GString have different hashCode values Triple double quoted stringTriple double quoted strings behave like double quoted strings, with the addition that they are multiline, like the triple single quoted strings. 123456789101112def name = 'Groovy'def template = """ Dear Mr $&#123;name&#125;, You're the winner of the lottery! Yours sincerly, Dave"""assert template.toString().contains('Groovy') Neither double quotes nor single quotes need be escaped in triple double quoted strings. Slashy stringBeyond the usual quoted strings, Groovy offers slashy strings, which use / as delimiters. Slashy strings are particularly useful for defining regular expressions and patterns, as there is no need to escape backslashes. Example of a slashy string: 12def fooPattern = /.*foo.*/assert fooPattern == '.*foo.*' Only forward slashes need to be escaped with a backslash: 12def escapeSlash = /The character \/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' Slashy strings are multiline: 1234def multilineSlashy = /one two three/assert multilineSlashy.contains('\n') Slashy strings can also be interpolated (ie. a GString): 1234def color = 'blue'def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == 'a blue car' There are a few gotchas to be aware of. An empty slashy string cannot be represented with a double forward slash, as it’s understood by the Groovy parser as a line comment. That’s why the following assert would actually not compile as it would look like a non-terminated statement: 1assert '' == // As slashy strings were mostly designed to make regexp easier so a few things that are errors in GStrings like $() will work with slashy strings. Dollar slashy stringDollar slashy strings are multiline GStrings delimited with an opening $/ and and a closing /$. The escaping character is the dollar sign, and it can escape another dollar, or a forward slash. But both dollar and forward slashes don’t need to be escaped, except to escape the dollar of a string subsequence that would start like a GString placeholder sequence, or if you need to escape a sequence that would start like a closing dollar slashy string delimiter. Here’s an example: 123456789101112131415161718192021222324252627def name = "Guillaume"def date = "April, 1st"def dollarSlashy = $/ Hello $name, today we're $&#123;date&#125;. $ dollar sign $$ escaped dollar sign \ backslash / forward slash $/ escaped forward slash $$$/ escaped opening dollar slashy $/$$ escaped closing dollar slashy/$assert [ 'Guillaume', 'April, 1st', '$ dollar sign', '$ escaped dollar sign', '\\ backslash', '/ forward slash', '/ escaped forward slash', '$/ escaped opening dollar slashy', '/$ escaped closing dollar slashy'].every &#123; dollarSlashy.contains(it) &#125; String summary table String name String syntax Interpolated Multiline Escape character Single quoted ‘…​’ \ Triple single quoted ‘’’…​’’’ √ \ Double quoted ‘’…​’’ √ \ Triple double quoted “””…””” √ √ \ Slashy /…​/ √ √ \ Dollar slashy \$/…​/\$ √ √ $ CharactersUnlike Java, Groovy doesn’t have an explicit character literal. However, you can be explicit about making a Groovy string an actual character, by three different means: 12345678char c1 = 'A' ①assert c1 instanceof Characterdef c2 = 'B' as char ②assert c2 instanceof Characterdef c3 = (char)'C' ③assert c3 instanceof Character ① by being explicit when declaring a variable holding the character by specifying the char type ② by using type coercion with the as operator ③ by using a cast to char operation The first option ① is interesting when the character is held in a variable, while the other two (② and ③) are more interesting when a char value must be passed as argument of a method call. NumbersIntegral literalsThe integral literal types are the same as in Java: byte char short int long java.lang.BigInteger You can create integral numbers of those types with the following declarations: 123456789// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6 If you use optional typing by using the def keyword, the type of the integral number will vary: it’ll adapt to the capacity of the type that can hold that number. For positive numbers: 123456789101112131415161718def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger As well as for negative numbers: 123456789101112131415161718def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger Alternative non-base 10 representationsNumbers can also be represented in binary, octal, hexadecimal and decimal bases. Binary literalBinary numbers start with a 0b prefix: 1234567891011121314151617int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175 Octal literalOctal numbers are specified in the typical format of 0 followed by octal digits. 1234567891011121314151617int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63 Hexadecimal literalHexadecimal numbers are specified in the typical format of 0x followed by hex digits. 1234567891011121314151617181920int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double('0x1.0p0')assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119 Decimal literalsThe decimal literal types are the same as in Java: float double java.lang.BigDecimal You can create decimal numbers of those types with the following declarations: 123456// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456 Decimals can use exponents, with the e or E exponent letter, followed by an optional sign, and a integral number representing the exponent: 12345assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04assert 5e-1 == 0.5 Conveniently for exact decimal number calculations, Groovy choses java.lang.BigDecimal as its decimal number type. In addition, both float and double are supported, but require an explicit type declaration, type coercion or suffix. Even if BigDecimal is the default for decimal numbers, such literals are accepted in methods or closures taking float or double as parameter types. Decimal numbers can’t be represented using a binary, octal or hexadecimal representation. Underscore in literalsWhen writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups: 12345678long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010 Number type suffixesWe can force a number (including binary, octals and hexadecimals) to have a specific type by giving a suffix (see table below), either uppercase or lowercase. Type Suffix BigInteger G or g Long L or l Integer I or i BigDecimal G or g Double D or d Float F or f Examples: 12345678910111213assert 42I == new Integer('42')assert 42i == new Integer('42') // lowercase i more readableassert 123L == new Long("123") // uppercase L more readableassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integerassert 456G == new BigInteger('456')assert 456g == new BigInteger('456')assert 123.45 == new BigDecimal('123.45') // default BigDecimal type usedassert 1.200065D == new Double('1.200065')assert 1.234F == new Float('1.234')assert 1.23E23D == new Double('1.23E23')assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal Math operationsAlthough operators are covered later on, it’s important to discuss the behavior of math operations and what their resulting types are. Division and power binary operations aside (covered below), binary operations between byte, char, short and int result in int binary operations involving long with byte, char, short and int result in long binary operations involving BigInteger and any other integral type result in BigInteger binary operations involving BigDecimal with byte, char, short, int and BigInteger result in BigDecimal binary operations between float, double and BigDecimal result in double binary operations between two BigDecimal result in BigDecimal The following table summarizes those rules: byte char short int long BigInteger float double BigDecimal byte byte char short int long BigInteger float double BigDecimal char char short int long BigInteger float double BigDecimal short short int long BigInteger float double BigDecimal int int long BigInteger float double BigDecimal long long BigInteger float double BigDecimal BigInteger BigInteger float double BigDecimal float float double BigDecimal double double BigDecimal BigDecimal BigDecimal Thanks to Groovy’s operator overloading, the usual arithmetic operators work as well with BigInteger and BigDecimal, unlike in Java where you have to use explicit methods for operating on those numbers. The case of the division operatorThe division operators / (and /= for division and assignment) produce a double result if either operand is a float or double, and a BigDecimal result otherwise (when both operands are any combination of an integral type short, char, byte, int, long, BigInteger or BigDecimal). BigDecimal division is performed with the divide() method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a MathContext with a precision of the maximum of the two operands’ precision plus an extra precision of 10, and a scale of the maximum of 10 and the maximum of the operands’ scale. For integer division like in Java, you should use the intdiv() method, as Groovy doesn’t provide a dedicated integer division operator symbol. The case of the power operatorThe power operation is represented by the ** operator, with two parameters: the base and the exponent. The result of the power operation depends on its operands, and the result of the operation (in particular if the result can be represented as an integral value). The following rules are used by Groovy’s power operation to determine the resulting type: If the exponent is a decimal value if the result can be represented as an Integer, then return an Integer else if the result can be represented as a Long, then return a Long otherwise return a Double If the exponent is an integral value if the exponent is strictly negative, then return an Integer, Long or Double if the result value fits in that type if the exponent is positive or zero if the base is a BigDecimal, then return a BigDecimal result value if the base is a BigInteger, then return a BigInteger result value if the base is an Integer, then return an Integer if the result value fits in it, otherwise a BigInteger if the base is a Long, then return a Long if the result value fits in it, otherwise a BigInteger We can illustrate those rules with a few examples: 12345678910111213141516171819202122232425262728293031323334353637// base and exponent are ints and the result can be represented by an Integerassert 2 ** 3 instanceof Integer // 8assert 10 ** 9 instanceof Integer // 1_000_000_000// the base is a long, so fit the result in a Long// (although it could have fit in an Integer)assert 5L ** 2 instanceof Long // 25// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger // 10e20assert 1234 ** 123 instanceof BigInteger // 170515806212727042875...// the base is a BigDecimal and the exponent a negative int// but the result can be represented as an Integerassert 0.5 ** -2 instanceof Integer // 4// the base is an int, and the exponent a negative float// but again, the result can be represented as an Integerassert 1 ** -0.3f instanceof Integer // 1// the base is an int, and the exponent a negative int// but the result will be calculated as a Double// (both base and exponent are actually converted to doubles)assert 10 ** -1 instanceof Double // 0.1// the base is a BigDecimal, and the exponent is an int, so return a BigDecimalassert 1.2 ** 10 instanceof BigDecimal // 6.1917364224// the base is a float or double, and the exponent is an int// but the result can only be represented as a Double valueassert 3.4f ** 5 instanceof Double // 454.35430372146965assert 5.6d ** 2 instanceof Double // 31.359999999999996// the exponent is a decimal value// and the result can only be represented as a Double valueassert 7.8 ** 1.9 instanceof Double // 49.542708423868476assert 2 ** 0.1f instanceof Double // 1.0717734636432956 BooleansBoolean is a special data type that is used to represent truth values: true and false. Use this data type for simple flags that track true/false conditions. Boolean values can be stored in variables, assigned into fields, just like any other data type: 123def myBooleanVariable = trueboolean untypedBooleanVar = falsebooleanField = true true and false are the only two primitive boolean values. But more complex boolean expressions can be represented using logical operators. In addition, Groovy has special rules (often referred to as Groovy Truth) for coercing non-boolean objects to a boolean value. ListsGroovy uses a comma-separated list of values, surrounded by square brackets, to denote lists. Groovy lists are plain JDK java.util.List, as Groovy doesn’t define its own collection classes. The concrete list implementation used when defining list literals are java.util.ArrayList by default, unless you decide to specify otherwise, as we shall see later on. 1234def numbers = [1, 2, 3] ①assert numbers instanceof List assert numbers.size() == 3 ② ① We define a list numbers delimited by commas and surrounded by square brackets, and we assign that list into a variable ② The list is an instance of Java’s java.util.List interface ③ The size of the list can be queried with the size() method, and shows our list contains 3 elements In the above example, we used a homogeneous list, but you can also create lists containing values of heterogeneous types: 1def heterogeneous = [1, "a", true] ① ① Our list here contains a number, a string and a boolean value We mentioned that by default, list literals are actually instances of java.util.ArrayList, but it is possible to use a different backing type for our lists, thanks to using type coercion with the as operator, or with explicit type declaration for your variables: 12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList ①assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] ②assert otherLinked instanceof java.util.LinkedList ① We use coercion with the as operator to explicitly request a java.util.LinkedList implementation ② We can say that the variable holding the list literal is of type java.util.LinkedList You can access elements of the list with the [] subscript operator (both for reading and setting values) with positive indices or negative indices to access elements from the end of the list, as well as with ranges, and use the &lt;&lt; leftShift operator to append elements to a list: 1234567891011121314151617def letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a' ①assert letters[1] == 'b'assert letters[-1] == 'd' ②assert letters[-2] == 'c'letters[2] = 'C' ③assert letters[2] == 'C'letters &lt;&lt; 'e' ④assert letters[ 4] == 'e'assert letters[-1] == 'e'assert letters[1, 3] == ['b', 'd'] ⑤assert letters[2..4] == ['C', 'd', 'e'] ⑥ ① Access the first element of the list (zero-based counting) ② Access the last element of the list with a negative index: -1 is the first element from the end of the list ③ Use an assignment to set a new value for the third element of the list ④ Use the &lt;&lt; leftShift operator to append an element at the end of the list ⑤ Access two elements at once, returning a new list containing those two elements ⑥ Use a range to access a range of values from the list, from a start to an end element position As lists can be heterogeneous in nature, lists can also contain other lists to create multi-dimensional lists: 12def multi = [[0, 1], [2, 3]] ①assert multi[1][0] == 2 ② ① Define a list of list of numbers ② Access the second element of the top-most list, and the first element of the inner list ArraysGroovy reuses the list notation for arrays, but to make such literals arrays, you need to explicitely define the type of the array through coercion or type declaration. 123456789String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] ①assert arrStr instanceof String[] ②assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] ③assert numArr instanceof int[] ④assert numArr.size() == 3 ① Define an array of strings using explicit variable type declaration ② Assert that we created an array of strings ③ Create an array of ints with the as operator ④ Assert that we created an array of primitive ints You can also create multi-dimensional arrays: 123456def matrix3 = new Integer[3][3] ①assert matrix3.size() == 3Integer[][] matrix2 ②matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][] ① You can define the bounds of a new array ② Or declare an array without specifying its bounds Access to elements of an array follows the same notation as for lists: 12345String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']assert names[0] == 'Cédric' ①names[2] = 'Blackdrag' ②assert names[2] == 'Blackdrag' ① Retrieve the first element of the array ② Set the value of the third element of the array to a new value Java’s array initializer notation is not supported by Groovy, as the curly braces can be misinterpreted with the notation of Groovy closures. MapsSometimes called dictionaries or associative arrays in other languages, Groovy features maps. Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets. 123456789101112def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']①assert colors['red'] == '#FF0000' ②assert colors.green == '#00FF00' ③colors['pink'] = '#FF00FF' ④colors.yellow = '#FFFF00' ⑤assert colors.pink == '#FF00FF'assert colors['yellow'] == '#FFFF00'assert colors instanceof java.util.LinkedHashMap ① We define a map of string color names, associated with their hexadecimal-coded html colors ② We use the subscript notation to check the content associated with the red key ③ We can also use the property notation to assert the color green’s hexadecimal representation ④ Similarly, we can use the subscript notation to add a new key/value pair ⑤ Or the property notation, to add the yellow color When using names for the keys, we actually define string keys in the map.Groovy creates maps that are actually instances of java.util.LinkedHashMap. If you try to access a key which is not present in the map: 1assert colors.unknown == null You will retrieve a null result. In the examples above, we used string keys, but you can also use values of other types as keys: 123def numbers = [1: 'one', 2: 'two']assert numbers[1] == 'one' Here, we used numbers as keys, as numbers can unambiguously be recognized as numbers, so Groovy will not create a string key like in our previous examples. But consider the case you want to pass a variable in lieu of the key, to have the value of that variable become the key: 12345def key = 'name'def person = [key: 'Guillaume'] ①assert !person.containsKey('name') ②assert person.containsKey('key') ③ ① The key associated with the ‘Guillaume’ name will actually be the “key” string, not the value associated with the key variable ② The map doesn’t contain the ‘name’ key ③Instead, the map contains a ‘key’ key You can also pass quoted strings as well as keys: [“name”: “Guillaume”]. This is mandatory if your key string isn’t a valid identifier, for example if you wanted to create a string key containing a hash like in: [“street-name”: “Main street”]. When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses: 1234person = [(key): 'Guillaume'] ①assert person.containsKey('name') ②assert !person.containsKey('key') ③ ① This time, we surround the key variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key ② The map does contain the name key ③ But the map doesn’t contain the key key as before that’s all, thanks for your reading.]]></content>
      <categories>
        <category>Groovy</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译] 高级 DataBinding: 绑定到 LiveData (单向绑定 & 双向绑定)]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AF%91-%E9%AB%98%E7%BA%A7-DataBinding-%E7%BB%91%E5%AE%9A%E5%88%B0-LiveData-%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[声明： 本文翻译自Medium 文章 数据绑定库在 Android 应用程序的生产中越来越受欢迎，因为它扩大了 MVVM 架构的优势。它允许您使用声明性格式而不是以编程方式将布局中的UI组件绑定到应用程序中的数据源。自动通知UI关于数据的变化并获得传播回来的UI属性的变化，这不是很好吗？那么让我们看看我们如何通过单向和双向绑定绑定到 LiveData ！ 为什么绑定到 LiveData？使用生命周期感知组件（如LiveData）的优点包括： 没有因停止活动而崩溃。如果观察者的生命周期处于非活动状态，例如活动位于后台堆栈中，则它不会收到任何 LiveData 事件。 自适应的配置更改。如果由于配置更改（例如，设备旋转）而重新创建 Fragment 或 Activity ，则会立即接收最新的可用数据。 没有内存泄漏。无需手动处理订阅。当相关的生命周期被破坏时，观察者会自行清理。 LiveData VS ObservableFields与实现 Observable 的对象 （例如可观察字段）不同 ， LiveData 对象知道订阅数据更改的观察者的生命周期。无论 LiveData 和 ObservableFields， 他们都可以实现其观察数据变化，但是在其他方面，LiveData 有它特殊的优势： 手动生命周期处理。UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些，因为它在观察时意识到相关的生命周期状态变化。 Transformations 和 MediatorLiveData 的更多功能。使用 LiveData 将使您受益于转换的强大功能，并且还可以向 MediatorLiveData 添加多个源。因此，如果布局中有5个 EditText 视图，则无需从 Activity 或 Fragment 中观察全部 5个 视图。您只能观察一个 MediatorLiveData，这将为您节省一些代码和逻辑复杂性。 共享资源。创建扩展 LiveData 的自定义对象将允许您连接到系统服务一次，然后任何需要该资源的观察者只能观察该对象。 开始使用带数据绑定的 LiveData要将 LiveData 对象与绑定类一起使用，需要指定生命周期所有者以定义 LiveData 对象的范围。以下示例说明如何在实例化绑定类之后将活动设置为生命周期所有者： 1234// Inflate view and obtain an instance of the binding class.val binding: MainBinding = DataBindingUtil.setContentView(this, R.layout.main)// Specify the current activity as the lifecycle owner.binding.setLifecycleOwner(this) 所以现在我们可以在布局文件 main.xml 中使用 LiveData 对象，如下所示，commentText 的值将设置到 text 属性上： 12&lt;android.support.design.widget.TextInputEditText android:text="@&#123;viewModel.commentText&#125;" /&gt; 在某些情况下，在数据绑定中使用 LiveData 时，可能会出现警告“…是一个盒装字段但需要取消装箱以执行…”。这表示使用可空类型作为 LiveData 对象值。要禁止警告，建议使用原语（ ObservableInt 而不是 MutableLiveData ）或使用safeUnbox，如下所示： 1android:text="@&#123;safeUnbox(viewModel.commentText)&#125;" 实现双向绑定在预期从 UI 更新 LiveData 值的情况下，双向绑定变得非常方便。在代码中访问它时，我们希望收到更新的值。为了能够做到这一点，我们将在绑定表达式的花括号之前添加“=”： 12&lt;android.support.design.widget.TextInputEditText android:text="@=&#123;viewModel.commentText&#125;" /&gt; 现在，只要用户在屏幕上的视图中键入新文本，LiveData 对象就会更新，当访问其值时，我们将收到最新的更新。 创建自定义绑定适配器为了更进一步，让我们想一个不那么通用的案例。想象一下，我们希望通过使用 LiveData 对象的数据绑定在 ViewPager 中设置当前选项卡。为此，我们需要在 BindingAdapter 的帮助下为 ViewPager 创建自定义属性 currentTab ： 123456789101112companion object &#123; @BindingAdapter("currentTab") @JvmStatic fun setNewTab(pager: ViewPager, newTab: MutableLiveData&lt;Int&gt;) &#123; newTab.value?.let &#123; //don't forget to break possible infinite loops! if (pager.currentItem != itemLiveData.value) &#123; pager.setCurrentItem(newTab.value, true) &#125; &#125; &#125;&#125; 所以现在我们可以将新属性添加到布局文件中，并从 LiveData 对象值设置 ViewPager 的当前项： 12&lt;android.support.v4.view.ViewPager app:currentTab="@&#123;viewModel.pagerCurrentTab&#125;"/&gt; 当新值设置为 pagerCurrentTab 对象时，将执行 BindingAdapter 正文中的代码。 使用自定义属性的双向绑定现在，在更新我们创建的 LivaData 对象中的值时，ViewPager 会滚动到新位置。这很好，除了在我们的用例中，用户还与 UI 交互并更改ViewPager 的位置，但 LiveData 对象仍保留“旧”值。我们希望收到有关此属性更改的通知，以便基于它实现某些逻辑或只检查当前值。这可以通过实现双向绑定来实现。 我们将要对布局文件进行以下更改： 12&lt;android.support.v4.view.ViewPager app:currentTab="@=&#123;viewModel.pagerCurrentTab&#125;"/&gt; BindingAdapter我们已经有了，另外需要创建一个 InverseBindingAdapter。此时，数据绑定知道在数据更改时要做什么（它调用使用了 @BindingAdapter 注释的方法）以及在 view 属性更改时调用的内容（它调用使用了 InverseBindingListener 注释的方法）。因此，如果用户滑动 ViewPager 选项卡，LiveData 对象将使用新值进行更新。但是，为了知道属性何时或如何更改，我们引入了自定义事件。事件的命名默认为具有后缀“AttrChanged”的属性名称。在这个场景里就是 currentTabAttrChanged。 1234567891011121314companion object &#123; @BindingAdapter("currentTab") @JvmStatic fun setTab(pager: ViewPager, itemLiveData: MutableLiveData&lt;Int&gt;)&#123; itemLiveData.value?.let &#123; //don't forget to break possible infinite loops! if (pager.currentItem != itemLiveData.value) &#123; pager.setCurrentItem(itemLiveData.value, true) &#125; &#125; &#125; @InverseBindingAdapter(attribute = "currentTab", event = "currentTabAttrChanged") @JvmStatic fun getTab(pager: ViewPager) = pager.currentItem 一句警告使用双向数据绑定时，请注意不要引入无限循环。当用户更改属性时，将调用注释@InverseBindingAdapter 的方法。反过来，这将调用注释 @BindingAdapter 的方法，这将触发对注释 @InverseBindingAdapter 的方法的另一个调用，依此类推。 因此，通过比较注释 @BindingAdapter 的方法中的新旧值来打破可能的无限循环非常重要。 一些最后的想法Android 组件的生命周期很复杂，手动管理可能很麻烦，因为保持 UI 与数据源保持同步，因此引入 LiveData 是生命周期管理中的一大步。将数据绑定添加到项目中可以使代码更加简洁和反应，因为数据源中的更改可以自动传播到 UI，同时考虑了到配置和生命周期状态。但是，使用数据绑定库不应仅限于将数据模型的属性设置为文本字段。使用单向和双向绑定绑定到 LiveData 将允许您充分利用 Observer 模式和生命周期感知。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Databinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 MVVM]]></title>
    <url>%2F2019%2F04%2F12%2FJetpack-%E4%B9%8B-MVVM%2F</url>
    <content type="text"><![CDATA[前置储备：LiveData可以说 MVVM 的好处那是相当多了😁，至少我个人使用来说，是方便了不少❤。 什么是 MVVM 说起 MVVM ，那就要大概提一提 MVC ,MVP 。当然，本文的重点并非 MVC &amp; MVP。 先来说说 MVC 直接贴上维基百科的解释(https://zh.wikipedia.org/wiki/MVC) 即 模型（Model）-视图（View）-控制器（Controller）。MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC模式最早由Trygve Reenskaug在1978年提出[1]，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 专业人员可以通过自身的专长分组： 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 MVP 维基解释(https://zh.wikipedia.org/wiki/Model-view-presenter) Model-view-presenter，简称MVP，是计算机软件设计工程中一种对针对MVC模式，再审议后所延伸提出的一种软件设计模式。 Model-View-Presenter (MVP) 是用户界面设计模式的一种，被广泛用于便捷自动化单元测试和在呈现逻辑中改良分离关注点（separation of concerns）。 Model 定义用户界面所需要被显示的数据模型，一个模型包含着相关的业务逻辑。 View 视图为呈现用户界面的终端，用以表现来自 Model 的数据，和用户命令路由再经过 Presenter 对事件处理后的数据。 Presenter 包含着组件的事件处理，负责检索 Model 获取数据，和将获取的数据经过格式转换与 View 进行沟通。 MVP 设计模式通常会再加上 Controller 做为整体应用程序的后端程序工作。 MVVM 维基(https://zh.wikipedia.org/wiki/MVVM) MVVM 概述 MVVM（Model–view–viewmodel）是一种软件架构模式。 MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。 MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。MVVM以相同的方式抽象出视图的状态和行为，但PM以不依赖于特定用户界面平台的方式抽象出视图（创建了视图模型）。 MVVM和PM都来自MVC模式。 MVVM由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用派生品）的特性来简化用户界面的事件驱动程序设计。微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。 MVVM也被称为model-view-binder，特别是在不涉及.NET平台的实现中。ZK（Java写的一个Web应用框架）和KnockoutJS（一个JavaScript库）使用model-view-binder。 MVVM模式的组成部分 模型 模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 视图 就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 视图模型 视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。 绑定器 声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。 理论基础 MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。 MVVM模式试图获得MVC提供的功能性开发分离的两个优点，同时利用数据绑定的优势和通过绑定数据的框架尽可能接近纯应用程序模型。它使用绑定器、视图模型和任何业务层的数据检查功能来验证传入的数据。结果是模型和框架驱动尽可能多的操作，消除或最小化直接操纵视图的应用程序逻辑（如代码隐藏）。 MVVM 特点在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层： 本节参考自 https://juejin.im/post/58cf2d791b69e6006b851605 a 、View: 视图层，对应xml文件与Activity/Fragment； b 、Presenter: 逻辑控制层，同时持有View和Model对象； c 、Model: 实体层，负责获取实体数据。 MVP模式有其很大的优点： 1.解耦合，业务逻辑和视图分离； 2.项目代码结构（文件夹）清晰，一看就知道什么类干什么事情； 3.便于单元测试（其实还是第一点）； 4.协同工作（例如在设计师没出图之前可以先写一些业务逻辑代码或者其他人接手代码改起来比较容易）； 但是也有美中不足的部分，MVP模式的缺点如下： 1.Presente层与View层是通过接口进行交互的，接口粒度不好控制。粒度太小，就会存在大量接口的情况，使代码太过碎版化;粒度太大，解耦效果不好。因为View定义的方法并不一定全部要用到，可能只是后面要用到先定义出来（后面要不要删也未知），而且如果后面有些方法要删改，Presenter和Activity都要删改，比较麻烦； 2.V层与P层还是有一定的耦合度。一旦V层某个UI元素更改，那么对应的接口就必须得改，数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。如果这一层也能解耦就更好了。 3.复杂的业务同时也可能会导致P层太大，代码臃肿的问题依然不能解决，这已经不是接口粒度把控的问题了，一旦业务逻辑越来越多，View定义的方法越来越多，会造成Activity和Fragment实现的方法越来越多，依然臃肿。 MVVM 的优点View和Model进行了双向绑定，两者之间有一方发生变化则会反应在另一方 MVP和MVC的主要区别是，MVP的View不能直接访问Model，需要通过Presenter发送请求，View和Model 不能直接通信。 MVP和MVVM的主要区别是，MVP 的View更新需要通过Presenter，而MVVM不需要，因为View 和Model进行了双向绑定，数据的修改会直接反应在View上，而View的修改也会导致数据变更，此时ViewModel需要做的是业务逻辑处理，以及修改View和Model的状态 原文：https://blog.csdn.net/Ghost_tal/article/details/82052377 MVVM &amp; LiveData使用 LiveData 的好处 UI 和数据保持一致性 LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。 没有内存泄漏 观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。 不会因 UI 暂停而崩溃 如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。 不再需要手动管理生命周期 UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。 始终保持最新数据 如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。 配置更改自动处理 如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。 共享资源 您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。 MVVM 每一层的处理Model show me the code as flowing：12345678910111213141516class MainRepository : BaseRepository() &#123; val loadSuccess = MutableLiveData&lt;FirstCategoryResp&gt;() fun loadData() &#123; compositeDisposable.add(Flowable.just(Any()) .doOnNext &#123; showLoading() &#125; .subscribeOn(Schedulers.io()) .flatMap &#123; WebApiService.getFirstCategories(FirstCategoryReq()) &#125; .doOnNext &#123; loadSuccess.postValue(it) &#125; .doFinally &#123; dismissLoading() &#125; .subscribe(&#123; &#125;, &#123; throwable -&gt; LogUtils.e(throwable, "获取一级分类信息失败") &#125;) ) &#125;&#125; 如上所示： Repository 持有 WebApiService, 同时，持有需要发射的后台数据。比如进行网络请求，数据库操作等。 ViewModel1234567891011class MainViewModel : BaseViewModel&lt;MainRepository&gt;() &#123; override fun initRepo(): MainRepository &#123; return MainRepository() &#125; val loadSuccess: LiveData&lt;FirstCategoryResp&gt; = Transformations.map(repository.loadSuccess) &#123; it &#125; fun loadData() &#123; repository.loadData() &#125;&#125; ViewModel 持有需要发射的 LiveData 数据对象，这里比较特殊，通过 Transformations.map 直接转发来发射自 Repository 的数据 ，同时提供加载数据的方法给 View 调用。方法内部没有任何逻辑，直接转发调用 Repository 的方法进行数据加载。 View123override fun initLiveDataObserver() &#123; viewModel.loadSuccess.observe(this, androidx.lifecycle.Observer &#123; refreshUI(it) &#125;)&#125; 在 View 层，持有 ViewModel，并观察 ViewMode 的数据变化。当有新的数据发射出来时，直接调用更新 UI。 综上，可以看出，从 View -&gt; ViewModel -&gt; Repository,即代表了 V -&gt; VM -&gt; M 这样的单向引用。统一标准为上层直接依赖下层，上传简介观察下层的数据变化，并非下层调用上层的业务逻辑，每一层之间的数据转发都是通过观察者的模式来连接。 Repository 结合 RxJava 使用在上面的示例中，已经展示过在 Repository 里使用 RxJava 进行网络请求的流封装，并且在 BaseViewModel 的 onCleared 方法中，调用 CompositeDisable 的 clear 方法进行后台任务的取消和清除。 而且可以看到，在进行网络数据请求或者任何耗时操作的时候，不需要进行主动的线程切换，因为所有的数据发射，我们都是使用了 postValue 方法，在其内部已经帮我们进行了现场的切换。 LiveData &amp; RxJava 比较两者有很多相似的地方，但是侧重点有所不同。 LiveData 侧重于生命周期的管理。 RxJava 侧重于流式 API 的支持。 总结总体来说，MVVM 是非常值得一试的。就目前的使用情况来看，没发现什么严重的问题。推荐一试。当然，任何东西也都不可能是完美的，始终要抱着辩证的思维去看待一个事情，但是也要保持积极地心态去拥抱新技术的不断涌现，才不至于被潮流所抛弃。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 LiveData]]></title>
    <url>%2F2019%2F04%2F12%2FJetpack-%E4%B9%8B-LiveData%2F</url>
    <content type="text"><![CDATA[什么是 LiveData LiveData是一个可观察的数据持有者类。与常规 observable 不同，LiveData 是生命周期感知的，这意味着它遵从其他应用程序组件的生命周期，例如 Activity，Fragment 或 Service。此感知确保 LiveData 仅更新处于 Activity 生命周期状态应用程序组件的观察者。 使用 LiveData 的好处 既然有了 observable 系列的支持，那为什么还有 LiveData 存在的意义？正所谓存在的就是合理的，也当然就有它存在的理由，下面我们来看看 LiveData 相较于 Observable 有哪些优点： UI 和数据保持一致性 LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。 没有内存泄漏 观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。 不会因 UI 暂停而崩溃 如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。 不再需要手动管理生命周期 UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。 始终保持最新数据 如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。 配置更改自动处理 如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。 共享资源 您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。 如何使用 LiveDate 对象 包括以下步骤： 创建一个 LiveData 用于保存特定类型数据的实例。这通常在您的 ViewModel 内完成 。 创建一个 Observer 定义 onChanged() 方法的对象，该对象负责处理 LiveData 对象数据更改时发出的数据。通常Observer 在 UI 控制器中创建，例如 Activity 或 Fragment 。 使用 LiveData 的 observe 方法将 Observer 绑定到 LiveData 对象。通常在UI控制器中完成绑定，例如 Activity 或 Fragment 。 创建 LiveData 对象 在 ViewModel 中创建 LiveData 对象： 1234567class NameViewModel : ViewModel() &#123; // Create a LiveData with a String val currentName: MutableLiveData&lt;String&gt; by lazy &#123; MutableLiveData&lt;String&gt;() &#125;&#125; 观察 LiveData 对象 在 UI 中观察 LiveData: 1234567891011121314151617181920212223class NameActivity : AppCompatActivity() &#123; private lateinit var model: NameViewModel override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // Other code to setup the activity... // Get the ViewModel. model = ViewModelProviders.of(this).get(NameViewModel::class.java) // Create the observer which updates the UI. val nameObserver = Observer&lt;String&gt; &#123; newName -&gt; // Update the UI, in this case, a TextView. nameTextView.text = newName &#125; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.currentName.observe(this, nameObserver) &#125;&#125; 更新 LiveData 对象 如果是在非主线程中更新数据，使用 postValue 方法 1234button.setOnClickListener &#123; val anotherName = "John Doe" model.currentName.postValue(anotherName)&#125; 如果是在主线程中更新数据，使用 setValue 方法 1234button.setOnClickListener &#123; val anotherName = "John Doe" model.currentName.setValue(anotherName)&#125; LiveData 高级部分在 Room 中使用 LiviDataRoom 持久库支持可观察的查询操作，返回 LiveData 对象，可观察的查询写在 DAO 中并成为 DAO 的一部分。Room 将自动生成所有需要的中间代码，以达到数据库被更新时自动发出通知，所生成的中间代码运行在异步线程中，如果你的界面显示的数据源来自 Room，这个特性将显得非常有用。 扩展 LiviData123456789101112131415class StockLiveData(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123; private val stockManager = StockManager(symbol) private val listener = &#123; price: BigDecimal -&gt; value = price &#125; override fun onActive() &#123; stockManager.requestPriceUpdates(listener) &#125; override fun onInactive() &#123; stockManager.removeUpdates(listener) &#125;&#125; 如上所示，如果需要扩展一个 LiveData 对象，我们需要实现以下方法： onActive() 当 LiveData 对象的观察者处于活动状态时调用该方法。 onInactive() 当 LiveData 对象的所有观察者都处于非活动状态时调用该方法。 setValue(T) 此方法 LiveData 实例的值发生更新时调用，并通知所有活动的观察者。 可以像下面这样使用上面扩展的 LiveData 对象： 1234567override fun onActivityCreated(savedInstanceState: Bundle?) &#123; super.onActivityCreated(savedInstanceState) val myPriceListener: LiveData&lt;BigDecimal&gt; = ... myPriceListener.observe(this, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt; // Update the UI. &#125;)&#125; 转换 LiveData 有时候希望在将 LiveData 对象分发给观察者之前对其中存储的值进行更改 ，或者可能需要此 LiveData 根据另一个实例的值返回其他实例。在这种场景下，Lifecycle 中包提供的 Transformations 包含支持这些方案的辅助方法和类。 Transformations.map() 对存储在 LiveData 对象中的值应用一个转换函数，并将结果传播到下游。 1234val userLiveData: LiveData&lt;User&gt; = UserLiveData()val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;user -&gt; "$&#123;user.name&#125; $&#123;user.lastName&#125;"&#125; Transformations.switchMap() 类似于 map()，将一个函数应用于存储在 LiveData 对象中的值，并将结果解包并调度到下游。传递给 switchMap() 参数的这个函数，必须返回一个LiveData对象，如下例所示： 12345private fun getUser(id: String): LiveData&lt;User&gt; &#123; ...&#125;val userId: LiveData&lt;String&gt; = ...val user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125; 合并多个 LiveData 源 MediatorLiveData MediatorLiveData 是一个 LiveData 的子类，允许合并多个 LiveData 源。MediatorLiveData 只要其中任何一个原始 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。 例如，如果一个 LiveData 可以从本地数据库或网络更新的对象，则可以将以下源添加到该 MediatorLiveData 对象： 一个与存储在数据库中的数据关联的 LiveData 对象。 一个与从网络访问的数据关联的 LiveData 对象。 此时，UI 中只需要观察 MediatorLiveData 对象，就可以做到观察两个数据源的更新。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>LiveData</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding - 使用可观察的数据对象]]></title>
    <url>%2F2019%2F04%2F09%2FDataBinding%20-%20%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是可观察对象 注：本文参考并翻译自官网链接 可观察性是指对象具备通知外部其数据发生变化的能力。Databinding 支持对象、字段或集合的可观察。 当其中一个可观察数据对象绑定到UI并且数据对象的属性发生更改时，UI将自动更新。 可观察的类型 任何普通对象都可用于数据绑定，但修改对象不会自动导致UI更新。Databinding 可用于为数据对象提供在数据更改时通知其他对象（称为侦听器）的能力。有三种不同类型的可观察类： 对象，字段和 集合。 可观察字段 有时候你的类中如果有一些需要更新的字段，并且只包含以下这些属性，那么可以直接使用系统的实现，而不需要重新实现。这时候，你字需要使用可观察对象作为其字段，或者直接使用可观察字段。 ObservableBoolean ObservableByte ObservableChar ObservableShort ObservableInt ObservableLong ObservableFloat ObservableDouble ObservableParcelable 可观察字段是具有单个字段的自包含可观察对象。原始版本在访问操作期间避免装箱和拆箱。要使用此机制，请public final在 Java 编程语言中创建属性或在 Kotlin 中创建只读属性，如以下示例所示： 12345class User &#123; val firstName = ObservableField&lt;String&gt;() val lastName = ObservableField&lt;String&gt;() val age = ObservableInt()&#125; 要访问字段值，请使用 set() and get() 方法，如下所示 12user.firstName = "Google"val age = user.age Note: Android Studio 3.1 and higher allow you to replace observable fields with LiveData objects, which provide additional benefits to your app. For more information, see Use LiveData to notify the UI about data changes. 可观察集合 可以使用可观察的集合，来存放一些列的数据。通过示例来使用 ObservableArrayMap 类： 12345ObservableArrayMap&lt;String, Any&gt;().apply &#123; put("firstName", "Google") put("lastName", "Inc.") put("age", 17)&#125; 在布局文件中，可以直接使用 key 去拿到这个存储的值： 12345678910111213&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&lt;String, Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text="@&#123;user.lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text="@&#123;String.valueOf(1 + (Integer)user.age)&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 如果 Key 是无序的 int 时，可以使用 ObservableArrayList 类。 12345ObservableArrayList&lt;Any&gt;().apply &#123; add("Google")add("Inc.")add(17)&#125; 在 layout 文件中，可以直接通过索引的方式获取： 1234567891011121314&lt;data&gt; &lt;import type="android.databinding.ObservableList"/&gt; &lt;import type="com.example.my.app.Fields"/&gt; &lt;variable name="user" type="ObservableList&lt;Object&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:text='@&#123;user[Fields.LAST_NAME]&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;&lt;TextView android:text='@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;' android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; 可观察的对象 实现 Observable 接口的类，允许注册对象属性更改的侦听器。该 Observable 接口具有添加和删除侦听器的机制，但您必须决定何时发送通知。为了使开发更容易，Databinding 库提供了 BaseObservable 实现侦听器注册机制的类。实现了 BaseObservable 的类，负责在属性更改时发出通知。这是通过 Bindable 为 getter 添加注解，并在 setter 中调用 notifyPropertyChanged() 方法来完成的，如以下示例所示： 12345678910111213141516class User : BaseObservable() &#123; @get:Bindable var firstName: String = "" set(value) &#123; field = value notifyPropertyChanged(BR.firstName) &#125; @get:Bindable var lastName: String = "" set(value) &#123; field = value notifyPropertyChanged(BR.lastName) &#125;&#125; Databinding 在模块包中生成BR命名的类，该类包含用于 Databinding 的资源的ID。 Bindable 注解会在编译期生成一个 BR类 中的的条目。如果无法更改数据类的基类，则 Observable可以使用PropertyChangeRegistry 对象来实现接口， 以便有效地注册和通知侦听器。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Databinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 Databinding]]></title>
    <url>%2F2019%2F04%2F04%2FJetpack-%E4%B9%8B-Databinding%2F</url>
    <content type="text"><![CDATA[关于DataBinding解释 DataBinding 是一个支持库，允许使用声明格式(而不是编程方式)将布局中的UI组件绑定到应用程序中的数据源。 问题描述 布局通常在 Activity 中定义。例如，下面的代码调用findViewById()查找TextView并将其绑定到 viewModel 变量的 userName 属性: 123findViewById&lt;TextView&gt;(R.id.sample_text).apply &#123; text = viewModel.userName&#125; 以下示例说明如何使用 DataBinding 直接在布局文件中将 text 赋值为 viewmodel.userName。这消除了上面显示调用任何Java代码的需要。注意@{}在赋值表达式中使用语法： 12&lt;TextView android:text="@&#123;viewmodel.userName&#125;" /&gt; 优点 在布局文件中进行数据绑定可以删除在 Activity 中许多的UI框架调用，使其更简单，更易于维护。这还可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常。 缺点 当然任何东西都不是完美无缺的，DataBinding 在使用的时候，因为 APT 会帮助我们生产很多中间模板代码，所在开发调试过程中、以及线上问题跟踪时，有可能定位不到准确的错误点。当然，你要是熟练使用 DataBinding 的话，这些缺点在优点面前就显得微不足道了。所以在这里还是要墙裂推荐这个库的使用。能大量减少繁琐的模板代码。 环境配置 仅支持 Android 4.0（API级别14）或更高版本的设备。 推荐使用最新的 Gradle 插件版本 Android Plugin。因为 DataBinding 支持 1.5.0 或更高版本。 设置构建环境 在 moudule 级别的 build 脚本中，adnroid 节点下配置如下： 123456android &#123; ... dataBinding &#123; enabled = true &#125;&#125; Android Studio 支持数据绑定 Android Studio支持许多用于数据绑定代码的编辑功能。例如，它支持数据绑定表达式的以下功能： 语法突出显示 标记表达式语言语法错误 XML代码补全 如果使用了 Navigation，那么在视图设计中可以直接预览默认值效果： 123&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName, default=my_default&#125;"/&gt; 如果只需要在项目的设计阶段显示默认值，则可以使用tools属性而不是默认表达式值。 在布局中使用编写布局文件并绑定表达式123456789&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="viewmodel" type="com.myapp.data.ViewModel" /&gt; &lt;/data&gt; &lt;ConstraintLayout... /&gt; &lt;!-- UI layout's root element --&gt;&lt;/layout&gt; 如上所示，不同于以往的常规布局方式，在最外层嵌套了一个 layout ,然后下面有一个 data 节点，再下面一个节点才是我们以往的布局根节点。 其中，data 节点下可以做很多事情，包括： 数据声明 使用 import 导包 在根布局节点下面，可以直接使用 data 中声明的变量、使用表达式等很多强大的功能。 使用可观察数据对象 DataBinding 提供了一些列的类和方法，可以轻松地观察数据变更以进行 UI 更改。不再担心在基础数据源发生更改时需要手动刷新UI。您可以观察变量或其属性。该库允许您使对象，字段或集合可观察。 生成绑定数据类 DataBinding 生成用于访问布局中变量和视图的绑定类。 生成的绑定类将布局变量与布局中的视图链接起来，绑定类的名称和包可以自定义。 所有生成的绑定类都继承自 ViewDataBinding类。 默认情况下，生成绑定数据类的名称基于布局文件的名称，将其转换为Pascal大小写并向其添加Binding后缀。 例如 activity_main.xml 生成的目标类名是：ActivityMainBinding]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Databinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 框架研究计划]]></title>
    <url>%2F2019%2F04%2F02%2FJetpack-%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[最近一直在做框架方面得预研工作，工作中使用的 MVP 框架到目前为止已经一年多，确实发现 MVP 框架在某些情况下看来，代码冗余量还是比较严重的。 目前公司的项目基本都是一两个人维护并进行迭代，所以 MVP 的分层架构在开发阶段并没有突出多少优势来。 加上 MVP 的接口太多太冗余，这个问题确实是非常突出了。一个项目里面，基本上打开都是接口类。有的甚至都没任何实现的空页面，但是为了遵循 MVP 的设计原则，不得不产生很多类似的模板代码类。 另外一点也是极为重要的，就是 MVP 继承体系，如果抽取多个 Base 类的话，一大堆的泛型传递也是非常繁琐的事情了。 在 2018 年 Google 全新推出的 Jetpack 框架集合，其中就包含了对 MVVM 架构的支持。如下图所示： 基于以上存在的问题和现状，是时候好好研究一下 google 强大的开发框架集合了。 后续会陆续更新一系列的文章，来记录学习的路径。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack 之 Navigation]]></title>
    <url>%2F2019%2F03%2F31%2FJetpack-%E4%B9%8B-Navigation%2F</url>
    <content type="text"><![CDATA[Navigation 是 Jetpack 组件中用于页面路由导航。在 Fragment 应用场景下，特别适合把各种页面逻辑调转和传参等繁琐无畏的模板代码交给 Navigation 来处理，同时能大幅度减少代码的数量和出错的问题。 类比 iOS 的 storyboard 有着很多相似的地方，下面就让我来看看具体如何来实现 Navigation 在项目中的应用。 配置环境module 中的 build 脚本：def nav_version = &quot;2.0.0&quot; implementation &quot;androidx.navigation:navigation-fragment:$nav_version&quot; // For Kotlin use navigation-fragment-ktx implementation &quot;androidx.navigation:navigation-ui:$nav_version&quot; // For Kotlin use navigation-ui-ktx root 的 build 脚本：buildscript { ... dependencies { ... classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0&quot; } } 概念解释导航容器（navigation container） 系统已经为我们实现了一个导航容器，androidx.navigation.fragment.NavHostFragment。 使用方式:将以下代码加入到 Activity 中的 layout 文件内 1234567&lt;fragment android:id=&quot;@+id/nav_host_fragment&quot; android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:defaultNavHost=&quot;true&quot; app:navGraph=&quot;@navigation/nav_graph&quot;/&gt; 导航控制器（navigation controller） 通过导航容器，即可拿到导航控制器对象。获取方式见 3.4。 目标页面（destination）App 中所有的 Fragment 都可作为目标页面。 跳转动作（action）App 中任意两个目标页面之间的逻辑跳转，都称作一个跳转动作。 导航视图（navigation graph）导航控制器需要指定一个导航视图，导航视图包括了所有的目标页面以及跳转动作。 FAQ如何创建导航视图（navigation graph）？res -&gt; 右键 -&gt; new -&gt; Android Resources File，在 Resource Type 中选择 Navigation。 如何创建一个目标页面（destination）？res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 点击导航视图面板中的加号（New Destination) -&gt;（Create new destination) -&gt; 输入目标页面名称 注：取消勾选 「Include fragment factory methods」 和 「Include interface callbacks」这两个选项,一般用不到。 如何创建一个跳转动作（action）？res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 选中一个目标页面 -&gt; 目标页面右侧会有一个圆点 -&gt; 拖动这个圆点链接到另一个目标页面 这样一个跳转动作就完成了。 如何获取导航控制器（navigation controller）？有三种方式可以获取到导航控制器 通过 View 获取 KotlinView.findNavController() JavaNavigation.findNavController(View) 通过 Fragment 获取 KotlinFragment.findNavController() JavaNavHostFragment.findNavController(Fragment) 通过 Activity 获取 KotlinActivity.findNavController(viewId: Int) JavaNavigation.findNavController(Activity, @IdRes int viewId) 如何执行跳转？ 首先，所有的跳转都是通过导航控制器（navigation controller）来完成的，所以，我们先要拿到 navigation controller 对象，见 3.4。 拿到 navigation controller 对象之后，我们就可以执行它的 navigate 方法，传入跳转动作的 int 类型 ID，进行相应的跳转。 示例：findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment ) 传递参数：只需要添加参数即可： val args = Bundle() args.putString(ARG,&quot;TEST DATA....&quot;) findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment ,args) 如何控制页面的栈？ 正常情况下，每次导航一个新的目标页面，都把目标页面置为栈顶。 如果某一个跳转（action）执行之后，希望把它的目标页面（destination）置顶并清除原来的栈，就需要在它对应的 action 上加入下面两个属性： app:popUpToInclusive=&quot;true&quot; app:popUpTo=&quot;@+id/page1Fragment&quot; 控制栈的回退 调用 findNavController().navigateUp() 执行一次栈顶出栈操作。 跳转动画可以自定义么？可以的。在 action 节点下添加以下属性指定页面跳转动画：、 app:enterAnim=&quot;@anim/nav_default_enter_anim&quot; app:exitAnim=&quot;@anim/nav_default_exit_anim&quot; app:popEnterAnim=&quot;@anim/nav_default_pop_enter_anim&quot; app:popExitAnim=&quot;@anim/nav_default_pop_exit_anim&quot; 如何设置启动页？每一个导航视图，都必须有且只有一个启动页（start destination） res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 选中一个目标页面 -&gt; 点击导航编辑器面板上的 「小房子」图标即可设置当前页面为启动页。 如何传递参数可以参考我的Github示例代码https://github.com/duanyitao/NavigationDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Jetpack</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
</search>
