<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colin&#39;s Blog</title>
  
  <subtitle>时间是没有声音的锉刀。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://duanyitao.com/"/>
  <updated>2020-03-12T07:48:13.302Z</updated>
  <id>http://duanyitao.com/</id>
  
  <author>
    <name>段燚涛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart 语法(2)</title>
    <link href="http://duanyitao.com/2020/03/12/Dart-%E8%AF%AD%E6%B3%95-2/"/>
    <id>http://duanyitao.com/2020/03/12/Dart-语法-2/</id>
    <published>2020-03-12T06:24:16.000Z</published>
    <updated>2020-03-12T07:48:13.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart-语法-2"><a href="#Dart-语法-2" class="headerlink" title="Dart 语法(2)"></a>Dart 语法(2)</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Dart 是一门真正面向对象的语言， 甚至其中的函数也是对象，并且有它的类型 Function 。 这也意味着函数可以被赋值给变量或者作为参数传递给其他函数。 也可以把 Dart 类的实例当做方法来调用。</p><p>已下是函数实现的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然在 Effective Dart 中推荐 公共API中声明类型, 但是省略了类型声明，函数依旧是可以正常使用的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数中只有一句表达式，可以使用简写语法：</p><p><code>bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;</code></p><p>=&gt; expr 语法是 { return expr; } 的简写。 =&gt; 符号 有时也被称为 箭头 语法。</p><blockquote><p>提示： 在箭头 (=&gt;) 和分号 (;) 之间只能使用一个 表达式 ，不能是 语句 。 例如：不能使用 if 语句 ，但是可以是用 条件表达式.</p></blockquote><p>函数有两种参数类型: required 和 optional。 required 类型参数在参数最前面， 随后是 optional 类型参数。 命名的可选参数也可以标记为 “@ required” 。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数可以是命名参数或者位置参数，但一个参数只能选择其中一种方式修饰。</p><h4 id="命名可选参数"><a href="#命名可选参数" class="headerlink" title="命名可选参数"></a>命名可选参数</h4><p>调用函数时，可以使用指定命名参数 paramName: value。 例如：</p><p><code>enableFlags(bold: true, hidden: false);</code></p><p>定义函数时，使用 {param1, param2, …} 来指定命名参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Sets the [bold] and [hidden] flags ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>Flutter 创建实例的表达式可能很复杂， 因此窗口小部件构造函数仅使用命名参数。 这样创建实例的表达式更易于阅读。</p><p>使用 @required 注释表示参数是 required 性质的命名参数， 该方式可以在任何 Dart 代码中使用（不仅仅是Flutter）。</p><p><code>const Scrollbar({Key key, @required Widget child})</code></p><p>此时 Scrollbar 是一个构造函数， 当 child 参数缺少时，分析器会提示错误。</p><h4 id="位置可选参数"><a href="#位置可选参数" class="headerlink" title="位置可选参数"></a>位置可选参数</h4><p>将参数放到 [] 中来标记参数是可选的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是不使用可选参数调用上面方法 的示例：</p><p><code>assert(say(&#39;Bob&#39;, &#39;Howdy&#39;) == &#39;Bob says Howdy&#39;);</code></p><p>下面是使用可选参数调用上面方法的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>) ==</span><br><span class="line">    <span class="string">'Bob says Howdy with a smoke signal'</span>);</span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。</p><p>下面是设置可选参数默认值示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 设置 [bold] 和 [hidden] 标志 ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold 值为 true; hidden 值为 false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不推荐： 旧版本代码中可能使用的是冒号 (:) 而不是 = 来设置参数默认值。 原因是起初命名参数只支持 : 。 这种支持可能会被弃用。 建议 使用 = 指定默认值。</p></blockquote><p>下面示例演示了如何为位置参数设置默认值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">'carrier pigeon'</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>) ==</span><br><span class="line">    <span class="string">'Bob says Howdy with a carrier pigeon'</span>);</span><br></pre></td></tr></table></figure><p>list 或 map 可以作为默认值传递。 下面的示例定义了一个方法 doStuff()， 并分别指定参数 list 和 gifts 的默认值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'paper'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'cotton'</span>,</span><br><span class="line">      <span class="string">'third'</span>: <span class="string">'leather'</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list:  <span class="subst">$list</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'gifts: <span class="subst">$gifts</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main() 函数"></a>main() 函数</h3><p>任何应用都必须有一个顶级 main() 函数，作为应用服务的入口。 main() 函数返回值为空，参数为一个可选的 List<string> 。</string></p><p>下面是 web 应用的 main() 函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">'#sample_text_id'</span>)</span><br><span class="line">    ..text = <span class="string">'Click me!'</span></span><br><span class="line">    ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：</p><p>以上代码中的 .. 语法为 级联调用 （cascade）。 使用级联调用， 可以简化在一个对象上执行的多个操作。</p><p>下面是一个命令行应用的 main() 方法，并且使用了输入参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样运行应用： dart args.dart 1 test</span></span><br><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(arguments.length == <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">int</span>.parse(arguments[<span class="number">0</span>]) == <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">assert</span>(arguments[<span class="number">1</span>] == <span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 args library 可以定义和解析命令行参数。</p><p>函数是一等对象<br>一个函数可以作为另一个函数的参数。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 printElement 函数作为参数传递。</span></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure><p>同样可以将一个函数赋值给一个变量，例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">'!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!'</span>;</span><br><span class="line"><span class="keyword">assert</span>(loudify(<span class="string">'hello'</span>) == <span class="string">'!!! HELLO !!!'</span>);</span><br></pre></td></tr></table></figure><p>示例中使用了匿名函数。 下一章节会有更多介绍。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>多数函数是有名字的， 比如 main() 和 printElement()。 也可以创建没有名字的函数，这种函数被称为 匿名函数， 有时候也被称为 lambda 或者 closure 。 匿名函数可以赋值到一个变量中， 举个例子，在一个集合中可以添加或者删除一个匿名函数。</p><p>匿名函数和命名函数看起来类似— 在括号之间可以定义一些参数或可选参数，参数使用逗号分割。</p><p>后面大括号中的代码为函数体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[<span class="built_in">Type</span>] param1[, …]]) &#123;</span><br><span class="line">  codeBlock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面例子中定义了一个包含一个无类型参数 item 的匿名函数。 list 中的每个元素都会调用这个函数，打印元素位置和值的字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'apples'</span>, <span class="string">'bananas'</span>, <span class="string">'oranges'</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(</span><br><span class="line">    (item) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>));</span><br></pre></td></tr></table></figure><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>Dart 是一门词法作用域的编程语言，就意味着变量的作用域是固定的， 简单说变量的作用域在编写代码的时候就已经确定了。 花括号内的是变量可见的作用域。</p><p>下面示例关于多个嵌套函数的变量作用域：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 nestedFunction() 可以访问所有的变量， 一直到顶级作用域变量。</p><h3 id="词法闭包"><a href="#词法闭包" class="headerlink" title="词法闭包"></a>词法闭包</h3><p>闭包 即一个函数对象，即使函数对象的调用在它原始作用域之外， 依然能够访问在它词法作用域内的变量。</p><p>函数可以封闭定义到它作用域内的变量。 接下来的示例中， makeAdder() 捕获了变量 addBy。 无论在什么时候执行返回函数，函数都会使用捕获的 addBy 变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回一个函数，返回的函数参数与 [addBy] 相加。</span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个加 2 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个加 4 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试函数是否相等"><a href="#测试函数是否相等" class="headerlink" title="测试函数是否相等"></a>测试函数是否相等</h3><p>下面是顶级函数，静态方法和示例方法相等性的测试示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;&#125; <span class="comment">// 顶级函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125; <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">void</span> baz() &#123;&#125; <span class="comment">// 示例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较顶级函数。</span></span><br><span class="line">  x = foo;</span><br><span class="line">  <span class="keyword">assert</span>(foo == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较静态方法。</span></span><br><span class="line">  x = A.bar;</span><br><span class="line">  <span class="keyword">assert</span>(A.bar == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较实例方法。</span></span><br><span class="line">  <span class="keyword">var</span> v = A(); <span class="comment">// A的1号实例</span></span><br><span class="line">  <span class="keyword">var</span> w = A(); <span class="comment">// A的2号实例</span></span><br><span class="line">  <span class="keyword">var</span> y = w;</span><br><span class="line">  x = w.baz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个闭包引用的同一实例（2号）,</span></span><br><span class="line">  <span class="comment">// 所以它们相等。</span></span><br><span class="line">  <span class="keyword">assert</span>(y.baz == x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个闭包引用的非同一个实例，</span></span><br><span class="line">  <span class="comment">// 所以它们不相等。</span></span><br><span class="line">  <span class="keyword">assert</span>(v.baz != w.baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>所有函数都会返回一个值。 如果没有明确指定返回值， 函数体会被隐式的添加 return null; 语句。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(foo() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h2><p>你可以通过下面任意一种方式来控制 Dart 程序流程：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> and <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> loops</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> and <span class="keyword">do</span>-<span class="keyword">while</span> loops</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span> and <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> and <span class="keyword">case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span></span><br></pre></td></tr></table></figure><p>使用 try-catch 和 throw 也可以改变程序流程， 详见 Exceptions。</p><h3 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h3><p>Dart 支持 if - else 语句，其中 else 是可选的， 比如下面的例子， 另参考 conditional expressions.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRaining()) &#123;</span><br><span class="line">  you.bringRainCoat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSnowing()) &#123;</span><br><span class="line">  you.wearJacket();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  car.putTopDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 JavaScript 不同， Dart 的判断条件必须是布尔值，不能是其他类型。 </p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>进行迭代操作，可以使用标准 for 语句。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="built_in">StringBuffer</span>(<span class="string">'Dart is fun'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  message.write(<span class="string">'!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包在 Dart 的 for 循环中会捕获循环的 index 索引值， 来避免 JavaScript 中常见的陷阱。 请思考示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure><p>和期望一样，输出的是 0 和 1。 但是示例中的代码在 JavaScript 中会连续输出两个 2 。</p><p>如果要迭代一个实现了 Iterable 接口的对象， 可以使用 forEach() 方法， 如果不需要使用当前计数值， 使用 forEach() 是非常棒的选择；</p><p><code>candidates.forEach((candidate) =&gt; candidate.interview());</code></p><p>实现了 Iterable 的类（比如， List 和 Set）同样也支持使用 for-in 进行迭代操作 iteration ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x); <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> 和 <span class="keyword">do</span>-<span class="keyword">while</span></span><br><span class="line"><span class="keyword">while</span> 循环在执行前判断执行条件：</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>-<span class="keyword">while</span> 循环在执行后判断执行条件：</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  printLine();</span><br><span class="line">&#125; <span class="keyword">while</span> (!atEndOfPage());</span><br></pre></td></tr></table></figure><h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p>使用 break 停止程序循环：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shutDownRequested()) <span class="keyword">break</span>;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 continue 跳转到下一次迭代：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> candidate = candidates[i];</span><br><span class="line">  <span class="keyword">if</span> (candidate.yearsExperience &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象实现了 Iterable 接口 （例如，list 或者 set）。 那么上面示例完全可以用另一种方式来实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">candidates</span><br><span class="line">    .where((c) =&gt; c.yearsExperience &gt;= <span class="number">5</span>)</span><br><span class="line">    .forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure><h3 id="switch-和-case"><a href="#switch-和-case" class="headerlink" title="switch 和 case"></a>switch 和 case</h3><p>在 Dart 中 switch 语句使用 == 比较整数，字符串，或者编译时常量。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 == 重写。 枚举类型 可以用于 switch 语句。</p><blockquote><p>提示： 在 Dart 中 Switch 语句仅适用于有限的情况下， 例如在 interpreter 或 scanner 中。</p></blockquote><p>在 case 语句中，每个非空的 case 语句结尾需要跟一个 break 语句。 除 break 以外，还有可以使用 continue, throw，者 return。</p><p>当没有 case 语句匹配时，执行 default 代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'OPEN'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'PENDING'</span>:</span><br><span class="line">    executePending();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'APPROVED'</span>:</span><br><span class="line">    executeApproved();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'DENIED'</span>:</span><br><span class="line">    executeDenied();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'OPEN'</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    executeUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的 case 程序示例中缺省了 break 语句，导致错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'OPEN'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'OPEN'</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="comment">// ERROR: 丢失 break</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是， Dart 支持空 case 语句， 允许程序以 fall-through 的形式执行。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'CLOSED'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>: <span class="comment">// Empty case falls through.</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'NOW_CLOSED'</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非空 case 中实现 fall-through 形式， 可以使用 continue 语句结合 lable 的方式实现:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'CLOSED'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line">  <span class="comment">// Continues executing at the nowClosed label.</span></span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'NOW_CLOSED'</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case 语句可以拥有局部变量， 这些局部变量只能在这个语句的作用域中可见。</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>如果 assert 语句中的布尔条件为 false ， 那么正常的程序执行流程会被中断。 在本章中包含部分 assert 的使用， 下面是一些示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确认变量值不为空。</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认变量值小于100。</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认 URL 是否是 https 类型。</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">'https'</span>));</span><br></pre></td></tr></table></figure><blockquote><p>提示： assert 语句只在开发环境中有效， 在生产环境是无效的； Flutter 中的 assert 只在 debug 模式 中有效。 开发用的工具，例如 dartdevc 默认是开启 assert 功能。 其他的一些工具， 例如 dart 和 dart2js, 支持通过命令行开启 assert ： –enable-asserts。</p></blockquote><p>assert 的第二个参数可以为其添加一个字符串消息。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">'https'</span>),</span><br><span class="line">    <span class="string">'URL (<span class="subst">$urlString</span>) should start with "https".'</span>);</span><br></pre></td></tr></table></figure><p>assert 的第一个参数可以是解析为布尔值的任何表达式。 如果表达式结果为 true ， 则断言成功，并继续执行。 如果表达式结果为 false ， 则断言失败，并抛出异常 (AssertionError) 。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>Dart 代码可以抛出和捕获异常。 异常表示一些未知的错误情况。 如果异常没有被捕获， 则异常会抛出， 导致抛出异常的代码终止执行。</p><p>和 Java 有所不同， Dart 中的所有异常是非检查异常。 方法不会声明它们抛出的异常， 也不要求捕获任何异常。</p><p>Dart 提供了 Exception 和 Error 类型， 以及一些子类型。 当然也可以定义自己的异常类型。 但是，此外 Dart 程序可以抛出任何非 null 对象， 不仅限 Exception 和 Error 对象。</p><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>下面是关于抛出或者 引发 异常的示例：</p><p><code>throw FormatException(&#39;Expected at least 1 section&#39;);</code></p><p>也可以抛出任意的对象：</p><p><code>throw &#39;Out of llamas!&#39;;</code></p><blockquote><p>提示： 高质量的生产环境代码通常会实现 Error 或 Exception 类型的异常抛出。</p></blockquote><p>因为抛出异常是一个表达式， 所以可以在 =&gt; 语句中使用，也可以在其他使用表达式的地方抛出异常：</p><p><code>void distanceTo(Point other) =&gt; throw UnimplementedError();</code></p><h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>捕获异常可以避免异常继续传递（除非重新抛出（ rethrow ）异常）。 可以通过捕获异常的机会来处理该异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过指定多个 catch 语句，可以处理可能抛出多种类型异常的代码。 与抛出异常类型匹配的第一个 catch 语句处理异常。 如果 catch 语句未指定类型， 则该语句可以处理任何类型的抛出对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// 一个特殊的异常</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 其他任何异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 没有指定的类型，处理所有异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Something really unknown: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，捕获语句中可以同时使用 on 和 catch ，也可以单独分开使用。 使用 on 来指定异常类型， 使用 catch 来 捕获异常对象。</p><p>catch() 函数可以指定1到2个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息 ( 一个 StackTrace 对象 )。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n <span class="subst">$e</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Stack trace:\n <span class="subst">$s</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅需要部分处理异常， 那么可以使用关键字 rethrow 将异常重新抛出。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> foo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">print</span>(foo++); <span class="comment">// Runtime error</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>不管是否抛出异常， finally 中的代码都会被执行。 如果 catch 没有匹配到异常， 异常会在 finally 执行完成后，再次被抛出：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Always clean up, even if an exception is thrown.</span></span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何匹配的 catch 执行完成后，再执行 finally ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Error: <span class="subst">$e</span>'</span>); <span class="comment">// Handle the exception first.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls(); <span class="comment">// Then clean up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Dart 是一种基于类和 mixin 继承机制的面向对象的语言。 每个对象都是一个类的实例，所有的类都继承于 Object. 。 基于 <em>Mixin 继承</em> 意味着每个类（除 Object 外） 都只有一个超类， 一个类中的代码可以在其他多个继承类中重复使用。</p><h3 id="使用类的成员变量"><a href="#使用类的成员变量" class="headerlink" title="使用类的成员变量"></a>使用类的成员变量</h3><p>对象的由函数和数据（即方法和实例变量）组成。 方法的调用要通过对象来完成： 调用的方法可以访问其对象的其他函数和数据。</p><p>使用 (.) 来引用实例对象的变量和方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为实例的变量 y 设置值。</span></span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取变量 y 的值。</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 p 的 distanceTo() 方法。</span></span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(Point(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>使用 ?. 来代替 . ， 可以避免因为左边对象可能为 null ， 导致的异常：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 p 为 non-null，设置它变量 y 的值为 4。</span></span><br><span class="line">p?.y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>通过 构造函数 创建对象。 构造函数的名字可以是 ClassName 或者 ClassName.identifier。例如， 以下代码使用 Point 和 Point.fromJson() 构造函数创建 Point 对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p>以下代码具有相同的效果， 但是构造函数前面的的 new 关键字是可选的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>版本提示： 在 Dart 2 中 new 关键字变成了可选的。</p></blockquote><p>一些类提供了常量构造函数。 使用常量构造函数，在构造函数名之前加 const 关键字，来创建编译时常量时：</p><p><code>var p = const ImmutablePoint(2, 2);</code></p><p>构造两个相同的编译时常量会产生一个唯一的， 标准的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(identical(a, b)); <span class="comment">// 它们是同一个实例。</span></span><br></pre></td></tr></table></figure><p>在 常量上下文 中， 构造函数或者字面量前的 const 可以省略。 例如，下面代码创建了一个 const 类型的 map 对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里有很多的 const 关键字。</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'point'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">'line'</span>: <span class="keyword">const</span> [<span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), <span class="keyword">const</span> ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>保留第一个 const 关键字，其余的全部省略：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅有一个 const ，由该 const 建立常量上下文。</span></span><br><span class="line"><span class="keyword">const</span> pointAndLine = &#123;</span><br><span class="line">  <span class="string">'point'</span>: [ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>)],</span><br><span class="line">  <span class="string">'line'</span>: [ImmutablePoint(<span class="number">1</span>, <span class="number">10</span>), ImmutablePoint(<span class="number">-2</span>, <span class="number">11</span>)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果常量构造函数在常量上下文之外， 且省略了 const 关键字， 此时创建的对象是非常量对象：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">const</span> ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 创建一个常量对象</span></span><br><span class="line"><span class="keyword">var</span> b = ImmutablePoint(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 创建一个非常量对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(!identical(a, b)); <span class="comment">// 两者不是同一个实例!</span></span><br></pre></td></tr></table></figure><blockquote><p>版本提示： 在 Dart 2 中，一个常量上下文中的 const 关键字可以被省略。</p></blockquote><h3 id="获取对象的类型"><a href="#获取对象的类型" class="headerlink" title="获取对象的类型"></a>获取对象的类型</h3><p>使用对象的 runtimeType 属性， 可以在运行时获取对象的类型， runtimeType 属性回返回一个 Type 对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'The type of a is <span class="subst">$&#123;a.runtimeType&#125;</span>'</span>);</span><br></pre></td></tr></table></figure><p>到目前为止，我们已经解了如何_使用<em>类。 本节的其余部分将介绍如何</em>实现_一个类。</p><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>下面是声明实例变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// 声明示例变量 x，初始值为 null 。</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// 声明示例变量 y，初始值为 null 。</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// 声明示例变量 z，初始值为 0 。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未初始化实例变量的默认人值为 “null” 。</p><p>所有实例变量都生成隐式 getter 方法。 非 final 的实例变量同样会生成隐式 setter 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point();</span><br><span class="line">  point.x = <span class="number">4</span>; <span class="comment">// Use the setter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// Use the getter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// Values default to null.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在声明时进行了示例变量的初始化， 那么初始化值会在示例创建时赋值给变量， 该赋值过程在构造函数及其初始化列表执行之前。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>通过创建一个与其类同名的函数来声明构造函数 （另外，还可以附加一个额外的可选标识符，如 命名构造函数 中所述）。 下面通过最常见的构造函数形式， 即生成构造函数， 创建一个类的实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式来实现下面代码，敬请关注。</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 this 关键字引用当前实例。</p><blockquote><p>提示： 近当存在命名冲突时，使用 this 关键字。 否则，按照 Dart 风格应该省略 this 。</p></blockquote><p>通常模式下，会将构造函数传入的参数的值赋值给对应的实例变量， Dart 自身的语法糖精简了这些代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构造函数体执行前，</span></span><br><span class="line">  <span class="comment">// 语法糖已经设置了变量 x 和 y。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>在没有声明构造函数的情况下， Dart 会提供一个默认的构造函数。 默认构造函数没有参数并会调用父类的无参构造函数。</p><ul><li>构造函数不被继承<br>子类不会继承父类的构造函数。 子类不声明构造函数，那么它就只有默认构造函数 (匿名，没有参数) 。</li></ul><h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>使用命名构造函数可为一个类实现多个构造函数， 也可以使用命名构造函数来更清晰的表明函数意图：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切记，构造函数不能够被继承， 这意味着父类的命名构造函数不会被子类继承。 如果希望使用父类中定义的命名构造函数创建子类， 就必须在子类中实现该构造函数。</p><h4 id="调用父类非默认构造函数"><a href="#调用父类非默认构造函数" class="headerlink" title="调用父类非默认构造函数"></a>调用父类非默认构造函数</h4><p>默认情况下，子类的构造函数会自动调用父类的默认构造函数（匿名，无参数）。 父类的构造函数在子类构造函数体开始执行的位置被调用。 如果提供了一个 initializer list （初始化参数列表）， 则初始化参数列表在父类构造函数执行之前执行。 总之，执行顺序如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initializer list （初始化参数列表）</span><br><span class="line">superclass’s no-arg constructor （父类的无名构造函数）</span><br><span class="line">main <span class="class"><span class="keyword">class</span>’<span class="title">s</span> <span class="title">no</span>-<span class="title">arg</span> <span class="title">constructor</span> （主类的无名构造函数）</span></span><br></pre></td></tr></table></figure><p>如果父类中没有匿名无参的构造函数， 则需要手工调用父类的其他构造函数。 在当前构造函数冒号 (:) 之后，函数体之前，声明调用父类构造函数。</p><p>由于父类的构造函数参数在构造函数执行之前执行， 所以参数可以是一个表达式或者一个方法调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(getDefaultData());</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>警告： 调用父类构造函数的参数无法访问 this 。 例如，参数可以为静态函数但是不能是实例函数。</p></blockquote><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>除了调用超类构造函数之外， 还可以在构造函数体执行之前初始化实例变量。 各参数的初始化用逗号分隔。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在构造函数体执行之前，</span></span><br><span class="line"><span class="comment">// 通过初始列表设置实例变量。</span></span><br><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">num</span>&gt; json)</span><br><span class="line">    : x = json[<span class="string">'x'</span>],</span><br><span class="line">      y = json[<span class="string">'y'</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>警告： 初始化程序的右侧无法访问 this 。</p></blockquote><p>在开发期间， 可以使用 assert 来验证输入的初始化列表。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point.withAssert(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y) : <span class="keyword">assert</span>(x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In Point.withAssert(): (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用初始化列表可以很方便的设置 final 字段。 下面示例演示了，如何使用初始化列表初始化设置三个 final 字段。 点击运行按钮  执行示例代码。</p><h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。 重定向构造函数的函数体为空， 构造函数的调用在冒号 (:) 之后。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的主构造函数。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向主构造函数</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果该类生成的对象是固定不变的， 那么就可以把这些对象定义为编译时常量。 为此，需要定义一个 const 构造函数， 并且声明所有实例变量为 final。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量构造函数创建的实例并不总是常量。 更多内容，查看 使用构造函数 章节。</p><h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>当执行构造函数并不总是创建这个类的一个新实例时，则使用 factory 关键字。 例如，一个工厂构造函数可能会返回一个 cache 中的实例， 或者可能返回一个子类的实例。</p><p>以下示例演示了从缓存中返回对象的工厂构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从命名的 _ 可以知，</span></span><br><span class="line">  <span class="comment">// _cache 是私有属性。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示： 工厂构造函数无法访问 this。</p></blockquote><p>工厂构造函的调用方式与其他构造函数一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = Logger(<span class="string">'UI'</span>);</span><br><span class="line">logger.log(<span class="string">'Button clicked'</span>);</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是为对象提供行为的函数。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>对象的实例方法可以访问 this 和实例变量。 以下示例中的 distanceTo() 方法就是实例方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Getter-和-Setter"><a href="#Getter-和-Setter" class="headerlink" title="Getter 和 Setter"></a>Getter 和 Setter</h4><p>Getter 和 Setter 是用于对象属性读和写的特殊方法。 回想之前的例子，每个实例变量都有一个隐式 Getter ，通常情况下还会有一个 Setter 。 使用 get 和 set 关键字实现 Getter 和 Setter ，能够为实例创建额外的属性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left, top, width, height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义两个计算属性： right 和 bottom。</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right =&gt; left + width;</span><br><span class="line">  <span class="keyword">set</span> right(<span class="built_in">num</span> value) =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom =&gt; top + height;</span><br><span class="line">  <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始实现 Getter 和 Setter 也许是直接返回成员变量； 随着需求变化， Getter 和 Setter 可能需要进行计算处理而使用方法来实现； 但是，调用对象的代码不需要做任何的修改。</p><blockquote><p>提示： 类似 (++) 之类操作符不管是否定义了 getter 方法，都能够正确的执行。 为了避免一些问题，操作符只调用一次 getter 方法， 然后把值保存到一个临时的变量中。</p></blockquote><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>实例方法， getter， 和 setter 方法可以是抽象的， 只定义接口不进行实现，而是留给其他类去实现。 抽象方法只存在于 抽象类 中。</p><p>定义一个抽象函数，使用分号 (;) 来代替函数体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义实例变量和方法 ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// 定义一个抽象方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// 提供方法实现，所以这里的方法就不是抽象方法了...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用抽象方法会导致运行时错误。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>使用 abstract 修饰符来定义 抽象类 — 抽象类不能实例化。 抽象类通常用来定义接口，以及部分实现。 如果希望抽象类能够被实例化，那么可以通过定义一个 工厂构造函数 来实现。</p><p>抽象类通常具有 抽象方法。 下面是一个声明具有抽象方法的抽象类示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类被定义为抽象类，</span></span><br><span class="line"><span class="comment">// 所以不能被实例化。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义构造行数，字段，方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h4><p>每个类都隐式的定义了一个接口，接口包含了该类所有的实例成员及其实现的接口。 如果要创建一个 A 类，A 要支持 B 类的 API ，但是不需要继承 B 的实现， 那么可以通过 A 实现 B 的接口。</p><p>一个类可以通过 implements 关键字来实现一个或者多个接口， 并实现每个接口要求的 API。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person 类。 隐式接口里面包含了 greet() 方法声明。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 包含在接口里，但只在当前库中可见。</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不包含在接口里，因为这是一个构造函数。</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含在接口里。</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 接口的实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'Bob'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'Kathy'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面示例演示一个类如何实现多个接口： Here’s an example of specifying that a class implements multiple interfaces:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展类（继承）"><a href="#扩展类（继承）" class="headerlink" title="扩展类（继承）"></a>扩展类（继承）</h4><p>使用 extends 关键字来创建子类， 使用 super 关键字来引用父类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写类成员"><a href="#重写类成员" class="headerlink" title="重写类成员"></a>重写类成员</h4><p>子类可以重写实例方法，getter 和 setter。 可以使用 @override 注解指出想要重写的成员：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To narrow the type of a method parameter or instance variable in code that is type safe, you can use the covariant keyword.</p><h4 id="重写运算符"><a href="#重写运算符" class="headerlink" title="重写运算符"></a>重写运算符</h4><p>下标的运算符可以被重写。 例如，想要实现两个向量对象相加，可以重写 + 方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;+|[]</span><br><span class="line">&gt;/^[]=</span><br><span class="line">&lt;=~/&amp;~</span><br><span class="line">&gt;=*&lt;&lt;==</span><br><span class="line">–%&gt;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>提示： 你可能会被提示 != 运算符为非可重载运算符。 因为 e1 != e2 表达式仅仅是 !(e1 == e2) 的语法糖。</p></blockquote><p>下面示例演示一个类重写 + 和 - 操作符：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) =&gt; Vector(x + v.x, y + v.y);</span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) =&gt; Vector(x - v.x, y - v.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运算符 == 和 hashCode 部分没有列出。 有关详情，请参考下面的注释。</span></span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(v + w == Vector(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  <span class="keyword">assert</span>(v - w == Vector(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要重写 == 操作符，需要重写对象的 hashCode getter 方法。 重写 == 和 hashCode 的实例，参考 Implementing map keys.</p><p>有关重写的更多介绍，请参考 扩展类（继承）.</p><h4 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h4><p>当代码尝试使用不存在的方法或实例变量时， 通过重写 noSuchMethod() 方法，来实现检测和应对处理：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不重写 noSuchMethod，访问</span></span><br><span class="line">  <span class="comment">// 不存在的实例变量时会导致 NoSuchMethodError 错误。</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation invocation) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'You tried to use a non-existent member: '</span> +</span><br><span class="line">        <span class="string">'<span class="subst">$&#123;invocation.memberName&#125;</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非符合下面的任意一项条件， 否则没有实现的方法不能够被调用：</p><ul><li><p>receiver 具有 dynamic 的静态类型 。</p></li><li><p>receiver 具有静态类型，用于定义为实现的方法 (可以是抽象的), 并且 receiver 的动态类型具有 noSuchMethod() 的实现， 该实现与 Object 类中的实现不同。</p></li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型也称为 enumerations 或 enums ， 是一种特殊的类，用于表示数量固定的常量值。</p><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><p>使用 enum 关键字定义一个枚举类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; red, green, blue &#125;</span><br></pre></td></tr></table></figure><p>枚举中的每个值都有一个 index getter 方法， 该方法返回值所在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的索引是 0 ， 第二个枚举值的索引是 1。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>使用枚举的 values 常量， 获取所有枚举值列表（ list ）。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p>可以在 switch 语句 中使用枚举， 如果不处理所有枚举值，会收到警告：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aColor = Color.blue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Red as roses!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Green as grass!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 没有这个，会看到一个警告。</span></span><br><span class="line">    <span class="built_in">print</span>(aColor); <span class="comment">// 'Color.blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型具有以下限制：</p><ul><li>枚举不能被子类化，混合或实现。</li><li>枚举不能被显式实例化。</li></ul><h2 id="为类添加功能：-Mixin"><a href="#为类添加功能：-Mixin" class="headerlink" title="为类添加功能： Mixin"></a>为类添加功能： Mixin</h2><p>Mixin 是复用类代码的一种途径， 复用的类可以在不同层级，之间可以不存在继承关系。</p><p>通过 with 后面跟一个或多个混入的名称，来使用 Mixin ， 下面的示例演示了两个使用 Mixin 的类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mixin Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定只有某些类型可以使用的 Mixin - 比如， Mixin 可以调用 Mixin 自身没有定义的方法 - 使用 on 来指定可以使用 Mixin 的父类类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixin MusicalPerformer on Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>版本提示： mixin 关键字在 Dart 2.1 中被引用支持。 早期版本中的代码通常使用 abstract class 代替。 更多有关 Mixin 在 2.1 中的变更信息，请参见 Dart SDK changelog 和 2.1 mixin specification 。</p></blockquote><p>提示： 对 Mixin 的一些限制正在被移除。</p><h2 id="类变量和方法"><a href="#类变量和方法" class="headerlink" title="类变量和方法"></a>类变量和方法</h2><p>使用 static 关键字实现类范围的变量和方法。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态变量（类变量）对于类级别的状态是非常有用的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> initialCapacity = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Queue.initialCapacity == <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量只到它们被使用的时候才会初始化。</p><blockquote><p>提示： 代码准守风格推荐指南 中的命名规则， 使用 lowerCamelCase 来命名常量。</p></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法（类方法）不能在实例上使用，因此它们不能访问 this 。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="number">2.8</span> &lt; distance &amp;&amp; distance &lt; <span class="number">2.9</span>);</span><br><span class="line">  <span class="built_in">print</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示： 对于常见或广泛使用的工具和函数， 应该考虑使用顶级函数而不是静态方法。</p></blockquote><p>静态函数可以当做编译时常量使用。 例如，可以将静态方法作为参数传递给常量构造函数。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在 API 文档中你会发现基础数组类型 List 的实际类型是 List<e> 。 &lt;…&gt; 符号将 List 标记为 泛型 (或 参数化) 类型。 这种类型具有形式化的参数。 通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。</e></p><h3 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h3><p>在类型安全上通常需要泛型支持， 它的好处不仅仅是保证代码的正常运行：</p><p>正确指定泛型类型可以提高代码质量。<br>使用泛型可以减少重复的代码。<br>如果想让 List 仅仅支持字符串类型， 可以将其声明为 List<string> （读作“字符串类型的 list ”）。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。 例如：</string></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>另外一个使用泛型的原因是减少重复的代码。 泛型可以在多种类型之间定义同一个实现， 同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。 例如，假设你创建了一个用于缓存对象的接口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现需要一个相同功能的字符串类型接口，因此又创建了另一个接口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来，又发现需要一个相同功能的数字类型接口 … 这里你应该明白了。</p><p>泛型可以省去创建所有这些接口的麻烦。 通过创建一个带有泛型参数的接口，来代替上述接口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  <span class="keyword">void</span> setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，T 是一个备用类型。 这是一个类型占位符，在开发者调用该接口的时候会指定具体类型。</p><h3 id="使用集合字面量"><a href="#使用集合字面量" class="headerlink" title="使用集合字面量"></a>使用集合字面量</h3><p>List , Set 和 Map 字面量也是可以参数化的。 参数化字面量和之前的字面量定义类似， 对于 List 或 Set 只需要在声明语句前加 <type> 前缀， 对于 Map 只需要在声明语句前加 &lt;keyType, valueType&gt; 前缀， 下面是参数化字面量的示例：</type></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'Hints for web robots'</span>,</span><br><span class="line">  <span class="string">'humans.txt'</span>: <span class="string">'We are people, not machines'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用泛型类型的构造函数"><a href="#使用泛型类型的构造函数" class="headerlink" title="使用泛型类型的构造函数"></a>使用泛型类型的构造函数</h3><p>在调用构造函数的时，在类名字后面使用尖括号（&lt;…&gt;）来指定泛型类型。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameSet = <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure><p>下面代码创建了一个 key 为 integer， value 为 View 的 map 对象：</p><p><code>var views = Map&lt;int, View&gt;();</code></p><h3 id="运行时中的泛型集合"><a href="#运行时中的泛型集合" class="headerlink" title="运行时中的泛型集合"></a>运行时中的泛型集合</h3><p>Dart 中泛型类型是 固化的，也就是说它们在运行时是携带着类型信息的。 例如， 在运行时检测集合的类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>提示： 相反，Java中的泛型会被 擦除 ，也就是说在运行时泛型类型参数的信息是不存在的。 在Java中，可以测试对象是否为 List 类型， 但无法测试它是否为 List<string> 。</string></p></blockquote><h3 id="限制泛型类型"><a href="#限制泛型类型" class="headerlink" title="限制泛型类型"></a>限制泛型类型</h3><p>使用泛型类型的时候， 可以使用 extends 实现参数类型的限制。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Implementation goes here...</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">"Instance of 'Foo&lt;<span class="subst">$T</span>&gt;'"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>可以使用 SomeBaseClass 或其任意子类作为通用参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();</span><br><span class="line"><span class="keyword">var</span> extenderFoo = Foo&lt;Extender&gt;();</span><br></pre></td></tr></table></figure><p>也可以不指定泛型参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Foo();</span><br><span class="line"><span class="built_in">print</span>(foo); <span class="comment">// Instance of 'Foo&lt;SomeBaseClass&gt;'</span></span><br></pre></td></tr></table></figure><p>指定任何非 SomeBaseClass 类型会导致错误：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Foo&lt;<span class="built_in">Object</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h3><p>最初，Dart 的泛型只能用于类。 新语法<em>泛型方法</em>，允许在方法和函数上使用类型参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 first (<t>) 泛型可以在如下地方使用参数 T ：</t></p><ul><li>函数的返回值类型 (T).</li><li>参数的类型 (List<t>).</t></li><li>局部变量的类型 (T tmp).</li></ul><h2 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h2><p>import 和 library 指令可以用来创建一个模块化的，可共享的代码库。 库不仅提供了 API ，而且对代码起到了封装的作用： 以下划线 (_) 开头的标识符仅在库内可见。 每个 Dart 应用程序都是一个库 ，虽然没有使用 library 指令。</p><p>库可以通过包来分发。有关 pub（集成在SDK中的包管理器）的信息，请参考 Pub Package 和 Asset Manager。</p><h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>通过 import 指定一个库命名空间中的内如如何在另一个库中使用。 例如，Dart Web应用程序通常使用 dart:html 库，它们可以像这样导入：</p><p><code>import &#39;dart:html&#39;;</code></p><p>import 参数只需要一个指向库的 URI。 对于内置库，URI 拥有自己特殊的dart: 方案。 对于其他的库，使用系统文件路径或者 package: 方案 。 package: 方案指定由包管理器（如 pub 工具）提供的库。例如：</p><p><code>import &#39;package:test/test.dart&#39;;</code></p><blockquote><p>提示： URI 代表统一资源标识符。 URL（统一资源定位符）是一种常见的URI。</p></blockquote><h4 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h4><p>如果导入两个存在冲突标识符的库， 则可以为这两个库，或者其中一个指定前缀。 例如，如果 library1 和 library2 都有一个 Element 类， 那么可以通过下面的方式处理：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lib1 中的 Element。</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lib2 中的 Element。</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure><h3 id="导入库的一部分"><a href="#导入库的一部分" class="headerlink" title="导入库的一部分"></a>导入库的一部分</h3><p>如果你只使用库的一部分功能，则可以选择需要导入的 内容。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import only foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import all names EXCEPT foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure><h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p>Deferred loading (也称之为 lazy loading) 可以让应用在需要的时候再加载库。 下面是一些使用延迟加载库的场景：</p><ul><li>减少 APP 的启动时间。</li><li>执行 A/B 测试，例如 尝试各种算法的 不同实现。</li><li>加载很少使用的功能，例如可选的屏幕和对话框。</li><li>要延迟加载一个库，需要先使用 deferred as 来导入：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">当需要使用的时候，使用库标识符调用 loadLibrary() 函数来加载库：</span><br><span class="line"></span><br><span class="line">```dart</span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的代码，使用 await 关键字暂停代码执行一直到库加载完成。 关于 async 和 await 的更多信息请参考 异步支持。</p><p>在一个库上你可以多次调用 loadLibrary() 函数。但是该库只是载入一次。</p><p>使用延迟加载库的时候，请注意一下问题：</p><p>延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用。<br>在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库。<br>Dart 隐含的把 loadLibrary() 函数导入到使用 deferred as 的命名空间 中。 loadLibrary() 方法返回一个 Future。<br>Dart VM difference: The Dart VM allows access to members of deferred libraries even before the call to loadLibrary(). This behavior might change, so don’t depend on the current VM behavior. For details, see issue #33118.</p><h3 id="实现库"><a href="#实现库" class="headerlink" title="实现库"></a>实现库</h3><p>有关如何实现库包的建议，请参考 Create Library Packages 这里面包括：</p><ul><li>如何组织库的源文件。</li><li>如何使用 export 命令。</li><li>何时使用 part 命令。</li><li>何时使用 library 命令。</li></ul><h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p>Dart 库中包含许多返回 Future 或 Stream 对象的函数. 这些函数在设置完耗时任务（例如 I/O 曹组）后， 就立即返回了，不会等待耗任务完成。 使用 async 和 await 关键字实现异步编程。 可以让你像编写同步代码一样实现异步操作。</p><h3 id="处理-Future"><a href="#处理-Future" class="headerlink" title="处理 Future"></a>处理 Future</h3><p>可以通过下面两种方式，获得 Future 执行完成的结果：</p><ul><li>使用 async 和 await.</li><li>使用 Future API，具体描述，参考 库概览.</li><li>使用 async 和 await 关键字的代码是异步的。 虽然看起来有点想同步代码。 例如，下面的代码使用 await 等待异步函数的执行结果。</li></ul><p><code>await lookUpVersion();</code></p><p>要使用 await ， 代码必须在 异步函数（使用 async 标记的函数）中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示： 虽然异步函数可能会执行耗时的操作， 但它不会等待这些操作。 相反，异步函数只有在遇到第一个 await 表达式（详情见）时才会执行。 也就是说，它返回一个 Future 对象， 仅在await表达式完成后才恢复执行。</p></blockquote><p>使用 try， catch， 和 finally 来处理代码中使用 await 导致的错误。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// React to inability to look up the version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个异步函数中可以多次使用 await 。 例如，下面代码中等待了三次函数结果：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure><p>在 await 表达式 中， 表达式 的值通常是一个 Future 对象； 如果不是，这是表达式的值会被自动包装成一个 Future 对象。 Future 对象指明返回一个对象的承诺（promise）。 await 表达式 执行的结果为这个返回的对象。 await 表达式会阻塞代码的执行，直到需要的对象返回为止。</p><p>如果在使用 await 导致编译时错误， 确认 await 是否在一个异步函数中。 例如，在应用的 main() 函数中使用 await ， main() 函数的函数体必须被标记为 async ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  checkVersion();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In main: version is <span class="subst">$&#123;await lookUpVersion()&#125;</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h3><p>函数体被 async 标示符标记的函数，即是一个<em>异步函数</em>。 将 async 关键字添加到函数使其返回Future。 例如，考虑下面的同步函数，它返回一个 String ：</p><p><code>String lookUpVersion() =&gt; &#39;1.0.0&#39;;</code></p><p>例如，将来的实现将非常耗时，将其更改为异步函数，返回值是 Future 。</p><p><code>Future&lt;String&gt; lookUpVersion() async =&gt; &#39;1.0.0&#39;;</code></p><p>注意，函数体不需要使用Future API。 如有必要， Dart 会创建 Future 对象。</p><p>如果函数没有返回有效值， 需要设置其返回类型为 Future<void> 。</void></p><h3 id="处理-Stream"><a href="#处理-Stream" class="headerlink" title="处理 Stream"></a>处理 Stream</h3><p>当需要从 Stream 中获取数据值时， 可以通过一下两种方式：</p><ul><li>使用 async 和 一个 异步循环 （await for）。</li><li>使用 Stream API, 更多详情，参考 in the library tour。</li></ul><blockquote><p>提示： 在使用 await for 前，确保代码清晰， 并且确实希望等待所有流的结果。 例如，通常不应该使用 await for 的UI事件侦听器， 因为UI框架会发送无穷无尽的事件流。</p></blockquote><p>以下是异步for循环的使用形式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (varOrType identifier <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// Executes each time the stream emits a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面 表达式 返回的值必须是 Stream 类型。 执行流程如下：</p><ul><li>等待，直到流发出一个值。</li><li>执行 for 循环体，将变量设置为该发出的值</li><li>重复1和2，直到关闭流。</li></ul><p>使用 break 或者 return 语句可以停止接收 stream 的数据， 这样就跳出了 for 循环， 并且从 stream 上取消注册。 <strong>如果在实现异步 for 循环时遇到编译时错误， 请检查确保 await for 处于异步函数中。</strong> 例如，要在应用程序的 main() 函数中使用异步 fo r循环， main() 函数体必须标记为 async` ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>当您需要延迟生成( lazily produce )一系列值时， 可以考虑使用<em>生成器函数</em>。 Dart 内置支持两种生成器函数：</p><ul><li>Synchronous 生成器： 返回一个 Iterable 对象。</li><li>Asynchronous 生成器： 返回一个 Stream 对象。<br>通过在函数体标记 sync*， 可以实现一个同步生成器函数。 使用 yield 语句来传递值：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在函数体标记 async*， 可以实现一个异步生成器函数。 使用 yield 语句来传递值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果生成器是递归的，可以使用 yield* 来提高其性能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h2><p>通过实现类的 call() 方法， 能够让类像函数一样被调用。</p><p>在下面的示例中，WannabeFunction 类定义了一个 call() 函数， 函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号。 单击运行按钮  执行代码。</p><h2 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h2><p>大多数计算机中，甚至在移动平台上，都在使用多核CPU。 为了有效利用多核性能，开发者一般使用共享内存数据来保证多线程的正确执行。 然而， 多线程共享数据通常会导致很多潜在的问题，并导致代码运行出错。</p><p>所有 Dart 代码都在隔离区（ isolates ）内运行，而不是线程。 每个隔离区都有自己的内存堆，确保每个隔离区的状态都不会被其他隔离区访问。</p><h2 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h2><p>在 Dart 中，函数也是对象，就想字符和数字对象一样。 使用 typedef ，或者 function-type alias 为函数起一个别名， 别名可以用来声明字段及返回值类型。 当函数类型分配给变量时，typedef会保留类型信息。</p><p>请考虑以下代码，代码中未使用 typedef ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial, broken implementation. // broken ？</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 虽然知道 compare 是函数，</span></span><br><span class="line">  <span class="comment">// 但是函数是什么类型 ？</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把 f 赋值给 compare 的时候，类型信息丢失了。 f 的类型是 (Object, Object) → int (这里 → 代表返回值类型)， 但是 compare 得到的类型是 Function 。如果我们使用显式的名字并保留类型信息， 这样开发者和工具都可以使用这些信息：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare = <span class="built_in">int</span> <span class="built_in">Function</span>(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial, broken implementation.</span></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  SortedCollection coll = SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>提示： 目前，typedefs 只能使用在函数类型上， 我们希望将来这种情况有所改变。</p></blockquote><p>由于 typedefs 只是别名， 他们还提供了一种方式来判断任意函数的类型。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Compare&lt;T&gt; = <span class="built_in">int</span> <span class="built_in">Function</span>(T a, T b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare&lt;<span class="built_in">int</span>&gt;); <span class="comment">// True!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>使用元数据可以提供有关代码的其他信息。 元数据注释以字符 @ 开头， 后跟对编译时常量 (如 deprecated) 的引用或对常量构造函数的调用。</p><p>对于所有 Dart 代码有两种可用注解：@deprecated 和 @override。 关于 @override 的使用， 参考 扩展类（继承）。 下面是使用 @deprecated 注解的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// _Deprecated: Use [turnOn] instead._</span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Turns the TV's power on.</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以自定义元数据注解。 下面的示例定义了一个带有两个参数的 @todo 注解：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @todo 注解的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'todo.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Todo</span>(<span class="string">'seth'</span>, <span class="string">'make this do something'</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'do something'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元数据可以在 library、 class、 typedef、 type parameter、 constructor、 factory、 function、 field、 parameter 或者 variable 声明之前使用，也可以在 import 或者 export 指令之前使用。 使用反射可以在运行时获取元数据信息。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Dart 支持单行注释、多行注释和文档注释。</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>单行注释以 // 开始。 所有在 // 和改行结尾之间的内容被编译器忽略。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> refactor into an AbstractLlamaGreetingFactory?</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Welcome to my Llama farm!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>多行注释以 /<em> 开始， 以 </em>/ 结尾。 所有在 /<em> 和 </em>/ 之间的内容被编译器忽略 （不会忽略文档注释）。 多行注释可以嵌套。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * This is a lot of work. Consider raising chickens.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Llama larry = Llama();</span></span><br><span class="line"><span class="comment">  larry.feed();</span></span><br><span class="line"><span class="comment">  larry.exercise();</span></span><br><span class="line"><span class="comment">  larry.clean();</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>文档注释可以是多行注释，也可以是单行注释， 文档注释以 /// 或者 /** 开始。 在连续行上使用 /// 与多行文档注释具有相同的效果。</p><p>在文档注释中，除非用中括号括起来，否则Dart 编译器会忽略所有文本。 使用中括号可以引用类、 方法、 字段、 顶级变量、 函数、 和参数。 括号中的符号会在已记录的程序元素的词法域中进行解析。</p><p>下面是一个引用其他类和成员的文档注释：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A domesticated South American camelid (Lama glama).</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 自从西班牙时代以来，</span></span><br><span class="line"><span class="comment">/// 安第斯文化就将骆驼当做肉食类和运输类动物。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Llama</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 喂养骆驼 [Food].</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 典型的美洲驼每周吃一捆干草。</span></span><br><span class="line">  <span class="keyword">void</span> feed(Food food) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用 [activity] 训练骆驼</span></span><br><span class="line">  <span class="comment">/// [timeLimit] 分钟。</span></span><br><span class="line">  <span class="keyword">void</span> exercise(Activity activity, <span class="built_in">int</span> timeLimit) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成的文档中，[Food] 会成为一个链接， 指向 Food 类的 API 文档。</p><p>解析 Dart 代码并生成 HTML 文档，可以使用 SDK 中的 documentation generation tool. 关于生成文档的实例，请参考 Dart API documentation. 关于文档结构的建议，请参考 Guidelines for Dart Doc Comments.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本页概述了 Dart 语言中常用的功能。 还有更多特性有待实现，但我们希望它们不会破坏现有代码。 有关更多信息，请参考 Dart language specification 和 Effective Dart.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;Dart-语法-2&quot;&gt;&lt;a href=&quot;#Dart-语法-2&quot; class=&quot;headerlink&quot; title=&quot;Dart 语法(2)&quot;&gt;&lt;/a&gt;Dart 语法(2)&lt;/h1&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot;
        
      
    
    </summary>
    
      <category term="Dart" scheme="http://duanyitao.com/categories/Dart/"/>
    
    
      <category term="语法" scheme="http://duanyitao.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Dart 风格指南</title>
    <link href="http://duanyitao.com/2020/03/12/Dart-%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://duanyitao.com/2020/03/12/Dart-风格指南/</id>
    <published>2020-03-12T01:58:35.000Z</published>
    <updated>2020-03-12T01:58:35.158Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="" scheme="http://duanyitao.com/tags/undefined/"/>
    
  </entry>
  
  <entry>
    <title>Dart 语法(1)</title>
    <link href="http://duanyitao.com/2020/03/11/Dart-%E8%AF%AD%E6%B3%95-1/"/>
    <id>http://duanyitao.com/2020/03/11/Dart-语法-1/</id>
    <published>2020-03-11T10:24:05.000Z</published>
    <updated>2020-03-12T06:24:35.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart-语法-1"><a href="#Dart-语法-1" class="headerlink" title="Dart 语法(1)"></a>Dart 语法(1)</h1><h2 id="一个简单的-Dart-程序"><a href="#一个简单的-Dart-程序" class="headerlink" title="一个简单的 Dart 程序"></a>一个简单的 Dart 程序</h2><p>下面的代码用到了很多 Dart 的基本功能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is <span class="subst">$aNumber</span>.'</span>); <span class="comment">// 打印到控制台。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用从这里开始执行。</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量。</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>// 单行注释。</p></li><li><p>int</p><p>数据类型。一些其他 内置类型 包括 String , List , 和 bool 。</p></li><li><p>42</p><p>字面量。字面量是一种编译型常量。</p></li><li><p>print()</p><p>便利输出方式。</p></li><li><p>‘…’ (or “…”)</p><p>字符串常量。</p></li><li><p>$variableName (或 ${expression})</p><p>字符串插值： 包括字符串文字内部的变量或表达式的字符串。</p></li><li><p>main()</p><p>程序开始执行函数，该函数是特定的、必须的、顶级函数。</p></li><li><p>var</p><p>定义变量，通过这种方式定义变量不需要指定变量类型。</p></li></ul><h2 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h2><p>在学习 Dart 语言时, 应该基于以下事实和概念：</p><ul><li><p>任何保存在变量中的都是一个 对象 ， 并且所有的对象都是对应一个 类 的实例。 无论是数字，函数和 null 都是对象。所有对象继承自 Object 类。</p></li><li><p>尽管 Dart 是强类型的，但是 Dart 可以推断类型，所以类型注释是可选的。 在上面的代码中， number 被推断为 int 类型。 如果要明确说明不需要任何类型， 需要使用特殊类型 dynamic 。</p></li><li><p>Dart 支持泛型，如 List <int> （整数列表）或 List <dynamic> （任何类型的对象列表）。</dynamic></int></p></li><li><p>Dart 支持顶级函数（例如 main（） ）， 同样函数绑定在类或对象上（分别是 静态函数 和 实例函数 ）。 以及支持函数内创建函数 （ 嵌套 或 局部函数 ） 。</p></li><li><p>类似地， Dart 支持顶级 变量 ， 同样变量绑定在类或对象上（静态变量和实例变量）。 实例变量有时称为字段或属性。</p></li><li><p>与 Java 不同，Dart 没有关键字 “public” ， “protected” 和 “private” 。 如果标识符以下划线（_）开头，则它相对于库是私有的。</p></li><li><p>标识符 以字母或下划线（_）开头，后跟任意字母和数字组合。</p></li><li><p>Dart 语法中包含 表达式（ expressions ）（有运行时值）和 语句（ statements ）（没有运行时值）。 例如，条件表达式 condition ? expr1 : expr2 的值可能是 expr1 或 expr2 。 将其与 if-else 语句 相比较，if-else 语句没有值。 一条语句通常包含一个或多个表达式，相反表达式不能直接包含语句。</p></li><li><p>Dart 工具提示两种类型问题：警告_和_错误。 警告只是表明代码可能无法正常工作，但不会阻止程序的执行。 错误可能是编译时错误或者运行时错误。 编译时错误会阻止代码的执行; 运行时错误会导致代码在执行过程中引发 [异常]（#exception）。</p></li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>Dart 语言关键字列表。</p><blockquote></blockquote><p>abstract<sup>2<sup> </sup></sup></p><p>dynamic<sup>2<sup></sup></sup></p><p>implements<sup>2<sup> </sup></sup></p><p>show<sup>1<sup></sup></sup></p><p>as<sup>2<sup> </sup></sup></p><p>else</p><p>import<sup>2<sup> </sup></sup></p><p>static<sup>2<sup> </sup></sup></p><p>assert</p><p>enum</p><p>in</p><p>super</p><p>async<sup>1<sup> </sup></sup></p><p>export<sup>2<sup> </sup></sup></p><p>interface<sup>2<sup> </sup></sup></p><p>switch</p><p>await<sup>3<sup> </sup></sup></p><p>extends</p><p>is</p><p>sync<sup>1<sup></sup></sup></p><p>break    external<sup>2<sup> </sup></sup></p><p>library<sup>2<sup> </sup></sup></p><p>this</p><p>case</p><p>factory<sup>2<sup> </sup></sup></p><p>mixin<sup>2<sup> </sup></sup></p><p>throw</p><p>catch    </p><p>false    </p><p>new    </p><p>true</p><p>class    </p><p>final    </p><p>null</p><p>try</p><p>const    </p><p>finally    </p><p>on<sup>1<sup> </sup></sup></p><p>typedef<sup>2<sup> </sup></sup></p><p>continue    </p><p>for    </p><p>operator<sup>2<sup></sup></sup></p><p>var</p><p>covariant<sup>2<sup> </sup></sup></p><p>Function<sup>2<sup> </sup></sup></p><p>part<sup>2<sup></sup></sup></p><p>void</p><p>default    </p><p>get<sup>2<sup> </sup></sup></p><p>rethrow</p><p>while</p><p>deferred<sup>2<sup> </sup></sup></p><p>hide<sup>1<sup></sup></sup></p><p>return    </p><p>with</p><p>do</p><p>if</p><p>set<sup>2<sup> </sup></sup></p><p>yield<sup>3<sup> </sup></sup></p><p>避免使用这些单词作为标识符。 但是，如有必要，标有上标的关键字可以用作标识符：</p><ul><li><p>带有 1 上标的单词为 上下文关键字， 仅在特定位置具有含义。 他们在任何地方都是有效的标识符。</p></li><li><p>带有 2 上标的单词为 内置标识符， 为了简化将 JavaScript 代码移植到 Dart 的工作， 这些关键字在大多数地方都是有效的标识符， 但它们不能用作类或类型名称，也不能用作 import 前缀。</p></li><li><p>带有 3 上标的单词是与 Dart 1.0 发布后添加的异步支持相关的更新，作为限制类保留字。<br>不能在标记为 async ，async<em> 或 sync</em> 的任何函数体中使用 await 或 yield 作为标识符。</p></li></ul><p>关键字表中的剩余单词都是保留字。 不能将保留字用作标识符。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>创建一个变量并进行初始化:</p><p><code>var name = &#39;Bob&#39;;</code></p><p>变量仅存储对象引用，这里的变量是 name 存储了一个 String 类型的对象引用。 “Bob” 是这个 String 类型对象的值。</p><p>name 变量的类型被推断为 String 。 但是也可以通过指定类型的方式，来改变变量类型。 如果对象不限定为单个类型，可以指定为 对象类型 或 动态类型。</p><p><code>dynamic name = &#39;Bob&#39;;</code></p><p>另一种方式是显式声明可以推断出的类型：</p><p><code>String name = &#39;Bob&#39;;</code></p><blockquote><p>提示： 本地局部变量遵守 风格建议指南 使用 var。 没有使用指定类型的方式。</p></blockquote><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量默认值是 null。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型 也不例外。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>提示： 在生产环境代码中 assert() 函数会被忽略，不会被调用。 在开发过程中, assert(condition) 会在非 true 的条件下抛出异常.</p></blockquote><h3 id="Final-和-Const"><a href="#Final-和-Const" class="headerlink" title="Final 和 Const"></a>Final 和 Const</h3><p>使用过程中从来不会被修改的变量， 可以使用 final 或 const, 而不是 var 或者其他类型， Final 变量的值只能被设置一次； Const 变量在编译时就已经固定 (Const 变量 是隐式 Final 的类型.) 最高级 final 变量或类变量在第一次使用时被初始化。</p><blockquote><p>提示： 实例变量可以是 final 类型但不能是 const 类型。 必须在构造函数体执行之前初始化 final 实例变量 —— 在变量声明中，参数构造函数中或构造函数的初始化列表中进行初始化。</p></blockquote><p>创建和设置一个 Final 变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// Without a type annotation</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>final 不能被修改:</p><p><code>name = &#39;Alice&#39;; // Error: 一个 final 变量只能被设置一次。</code></p><p>如果需要在编译时就固定变量的值，可以使用 const 类型变量。 如果 Const 变量是类级别的，需要标记为 static const。 在这些地方可以使用在编译时就已经固定不变的值，字面量的数字和字符串， 固定的变量，或者是用于计算的固定数字：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位 (dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准气压</span></span><br></pre></td></tr></table></figure><p>Const 关键字不仅可以用于声明常量变量。 还可以用来创建常量值，以及声明创建常量值的构造函数。 任何变量都可以拥有常量值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> [];</span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> [];</span><br><span class="line"><span class="keyword">const</span> baz = []; <span class="comment">// Equivalent to `const []`</span></span><br></pre></td></tr></table></figure><p>声明 const 的初始化表达式中 const 可以被省略。 比如上面的 baz。</p><p>非 Final ， 非 const 的变量是可以被修改的，即使这些变量 曾经引用过 const 值。</p><p><code>foo = [1, 2, 3]; // 曾经引用过 const [] 常量值。</code></p><p>Const 变量的值不可以修改：</p><p><code>baz = [42]; // Error: 常量变量不能赋值修改。</code></p><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><p>Dart 语言支持以下内建类型：</p><ul><li>Number</li><li>String</li><li>Boolean</li><li>List (也被称为 Array)</li><li>Map</li><li>Set</li><li>Rune (用于在字符串中表示 * Unicode 字符)</li><li>Symbol</li></ul><p>这些类型都可以被初始化为字面量。 例如, ‘this is a string’ 是一个字符串的字面量， true 是一个布尔的字面量。</p><p>因为在 Dart 所有的变量终究是一个对象（一个类的实例）， 所以变量可以使用 构造涵数 进行初始化。 一些内建类型拥有自己的构造函数。 例如， 通过 Map() 来构造一个 map 变量。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Dart 语言的 Number 有两种类型:</p><ul><li><p>int</p><p>整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -253 到 253 - 1.</p></li><li><p>double</p><p>64位（双精度）浮点数，依据 IEEE 754 标准。</p><p>int 和 double 都是 num. 的子类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 abs()， ceil()， 和 floor()， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及其亚类型找不到你想要的方法， 尝试查找使用 dart:math 库。</p><p>整数类型不包含小数点。 下面是定义整数类型字面量的例子:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0xDEADBEEF</span>;</span><br></pre></td></tr></table></figure></li></ul><p>如果一个数字包含小数点，那么就是小数类型。 下面是定义小数类型字面量的例子:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> exponents = <span class="number">1.42e5</span>;</span><br></pre></td></tr></table></figure><p>从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。</p><p><code>double z = 1; // 相当于 double z = 1.0.</code></p><blockquote><p>版本提示： 在 2.1 之前，在 double 上下文中使用 int 字面量是错误的。</p></blockquote><p>以下是将字符串转换为数字的方法，反之亦然：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">assert</span>(one == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">'1.1'</span>);</span><br><span class="line"><span class="keyword">assert</span>(onePointOne == <span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"><span class="keyword">assert</span>(oneAsString == <span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">assert</span>(piAsString == <span class="string">'3.14'</span>);</span><br></pre></td></tr></table></figure><p>int 特有的传统按位运算操作，移位（&lt;&lt;， &gt;&gt;），按位与（&amp;）以及 按位或（|）。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>); <span class="comment">// 0011 &lt;&lt; 1 == 0110</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>); <span class="comment">// 0011 &gt;&gt; 1 == 0001</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> | <span class="number">4</span>) == <span class="number">7</span>); <span class="comment">// 0011 | 0100 == 0111</span></span><br></pre></td></tr></table></figure><p>数字类型字面量是编译时常量。 在算术表达式中，只要参与计算的因子是编译时常量， 那么算术表达式的结果也是编译时常量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msPerSecond = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> secondsUntilRetry = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> msUntilRetry = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'Single quotes work well for string literals.'</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"Double quotes work just as well."</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">'It\'s easy to escape the string delimiter.'</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">"It's even easier to use the other delimiter."</span>;</span><br></pre></td></tr></table></figure><p>字符串可以通过 ${expression} 的方式内嵌表达式。 如果表达式是一个标识符，则 {} 可以省略。 在 Dart 中通过调用就对象的 toString() 方法来得到对象相应的字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'string interpolation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">'Dart has <span class="subst">$s</span>, which is very handy.'</span> ==</span><br><span class="line">    <span class="string">'Dart has string interpolation, '</span> +</span><br><span class="line">        <span class="string">'which is very handy.'</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">'That deserves all caps. '</span> +</span><br><span class="line">        <span class="string">'<span class="subst">$&#123;s.toUpperCase()&#125;</span> is very handy!'</span> ==</span><br><span class="line">    <span class="string">'That deserves all caps. '</span> +</span><br><span class="line">        <span class="string">'STRING INTERPOLATION is very handy!'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>提示： == 运算符用来测试两个对象是否相等。 在字符串中，如果两个字符串包含了相同的编码序列，那么这两个字符串相等。</p></blockquote><p>可以使用 + 运算符来把多个字符串连接为一个，也可以把多个字面量字符串写在一起来实现字符串连接：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'String '</span></span><br><span class="line">    <span class="string">'concatenation'</span></span><br><span class="line">    <span class="string">" works even over line breaks."</span>;</span><br><span class="line"><span class="keyword">assert</span>(s1 ==</span><br><span class="line">    <span class="string">'String concatenation works even over '</span></span><br><span class="line">    <span class="string">'line breaks.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">'The + operator '</span> + <span class="string">'works, as well.'</span>;</span><br><span class="line"><span class="keyword">assert</span>(s2 == <span class="string">'The + operator works, as well.'</span>);</span><br></pre></td></tr></table></figure><p>使用连续三个单引号或者三个双引号实现多行字符串对象的创建：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'''</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">'''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"""This is also a</span></span><br><span class="line"><span class="string">multi-line string."""</span>;</span><br></pre></td></tr></table></figure><p>使用 r 前缀，可以创建 “原始 raw” 字符串：</p><p><code>var s = r&quot;In a raw string, even \n isn&#39;t special.&quot;;</code></p><p>一个编译时常量的字面量字符串中，如果存在插值表达式，表达式内容也是编译时常量， 那么该字符串依旧是编译时常量。 插入的常量值类型可以是 null，数值，字符串或布尔值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 类型数据</span></span><br><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstString = <span class="string">'a constant string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 const 类型数据</span></span><br><span class="line"><span class="keyword">var</span> aNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> aBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> aString = <span class="string">'a string'</span>;</span><br><span class="line"><span class="keyword">const</span> aConstList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">'<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>'</span>; <span class="comment">//const 类型数据</span></span><br><span class="line"><span class="comment">// const invalidConstString = '$aNum $aBool $aString $aConstList'; //非 const 类型数据</span></span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Dart 使用 bool 类型表示布尔值。 Dart 只有字面量 true and false 是布尔类型， 这两个对象都是编译时常量。</p><p>Dart 的类型安全意味着不能使用 if (nonbooleanValue) 或者 assert (nonbooleanValue)。 而是应该像下面这样，明确的进行值检查：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查空字符串。</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 0 值。</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 null 值。</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 NaN 。</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>几乎每种编程语言中最常见的集合可能是 array 或有序的对象集合。 在 Dart 中的 Array 就是 List 对象， 通常称之为 List 。</p><p>Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例：</p><p><code>var list = [1, 2, 3];</code></p><blockquote><p>提示： Dart 推断 list 的类型为 List<int> 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。</int></p></blockquote><p>Lists 的下标索引从 0 开始，第一个元素的索引是 0。 list.length - 1 是最后一个元素的索引。 访问 List 的长度和元素与 JavaScript 中的用法一样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">assert</span>(list.length == <span class="number">3</span>);</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span>(list[<span class="number">1</span>] == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// constantList[1] = 1; // 取消注释会引起错误。</span></span><br></pre></td></tr></table></figure><p>List 类型包含了很多 List 的操作函数。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在 Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 Set 类型。</p><blockquote><p>版本提示： 虽然 Set 类型 一直是 Dart 的核心部分， 但在 Dart2.2 中才引入了 Set 字面量 。</p></blockquote><p>下面是通过字面量创建 Set 的一个简单示例：</p><p><code>var halogens = {&#39;fluorine&#39;, &#39;chlorine&#39;, &#39;bromine&#39;, &#39;iodine&#39;, &#39;astatine&#39;};</code></p><blockquote><p>Note: Dart 推断 halogens 类型为 Set<string> 。如果尝试为它添加一个 错误类型的值，分析器或执行时会抛出错误。</string></p></blockquote><p>要创建一个空集，使用前面带有类型参数的 {} ，或者将 {} 赋值给 Set 类型的变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="comment">// Set&lt;String&gt; names = &#123;&#125;; // 这样也是可以的。</span></span><br><span class="line"><span class="comment">// var names = &#123;&#125;; // 这样会创建一个 Map ，而不是 Set 。</span></span><br></pre></td></tr></table></figure><blockquote><p>是 Set 还是 Map ？ Map 字面量语法同 Set 字面量语法非常相似。 因为先有的 Map 字母量语法，所以 {} 默认是 Map 类型。   如果忘记在 {} 上注释类型或赋值到一个未声明类型的变量上，   那么 Dart 会创建一个类型为 Map&lt;dynamic, dynamic&gt; 的对象。</p></blockquote><p>使用 add() 或 addAll() 为已有的 Set 添加元素：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line">elements.add(<span class="string">'fluorine'</span>);</span><br><span class="line">elements.addAll(halogens);</span><br></pre></td></tr></table></figure><p>使用 .length 来获取 Set 中元素的个数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line">elements.add(<span class="string">'fluorine'</span>);</span><br><span class="line">elements.addAll(halogens);</span><br><span class="line"><span class="keyword">assert</span>(elements.length == <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>在 Set 字面量前增加 const ，来创建一个编译时 Set 常量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantSet = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">'fluorine'</span>,</span><br><span class="line">  <span class="string">'chlorine'</span>,</span><br><span class="line">  <span class="string">'bromine'</span>,</span><br><span class="line">  <span class="string">'iodine'</span>,</span><br><span class="line">  <span class="string">'astatine'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// constantSet.add('helium'); // Uncommenting this causes an error.</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。</p><p>下面是使用 Map 字面量的两个简单例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="comment">// Key:    Value</span></span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'partridge'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'turtledoves'</span>,</span><br><span class="line">  <span class="string">'fifth'</span>: <span class="string">'golden rings'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">'helium'</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">'neon'</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">'argon'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>提示： Dart 会将 gifts 的类型推断为 Map&lt;String, String&gt;， nobleGases 的类型推断为 Map&lt;int, String&gt; 。 如果尝试在上面的 map 中添加错误类型，那么分析器或者运行时会引发错误。</p></blockquote><p>以上 Map 对象也可以使用 Map 构造函数创建：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">'first'</span>] = <span class="string">'partridge'</span>;</span><br><span class="line">gifts[<span class="string">'second'</span>] = <span class="string">'turtledoves'</span>;</span><br><span class="line">gifts[<span class="string">'fifth'</span>] = <span class="string">'golden rings'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nobleGases = <span class="built_in">Map</span>();</span><br><span class="line">nobleGases[<span class="number">2</span>] = <span class="string">'helium'</span>;</span><br><span class="line">nobleGases[<span class="number">10</span>] = <span class="string">'neon'</span>;</span><br><span class="line">nobleGases[<span class="number">18</span>] = <span class="string">'argon'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>提示: 这里为什么只有 Map() ，而不是使用 new Map()。 因为在 Dart 2 中，new 关键字是可选的。</p></blockquote><p>类似 JavaScript ，添加 key-value 对到已有的 Map 中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">gifts[<span class="string">'fourth'</span>] = <span class="string">'calling birds'</span>; <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure><p>类似 JavaScript ，从一个 Map 中获取一个 value：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">'first'</span>] == <span class="string">'partridge'</span>);</span><br></pre></td></tr></table></figure><p>如果 Map 中不包含所要查找的 key，那么 Map 返回 null：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">'fifth'</span>] == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>使用 .length 函数获取当前 Map 中的 key-value 对数量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">gifts[<span class="string">'fourth'</span>] = <span class="string">'calling birds'</span>;</span><br><span class="line"><span class="keyword">assert</span>(gifts.length == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">'helium'</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">'neon'</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">'argon'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constantMap[2] = 'Helium'; // 取消注释会引起错误。</span></span><br></pre></td></tr></table></figure><h3 id="Rune"><a href="#Rune" class="headerlink" title="Rune"></a>Rune</h3><p>在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。</p><p>Unicode 定义了一个全球的书写系统编码， 系统中使用的所有字母，数字和符号都对应唯一的数值编码。 由于 Dart 字符串是一系列 UTF-16 编码单元， 因此要在字符串中表示32位 Unicode 值需要特殊语法支持。</p><p>表示 Unicode 编码的常用方法是， \uXXXX, 这里 XXXX 是一个4位的16进制数。 例如，心形符号 (♥) 是 \u2665。 对于特殊的非 4 个数值的情况， 把编码值放到大括号中即可。 例如，emoji 的笑脸 (�) 是 \u{1f600}。</p><p>String 类有一些属性可以获得 rune 数据。 属性 codeUnitAt 和 codeUnit 返回16位编码数据。 属性 runes 获取字符串中的 Rune 。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#radix</span><br><span class="line">#bar</span><br></pre></td></tr></table></figure><p>Symbol 字面量是编译时常量。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;Dart-语法-1&quot;&gt;&lt;a href=&quot;#Dart-语法-1&quot; class=&quot;headerlink&quot; title=&quot;Dart 语法(1)&quot;&gt;&lt;/a&gt;Dart 语法(1)&lt;/h1&gt;&lt;h2 id=&quot;一个简单的-Dart-程序&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="Dart" scheme="http://duanyitao.com/categories/Dart/"/>
    
    
      <category term="语法" scheme="http://duanyitao.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Webview Http Https</title>
    <link href="http://duanyitao.com/2020/03/11/Webview-Http-Https/"/>
    <id>http://duanyitao.com/2020/03/11/Webview-Http-Https/</id>
    <published>2020-03-11T03:49:22.000Z</published>
    <updated>2020-03-11T03:53:39.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址： <a href="https://blog.csdn.net/jinshitou2012/article/details/80307428" target="_blank" rel="noopener">https://blog.csdn.net/jinshitou2012/article/details/80307428</a><br><img src="/2020/03/11/Webview-Http-Https/img1.png" alt="img"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://blog.csdn.net/jinshitou2012/article/details/80307428&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Webview" scheme="http://duanyitao.com/tags/Webview/"/>
    
      <category term="HTTP" scheme="http://duanyitao.com/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://duanyitao.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Chronometer 实现倒计时</title>
    <link href="http://duanyitao.com/2020/03/11/%E4%BD%BF%E7%94%A8-Chronometer-%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <id>http://duanyitao.com/2020/03/11/使用-Chronometer-实现倒计时/</id>
    <published>2020-03-11T02:20:10.000Z</published>
    <updated>2020-03-11T02:27:38.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Chronometer-实现倒计时"><a href="#使用-Chronometer-实现倒计时" class="headerlink" title="使用 Chronometer 实现倒计时"></a>使用 Chronometer 实现倒计时</h1><blockquote><p>在实际业务开发的场景中，经常会有要用到倒计时的功能，比如一个广告页面倒计时，比如一个超时自动关闭页面，等这些操作都离不开倒计时的概念。<br>当然，我们完全可以自己去实现一个倒计时逻辑，例如使用 timer ，或者使用 RxJava 等各种定时策略。<br>本文介绍一个比较简单的，系统原生提供的一个组件 <code>Chronometer</code>。</p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Chronometer</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/chronometer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChronoActivity1</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Chronometer chronometer = findViewById(R.id.chronometer);</span><br><span class="line">        chronometer.setOnChronometerTickListener(<span class="keyword">new</span> Chronometer.OnChronometerTickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChronometerTick</span><span class="params">(Chronometer chronometer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">                    chronometer.setText(<span class="string">"0"</span>);</span><br><span class="line">                    chronometer.stop();</span><br><span class="line">                    finish();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    time--;</span><br><span class="line">                    chronometer.setText(time + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        chronometer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得非常简单呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;使用-Chronometer-实现倒计时&quot;&gt;&lt;a href=&quot;#使用-Chronometer-实现倒计时&quot; class=&quot;headerlink&quot; title=&quot;使用 Chronometer 实现倒计时&quot;&gt;&lt;/a&gt;使用 Chronometer
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="倒计时" scheme="http://duanyitao.com/tags/%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>LiveData may lost Data</title>
    <link href="http://duanyitao.com/2019/12/30/LiveData-may-lose-Data/"/>
    <id>http://duanyitao.com/2019/12/30/LiveData-may-lose-Data/</id>
    <published>2019-12-30T09:13:13.000Z</published>
    <updated>2019-12-30T09:27:10.532Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明： 本文翻译自<a href="https://medium.com/@hanyuliu/livedata-may-lose-data-2fffdac57dc9" target="_blank" rel="noopener">Medium 文章</a></p></blockquote><blockquote><p>LiveData可能会丢失数据。在你说“没关系”之前，请检查所有的情况。</p></blockquote><p>LiveData是谷歌的Android架构中最引人注目的明星组件之一。基本上，它是一个可观察的数据持有者，并在观察者处于活动状态时将数据更改发送给观察者。在Android应用程序中，视图通常附加到生命周期感知组件，如片段或活动。然而，生命周期感知组件可能被杀死、重新创建或分离(片段)，这使得访问视图变得危险和复杂。为了使视图层操作更加友好，LiveData向它的观察者引入了生命周期感知。每个观察者可以与一个LifecycleOwner相关联，通常是一个片段或活动，并防止在其LifecycleOwner不活动时将数据更改发送给观察者。此行为可以确保在执行不是“必要的”情况下，观察者中的逻辑不会被执行。例如，如果一个片段正在分离，它的视图将很快被销毁。在分离过程中，这个片段视图上的任何视图层操作都是不可见的，也是不必要的。相反，LiveData缓冲最后的数据更改，并在片段重新连接和重新创建视图时通知观察者，这可以将新视图实例“恢复”到最新状态，并防止潜在的NPE或内存泄漏。<br>但是，由于LiveData在主线程上分发数据，并且只缓冲一个挂起的数据更改，所以您的观察者很少会错过或没有接收到数据更改。尽管谷歌的文档从未将LiveData定义为类似于rxjava的流框架，也没有建议使用LiveData，只是在视图和VM之间建立一个薄薄的粘合层，但我们仍然有必要研究所有可能的数据丢失场景，并避免生产中可能出现的意外行为。在下一节中，我们将通过示例讨论三种数据丢失情况。</p><h2 id="将数据发送到活动状态之外"><a href="#将数据发送到活动状态之外" class="headerlink" title="将数据发送到活动状态之外"></a>将数据发送到活动状态之外</h2><p>LiveData是一个支持生命周期的组件。因此，只有在其LifecycleOwner处于活动状态时，才能将数据更改交付给观察者。如下图所示，当一个LifecycleOwner切换到“STARTED”或“resume”时，它是活动的。因此，LiveData观察者只能在其LifecycleOwner“启动”或“恢复”时接收数据更改更新。如果数据源将数据发送到活动状态之外的LiveData，则观察者将不会接收发送的数据。</p><p><img src="https://miro.medium.com/proxy/1*GKpyv8DQ3qJMKvpGWEVIyw.jpeg" alt="图片"></p><p>假设我们有一个活动，它在其生命周期回调中将数据写入MutableLiveData。一个观察者正在观察MutableLiveData并打印出接收到的数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveGapActivity</span> <span class="title">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static MutableLiveData&lt;String&gt; mutableLiveData = new MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onCreate(<span class="meta">@Nullable</span> Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mutableLiveData.observe(<span class="keyword">this</span>, new Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"ActiveGapActivity Observed: "</span> + string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mutableLiveData.setValue(<span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onResume() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mutableLiveData.setValue(<span class="string">"onResume"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onPause() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mutableLiveData.setValue(<span class="string">"onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onStop() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"ActiveGapActivity onStop called"</span>);</span><br><span class="line">        mutableLiveData.setValue(<span class="string">"onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> void onDestroy() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mutableLiveData.setValue(<span class="string">"onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们旋转app并触发Activity recreation，会打印如下日志:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ActiveGapActivity Observed: onCreate</span><br><span class="line">ActiveGapActivity Observed: onResume</span><br><span class="line">ActiveGapActivity Observed: onPause</span><br><span class="line">ActiveGapActivity onStop called       <span class="tag">&lt;<span class="name">==</span> <span class="attr">onStop</span>() <span class="attr">is</span> <span class="attr">called</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">Observed:</span> <span class="attr">onCreate</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">Observed:</span> <span class="attr">onResume</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">Observed:</span> <span class="attr">onPause</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">onStop</span> <span class="attr">called</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">Observed:</span> <span class="attr">onCreate</span></span></span><br><span class="line"><span class="tag"><span class="attr">ActiveGapActivity</span> <span class="attr">Observed:</span> <span class="attr">onResume</span></span></span><br></pre></td></tr></table></figure><p>如日志所示，观察者没有接收到“onStop”，这肯定是被调用的，因为“ActiveGapActivity onStop调用”被打印出来了。这种行为是由两个LiveData礼:</p><ul><li>LiveData可以缓冲一个数据实例;</li><li>LiveData在其生命周期中不会通知观察者，而cleowner则处于“非活动”状态。</li></ul><p>当我们旋转屏幕时，活动将被重新创建。将顺序调用当前活动实例的onStop()和onDestroy()。但是，由于活动不再活动，发出的数据将不会传递给观察者。而是在内部缓冲最新的数据实例，即“onDestroy”。当活动被重新创建时，第二个活动实例将发出“onCreate”，并覆盖之前的缓冲数据“onDestroy”。一旦活动(即LifecycleOwner)恢复活动，观察者将只接收缓冲的“onCreate”。onStop和onDestroy都丢失了。<br>下图显示了在第二个活动的onCreate()中调用LiveData的setValue函数时的调试信息。显然，新的数据实例“onCreate”覆盖了先前由第一个实例的onDestroy()发出的缓冲数据实例(“mData”)。</p><p><img src="https://miro.medium.com/max/1077/1*OobWCz4qZm6XNHk-PxWP0A.png" alt="图片"></p><h2 id="从后台线程发出数据"><a href="#从后台线程发出数据" class="headerlink" title="从后台线程发出数据"></a>从后台线程发出数据</h2><p>LiveData在主线程上调度数据。如果源从后台线程发出数据，则下游使用者不会立即收到更新。相反，发出的数据将在LiveData中进行缓冲，并等待主线程稍后进行调度。但是，由于LiveData只缓冲一个数据实例，如果数据源发出的数据比主线程分派的数据“更快”。新数据实例可能会覆盖已缓存的数据实例，从而导致数据丢失。<br>让我们来看看下面的例子。在onResume()中启动一个AsyncTask，并向LiveData发送三个数据实例;在“onCreate”中初始化输出数据的观察者。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostValueSampleActivity</span> <span class="title">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        source = new MutableLiveData&lt;&gt;();</span><br><span class="line">        source.observe(<span class="keyword">this</span>, new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> Integer integer) &#123;</span><br><span class="line">                append(integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onResume() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AsyncTask.execute(new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                source.postValue(<span class="number">1</span>);</span><br><span class="line">                source.postValue(<span class="number">2</span>);</span><br><span class="line">                source.postValue(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码将只输出“3”，这是AsyncTask发出的最后一个数据。这个输出背后的魔力可以在LiveData的源代码中找到。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> void postValue(T value) &#123;</span><br><span class="line">      boolean postTask;</span><br><span class="line">      synchronized (mDataLock) &#123;</span><br><span class="line">          postTask = mPendingData == NOT_SET;</span><br><span class="line">          mPendingData = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!postTask) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当一个后台线程向LiveData发送数据时，LiveData会将一个标记、postTask标记为true;发布一个runnable到主线程，将数据更改发送给观察者。如果后台线程发出数据“太频繁”(在主线程可运行完成之前)，新发布的数据将覆盖“mPendingData”。当主thead执行runnable并尝试分发数据更改时，它将获得最后的数据，即“mPendingData”保存的数据。</p><h2 id="在观察者中发射数据"><a href="#在观察者中发射数据" class="headerlink" title="在观察者中发射数据"></a>在观察者中发射数据</h2><p>由于LiveData在主线程上调度数据，所以在调度已经启动时，所有的事情都是(某种程度上)同步的。所有观察者将被迭代，并依次接收更新。但是，如果在观察者内部设置新的数据更改，则新的数据更改(我们称之为“B”)将覆盖当前正在调度的数据更改(我们称之为“A”)并终止当前调度周期。一些观察者可能不会永远得到“A”。<br>假设有两个观察者。观察者2打印接收到的内容，但是如果接收到的数字是偶数，观察者1将把新值设置回LiveData。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetValueSampleActivity</span> <span class="title">extends</span> <span class="title">BaseActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;Integer&gt; source;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        source = new MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        source.observe(<span class="keyword">this</span>, new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> Integer integer) &#123;</span><br><span class="line">                append(<span class="string">"Receiver 1: "</span> + integer.toString());</span><br><span class="line">                <span class="keyword">if</span> (integer % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    source.setValue(integer * <span class="number">10</span>);</span><br><span class="line">                    source.setValue(integer * <span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        source.observe(<span class="keyword">this</span>, new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void onChanged(<span class="meta">@Nullable</span> Integer integer) &#123;</span><br><span class="line">                append(<span class="string">"Receiver 2: "</span> + integer.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onResume() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">        source.setValue(<span class="number">1</span>);</span><br><span class="line">        source.setValue(<span class="number">2</span>);</span><br><span class="line">        source.setValue(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例的输出如下图所示。观察者1收到1 2 21 3，观察者2收到1 21 3。</p><p><img src="https://miro.medium.com/max/1078/1*QLCjpBsQ_DezOpQIEbI4PQ.png" alt="图片"></p><p>这种行为背后的原因有点复杂。让我们检查LiveData中的“dispatchingValue()”函数。从第2行到第6行可以看出，如果调度已经启动，任何新的数据集都不会启动另一个调度循环。相反，新的数据更改将覆盖挂起的数据(在setValue()函数中)，将“mDispatchInvalidated”设置为true并跳过(从第2行到第5行)。在我们的示例中，当观察者1接收到“2”时，它将“20”和“21”设置回LiveData。因为“mDispatchingValue”为真，所以“20”将不会被分派，而是被“21”覆盖。观察者1的逻辑完成后，由于“mDispatchInvalidated”为真，它将中断当前调度循环(从第13行到第19行，并停止观察者2接收“2”)，并使外部while循环再运行一次(从第7行到第21行)。在这个调度循环中，所有的观察者接收最后的数据“21”。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void dispatchingValue(<span class="meta">@Nullable</span> ObserverWrapper initiator) &#123;</span><br><span class="line">       <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">           mDispatchInvalidated = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       mDispatchingValue = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           mDispatchInvalidated = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (initiator != <span class="literal">null</span>) &#123;</span><br><span class="line">               considerNotify(initiator);</span><br><span class="line">               initiator = <span class="literal">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                       mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                   considerNotify(iterator.next().getValue());</span><br><span class="line">                   <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">       mDispatchingValue = <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>github code↓↓<br><a href="https://github.com/hanyuliu/livedata_may_lose_data" target="_blank" rel="noopener">https://github.com/hanyuliu/livedata_may_lose_data</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;声明： 本文翻译自&lt;a href=&quot;https://medium.com/@hanyuliu/livedata-may-lose-data-2fffdac57dc9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Medium
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="LiveData" scheme="http://duanyitao.com/tags/LiveData/"/>
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>HTML 基础</title>
    <link href="http://duanyitao.com/2019/06/22/HTML-%E5%9F%BA%E7%A1%80/"/>
    <id>http://duanyitao.com/2019/06/22/HTML-基础/</id>
    <published>2019-06-22T02:53:53.000Z</published>
    <updated>2019-06-22T04:22:38.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-基本结构"><a href="#HTML-基本结构" class="headerlink" title="HTML 基本结构"></a>HTML 基本结构</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    网页主体内容</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>&lt;标签&gt;&lt;/标签&gt;</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>“&lt;html&gt;&lt;/html&gt;”</p></blockquote><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>用 ‘&lt;’ 和 ‘&gt;’ 括起来</li><li>一般成对出现，分为开始标签和结束标签</li><li>结束标签比开始标签多了个 ‘/‘</li><li>单标签没有结束标签，如 “&lt;hr/&gt;”</li></ul><h1 id="HTML-元素"><a href="#HTML-元素" class="headerlink" title="HTML 元素"></a>HTML 元素</h1><p>从<em>开始标签</em> 到<em>结束标签</em> 的所有代码，称为 <em>HTML 元素</em>。</p><h1 id="HTML-属性"><a href="#HTML-属性" class="headerlink" title="HTML 属性"></a>HTML 属性</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>&lt;标签名 属性名1=”值” 属性名2=”值” 属性名3=”值” &gt;……&lt;/标签名&gt;</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>语法：&lt;!– 注释 –&gt;</p><h1 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h1><p>&lt;!DOCTYPE html&gt; 必须放在文档第一行。</p><h1 id="网页编码设置"><a href="#网页编码设置" class="headerlink" title="网页编码设置"></a>网页编码设置</h1><p>&lt;meta http-equiv=”Content-Type” content=”text/html;charset-utf8”&gt;</p><h1 id="文字和段落"><a href="#文字和段落" class="headerlink" title="文字和段落"></a>文字和段落</h1><ul><li>标题：h1 - h6</li><li>段落：p<ul><li>align 属性：<ul><li>left</li><li>center</li><li>right</li><li>justify</li></ul></li></ul></li><li>换行：br</li><li>水平线：hr<ul><li>width<ul><li>px</li><li>persent</li></ul></li><li>color<ul><li>rgb</li><li>hex</li><li>name<ul><li>black</li><li>red</li><li>…</li></ul></li></ul></li><li>align</li><li>noshade</li></ul></li><li>i/em</li><li>b/strong</li><li>sub</li><li>sup</li><li>ins</li><li>del</li></ul><h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><ul><li>&lt; <em>-&gt;</em> <code>&amp;lt;</code></li><li>&gt; <em>-&gt;</em> <code>&amp;gt;</code></li><li>&reg; <em>-&gt;</em> <code>&amp;reg;</code></li><li>&copy; <em>-&gt;</em> <code>&amp;copy;</code></li><li>&trade; <em>-&gt;</em> <code>&amp;trade;</code></li><li>空格 <em>-&gt;</em> <code>&amp;nbsp;</code></li></ul><h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><ul><li><p>无序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>有序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>定义列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">..</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">htef</span>=<span class="string">""</span> &gt;</span>内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;HTML-基本结构&quot;&gt;&lt;a href=&quot;#HTML-基本结构&quot; class=&quot;headerlink&quot; title=&quot;HTML 基本结构&quot;&gt;&lt;/a&gt;HTML 基本结构&lt;/h1&gt;&lt;figure class=&quot;highlight
        
      
    
    </summary>
    
      <category term="Web" scheme="http://duanyitao.com/categories/Web/"/>
    
    
      <category term="HTML" scheme="http://duanyitao.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Koin with ViewModel</title>
    <link href="http://duanyitao.com/2019/04/25/Koin-with-ViewModel/"/>
    <id>http://duanyitao.com/2019/04/25/Koin-with-ViewModel/</id>
    <published>2019-04-25T08:29:57.000Z</published>
    <updated>2019-04-25T10:08:19.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Architecture-Components-with-Koin-ViewModel"><a href="#Architecture-Components-with-Koin-ViewModel" class="headerlink" title="Architecture Components with Koin: ViewModel"></a>Architecture Components with Koin: ViewModel</h2><h3 id="Gradle-setup"><a href="#Gradle-setup" class="headerlink" title="Gradle setup"></a>Gradle setup</h3><p>Choose the koin-android-viewmodel dependency to add to your Gradle project (android or androix version):</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add Jcenter to your repositories if needed</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// ViewModel for Android</span></span><br><span class="line">    implementation <span class="string">'org.koin:koin-android-viewmodel:2.0.0-beta-4'</span></span><br><span class="line">    <span class="comment">// or ViewModel for AndroidX</span></span><br><span class="line">    implementation <span class="string">'org.koin:koin-androidx-viewmodel:2.0.0-beta-4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel-DSL"><a href="#ViewModel-DSL" class="headerlink" title="ViewModel DSL"></a>ViewModel DSL</h3><p>The koin-android-viewmodel introduces a new viewModel DSL keyword that comes in complement of single and factory, to help declare a ViewModel component and bind it to an Android Component lifecycle.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel for Detail View</span></span><br><span class="line">    viewModel &#123; DetailViewModel(<span class="keyword">get</span>(), <span class="keyword">get</span>()) &#125;</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    viewModel&lt;DetailViewModel&gt;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your declared component must at least extends the android.arch.lifecycle.ViewModel class. You can specify how you inject the constructor of the class and use the get() function to inject dependencies.</p><blockquote><p>The viewModel keyword helps declaring a factory instance of ViewModel. This instance will be handled by internal ViewModelFactory and reattach ViewModel instance if needed.</p></blockquote><blockquote><p>The viewModel keyword can also let you use the injection parameters.</p></blockquote><h3 id="Injecting-your-ViewModel"><a href="#Injecting-your-ViewModel" class="headerlink" title="Injecting your ViewModel"></a>Injecting your ViewModel</h3><p>To inject a ViewModel in an Activity, Fragment or Service use:</p><ul><li><p><strong>by viewModel()</strong> - lazy delegate property to inject a ViewModel into a property</p></li><li><p><strong>getViewModel()</strong> - directly get the ViewModel instance</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy inject ViewModel</span></span><br><span class="line">    <span class="keyword">val</span> detailViewModel: DetailViewModel <span class="keyword">by</span> viewModel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shared-ViewModel"><a href="#Shared-ViewModel" class="headerlink" title="Shared ViewModel"></a>Shared ViewModel</h3><p>One ViewModel instance can be shared between Fragments and their host Activity.</p><p>To inject a shared ViewModel in a Fragment use:</p><ul><li><p><strong>by sharedViewModel()</strong> - lazy delegate property to inject shared ViewModel instance into a property</p></li><li><p><strong>getSharedViewModel()</strong> - directly get the shared ViewModel instance</p></li></ul><p>Just declare the ViewModel only once:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> weatherAppModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WeatherViewModel declaration for Weather View components</span></span><br><span class="line">    viewModel &#123; WeatherViewModel(<span class="keyword">get</span>(), <span class="keyword">get</span>()) &#125;</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    viewModel&lt;WeatherViewModel&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And reuse it in Activity and Fragments:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Declare WeatherViewModel with Koin and allow constructor dependency injection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> weatherViewModel <span class="keyword">by</span> viewModel&lt;WeatherViewModel&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherHeaderFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Declare shared WeatherViewModel with WeatherActivity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> weatherViewModel <span class="keyword">by</span> sharedViewModel&lt;WeatherViewModel&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherListFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Declare shared WeatherViewModel with WeatherActivity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> weatherViewModel <span class="keyword">by</span> sharedViewModel&lt;WeatherViewModel&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewModel-and-injection-parameters"><a href="#ViewModel-and-injection-parameters" class="headerlink" title="ViewModel and injection parameters"></a>ViewModel and injection parameters</h3><p>the viewModel keyword and injection API is compatible with injection parameters.</p><p>In the module:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appModule = module &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewModel for Detail View with id as parameter injection</span></span><br><span class="line">    viewModel &#123; (id : String) -&gt; DetailViewModel(id, <span class="keyword">get</span>(), <span class="keyword">get</span>()) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From the injection call site:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id : String <span class="comment">// id of the view</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazy inject ViewModel with id parameter</span></span><br><span class="line">    <span class="keyword">val</span> detailViewModel: DetailViewModel <span class="keyword">by</span> viewModel&#123; parametersOf(id)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>that’s all, thanks for your reading.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Architecture-Components-with-Koin-ViewModel&quot;&gt;&lt;a href=&quot;#Architecture-Components-with-Koin-ViewModel&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="MVVM" scheme="http://duanyitao.com/tags/MVVM/"/>
    
      <category term="Koin" scheme="http://duanyitao.com/tags/Koin/"/>
    
  </entry>
  
  <entry>
    <title>Groovy Syntax</title>
    <link href="http://duanyitao.com/2019/04/23/Groovy-Syntax/"/>
    <id>http://duanyitao.com/2019/04/23/Groovy-Syntax/</id>
    <published>2019-04-23T07:09:10.000Z</published>
    <updated>2019-04-23T10:21:07.570Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reference: <a href="http://groovy-lang.org/syntax.html" target="_blank" rel="noopener">Apache Groovy</a><br>This chapter covers the syntax of the Groovy programming language. The grammar of the language derives from the Java grammar, but enhances it with specific constructs for Groovy, and allows certain simplifications.</p></blockquote><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h2><h3 id="Single-line-comment"><a href="#Single-line-comment" class="headerlink" title="Single line comment"></a>Single line comment</h3><p>Single line comments start with // and can be found at any position in the line. The characters following //, till the end of the line, are considered part of the comment.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a standalone single line comment</span></span><br><span class="line">println <span class="string">"hello"</span> <span class="comment">// a comment till the end of the line</span></span><br></pre></td></tr></table></figure><h3 id="Multiline-comment"><a href="#Multiline-comment" class="headerlink" title="Multiline comment"></a>Multiline comment</h3><p>A multiline comment starts with /<em> and can be found at any position in the line. The characters following /</em> will be considered part of the comment, including new line characters, up to the first */ closing the comment. Multiline comments can thus be put at the end of a statement, or even inside a statement.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a standalone multiline comment</span></span><br><span class="line"><span class="comment">   spanning two lines */</span></span><br><span class="line">println <span class="string">"hello"</span> <span class="comment">/* a multiline comment starting</span></span><br><span class="line"><span class="comment">                   at the end of a statement */</span></span><br><span class="line">println <span class="number">1</span> <span class="comment">/* one */</span> + <span class="number">2</span> <span class="comment">/* two */</span></span><br></pre></td></tr></table></figure><h3 id="GroovyDoc-comment"><a href="#GroovyDoc-comment" class="headerlink" title="GroovyDoc comment"></a>GroovyDoc comment</h3><p>Similarly to multiline comments, GroovyDoc comments are multiline, but start with /*<em> and end with </em>/. Lines following the first GroovyDoc comment line can optionally start with a star *. Those comments are associated with:</p><ul><li>type definitions (classes, interfaces, enums, annotations),</li><li>fields and properties definitions</li><li>methods definitions</li></ul><p>Although the compiler will not complain about GroovyDoc comments not being associated with the above language elements, you should prepend those constructs with the comment right before it.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Class description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">/** the name of the person */</span></span><br><span class="line">    String name</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a greeting method for a certain person.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> otherPerson the person to greet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a greeting message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String greet(String otherPerson) &#123;</span><br><span class="line">       <span class="string">"Hello $&#123;otherPerson&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GroovyDoc follows the same conventions as Java’s own JavaDoc. So you’ll be able to use the same tags as with JavaDoc.</p><h3 id="Shebang-line"><a href="#Shebang-line" class="headerlink" title="Shebang line"></a>Shebang line</h3><p>Beside the single line comment, there is a special line comment, often called the shebang line understood by UNIX systems which allows scripts to be run directly from the command-line, provided you have installed the Groovy distribution and the groovy command is available on the PATH.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env groovy</span></span><br><span class="line">println <span class="string">"Hello from the shebang line"</span></span><br></pre></td></tr></table></figure><p>The # character must be the first character of the file. Any indentation would yield a compilation error.</p><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>The following list represents all the keywords of the Groovy language:</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>as</td><td>assert</td><td>catch</td><td>class</td></tr><tr><td>break</td><td>case</td><td>const</td><td>continue</td></tr><tr><td>const</td><td>continue</td><td>def</td><td>default</td></tr><tr><td>do</td><td>else</td><td>enum</td><td>extends</td></tr><tr><td>false</td><td>finally</td><td>for</td><td>goto</td></tr><tr><td>if</td><td>implements</td><td>import</td><td>in</td></tr><tr><td>instanceof</td><td>interface</td><td>new</td><td>null</td></tr><tr><td>package</td><td>return</td><td>super</td><td>switch</td></tr><tr><td>this</td><td>throw</td><td>throws</td><td>trait</td></tr><tr><td>true</td><td>try</td><td>while</td></tr></tbody></table><h2 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h2><h3 id="Normal-identifiers"><a href="#Normal-identifiers" class="headerlink" title="Normal identifiers"></a>Normal identifiers</h3><p>Identifiers start with a letter, a dollar or an underscore. They cannot start with a number.</p><p>A letter can be in the following ranges:</p><ul><li>‘a’ to ‘z’ (lowercase ascii letter)</li><li>‘A’ to ‘Z’ (uppercase ascii letter)</li><li>‘\u00C0’ to ‘\u00D6’</li><li>‘\u00D8’ to ‘\u00F6’</li><li>‘\u00F8’ to ‘\u00FF’</li><li>‘\u0100’ to ‘\uFFFE’</li></ul><p>Then following characters can contain letters and numbers.</p><p>Here are a few examples of valid identifiers (here, variable names):</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name</span><br><span class="line"><span class="keyword">def</span> item3</span><br><span class="line"><span class="keyword">def</span> with_underscore</span><br><span class="line"><span class="keyword">def</span> $dollarStart</span><br></pre></td></tr></table></figure><p>But the following ones are invalid identifiers:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="number">3</span>tier</span><br><span class="line"><span class="keyword">def</span> a+b</span><br><span class="line">def a#b</span><br></pre></td></tr></table></figure><p>All keywords are also valid identifiers when following a dot:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo.<span class="keyword">as</span></span><br><span class="line">foo.<span class="keyword">assert</span></span><br><span class="line">foo.<span class="keyword">break</span></span><br><span class="line">foo.<span class="keyword">case</span></span><br><span class="line">foo.<span class="keyword">catch</span></span><br></pre></td></tr></table></figure><h3 id="Quoted-identifiers"><a href="#Quoted-identifiers" class="headerlink" title="Quoted identifiers"></a>Quoted identifiers</h3><p>Quoted identifiers appear after the dot of a dotted expression. For instance, the <code>name</code> part of the <code>person.name</code> expression can be quoted with <code>person.&quot;name&quot;</code> or <code>person.&#39;name&#39;</code>. This is particularly interesting when certain identifiers contain illegal characters that are forbidden by the Java Language Specification, but which are allowed by Groovy when quoted. For example, characters like a dash, a space, an exclamation mark, etc.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [:]</span><br><span class="line"></span><br><span class="line">map.<span class="string">"an identifier with a space and double quotes"</span> = <span class="string">"ALLOWED"</span></span><br><span class="line">map.<span class="string">'with-dash-signs-and-single-quotes'</span> = <span class="string">"ALLOWED"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">"an identifier with a space and double quotes"</span> == <span class="string">"ALLOWED"</span></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">'with-dash-signs-and-single-quotes'</span> == <span class="string">"ALLOWED"</span></span><br></pre></td></tr></table></figure><p>As we shall see in the following section on strings, Groovy provides different string literals. All kind of strings are actually allowed after the dot:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="string">'single quote'</span></span><br><span class="line">map.<span class="string">"double quote"</span></span><br><span class="line">map.<span class="string">'''triple single quote'''</span></span><br><span class="line">map.<span class="string">"""triple double quote"""</span></span><br><span class="line">map.<span class="regexp">/slashy string/</span></span><br><span class="line">map.<span class="string">$/dollar slashy string/$</span></span><br></pre></td></tr></table></figure><p>There’s a difference between plain character strings and Groovy’s GStrings (interpolated strings), as in that the latter case, the interpolated values are inserted in the final string for evaluating the whole identifier:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> firstname = <span class="string">"Homer"</span></span><br><span class="line">map.<span class="string">"Simpson-$&#123;firstname&#125;"</span> = <span class="string">"Homer Simpson"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> map.<span class="string">'Simpson-Homer'</span> == <span class="string">"Homer Simpson"</span></span><br></pre></td></tr></table></figure><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>Text literals are represented in the form of chain of characters called strings. Groovy lets you instantiate java.lang.String objects, as well as GStrings (groovy.lang.GString) which are also called interpolated strings in other programming languages.</p><h3 id="Single-quoted-string"><a href="#Single-quoted-string" class="headerlink" title="Single quoted string"></a>Single quoted string</h3><p>Single quoted strings are a series of characters surrounded by single quotes:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a single quoted string'</span></span><br></pre></td></tr></table></figure><p>Single quoted strings are plain java.lang.String and don’t support interpolation.</p><h3 id="String-concatenation"><a href="#String-concatenation" class="headerlink" title="String concatenation"></a>String concatenation</h3><p>All the Groovy strings can be concatenated with the + operator:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">'ab'</span> == <span class="string">'a'</span> + <span class="string">'b'</span></span><br></pre></td></tr></table></figure><h3 id="Triple-single-quoted-string"><a href="#Triple-single-quoted-string" class="headerlink" title="Triple single quoted string"></a>Triple single quoted string</h3><p>Triple single quoted strings are a series of characters surrounded by triplets of single quotes:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Triple single quoted strings are a series of characters surrounded by triplets of single <span class="string">quotes:</span></span><br></pre></td></tr></table></figure><p>Triple single quoted strings are plain java.lang.String and don’t support interpolation.</p><p>Triple single quoted strings are multiline. You can span the content of the string across line boundaries without the need to split the string in several pieces, without contatenation or newline escape characters:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> aMultilineString = <span class="string">'''line one</span></span><br><span class="line"><span class="string">line two</span></span><br><span class="line"><span class="string">line three'''</span></span><br></pre></td></tr></table></figure><p>If your code is indented, for example in the body of the method of a class, your string will contain the whitespace of the indentation. The Groovy Development Kit contains methods for stripping out the indentation with the String#stripIndent() method, and with the String#stripMargin() method that takes a delimiter character to identify the text to remove from the beginning of a string.</p><p>When creating a string as follows:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> startingAndEndingWithANewline = <span class="string">'''</span></span><br><span class="line"><span class="string">line one</span></span><br><span class="line"><span class="string">line two</span></span><br><span class="line"><span class="string">line three</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>You will notice that the resulting string contains a newline character as first character. It is possible to strip that character by escaping the newline with a backslash:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> strippedFirstNewline = <span class="string">'''\</span></span><br><span class="line"><span class="string">line one</span></span><br><span class="line"><span class="string">line two</span></span><br><span class="line"><span class="string">line three</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> !strippedFirstNewline.startsWith(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h3 id="Escaping-special-characters"><a href="#Escaping-special-characters" class="headerlink" title="Escaping special characters"></a>Escaping special characters</h3><p>You can escape single quotes with the the backslash character to avoid terminating the string literal:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'an escaped single quote: \' needs a backslash'</span></span><br></pre></td></tr></table></figure><p>And you can escape the escape character itself with a double backslash:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'an escaped escape character: \\ needs a double backslash'</span></span><br></pre></td></tr></table></figure><p>Some special characters also use the backslash as escape character:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>‘\t’</td><td>tabulation</td></tr><tr><td>‘\b’</td><td>backspace</td></tr><tr><td>‘\n’</td><td>newline</td></tr><tr><td>‘\r’</td><td>carriage return</td></tr><tr><td>‘\f’</td><td>formfeed</td></tr><tr><td>‘\‘</td><td>backslash</td></tr><tr><td>‘\’’</td><td>single quote (for single quoted and triple single quoted strings)</td></tr><tr><td>‘\”‘</td><td>double quote (for double quoted and triple double quoted strings)</td></tr></tbody></table><h3 id="Unicode-escape-sequence"><a href="#Unicode-escape-sequence" class="headerlink" title="Unicode escape sequence"></a>Unicode escape sequence</h3><p>For characters that are not present on your keyboard, you can use unicode escape sequences: a backslash, followed by ‘u’, then 4 hexadecimal digits.</p><p>For example, the Euro currency symbol can be represented with:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'The Euro currency symbol: \u20AC'</span></span><br></pre></td></tr></table></figure><h3 id="Double-quoted-string"><a href="#Double-quoted-string" class="headerlink" title="Double quoted string"></a>Double quoted string</h3><p>Double quoted strings are a series of characters surrounded by double quotes:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a double quoted string"</span></span><br></pre></td></tr></table></figure><p>Double quoted strings are plain java.lang.String if there’s no interpolated expression, but are groovy.lang.GString instances if interpolation is present.</p><p>To escape a double quote, you can use the backslash character: “A double quote: \””.</p><h3 id="String-interpolation"><a href="#String-interpolation" class="headerlink" title="String interpolation"></a>String interpolation</h3><p>Any Groovy expression can be interpolated in all string literals, apart from single and triple single quoted strings. Interpolation is the act of replacing a placeholder in the string with its value upon evaluation of the string. The placeholder expressions are surrounded by ${} or prefixed with $ for dotted expressions. The expression value inside the placeholder is evaluated to its string representation when the GString is passed to a method taking a String as argument by calling toString() on that expression.</p><p>Here, we have a string with a placeholder referencing a local variable:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name = <span class="string">'Guillaume'</span> <span class="comment">// a plain string</span></span><br><span class="line"><span class="keyword">def</span> greeting = <span class="string">"Hello $&#123;name&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> greeting.toString() == <span class="string">'Hello Guillaume'</span></span><br></pre></td></tr></table></figure><p>But any Groovy expression is valid, as we can see in this example with an arithmetic expression:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sum = <span class="string">"The sum of 2 and 3 equals $&#123;2 + 3&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> sum.toString() == <span class="string">'The sum of 2 and 3 equals 5'</span></span><br></pre></td></tr></table></figure><p>Not only are expressions allowed in between the ${} placeholder, but so are statements. However, a statement’s value is just null. So if several statements are inserted in that placeholder, the last one should somehow return a meaningful value to be inserted. For instance, “The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}” is supported and works as expected but a good practice is usually to stick to simple expressions inside GString placeholders.</p><p>In addition to ${} placeholders, we can also use a lone $ sign prefixing a dotted expression:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> person = [<span class="string">name:</span> <span class="string">'Guillaume'</span>, <span class="string">age:</span> <span class="number">36</span>]</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"$person.name is $person.age years old"</span> == <span class="string">'Guillaume is 36 years old'</span></span><br></pre></td></tr></table></figure><p>But only dotted expressions of the form a.b, a.b.c, etc, are valid, but expressions that would contain parentheses like method calls, curly braces for closures, or arithmetic operators would be invalid. Given the following variable definition of a number:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> number = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>The following statement will throw a groovy.lang.MissingPropertyException because Groovy believes you’re trying to access the toString property of that number, which doesn’t exist:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldFail(MissingPropertyException) &#123;</span><br><span class="line">    println <span class="string">"$number.toString()"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can think of “$number.toString()” as being interpreted by the parser as “${number.toString()}”.</p><p>If you need to escape the $ or ${} placeholders in a GString so they appear as is without interpolation, you just need to use a \ backslash character to escape the dollar sign:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">'$&#123;name&#125;'</span> == <span class="string">"\$&#123;name&#125;"</span></span><br></pre></td></tr></table></figure><h3 id="Special-case-of-interpolating-closure-expressions"><a href="#Special-case-of-interpolating-closure-expressions" class="headerlink" title="Special case of interpolating closure expressions"></a>Special case of interpolating closure expressions</h3><p>So far, we’ve seen we could interpolate arbitrary expressions inside the ${} placeholder, but there is a special case and notation for closure expressions. When the placeholder contains an arrow, ${→}, the expression is actually a closure expression — you can think of it as a closure with a dollar prepended in front of it:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> sParameterLessClosure = <span class="string">"1 + 2 == $&#123;-&gt; 3&#125;"</span> ①</span><br><span class="line"><span class="keyword">assert</span> sParameterLessClosure == <span class="string">'1 + 2 == 3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> sOneParamClosure = <span class="string">"1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;"</span> ②</span><br><span class="line"><span class="keyword">assert</span> sOneParamClosure == <span class="string">'1 + 2 == 3'</span></span><br></pre></td></tr></table></figure><p>① The closure is a parameterless closure which doesn’t take arguments.</p><p>② Here, the closure takes a single java.io.StringWriter argument, to which you can append content with the &lt;&lt; leftShift operator. In either case, both placeholders are embedded closures.</p><p>In appearance, it looks like a more verbose way of defining expressions to be interpolated, but closures have an interesting advantage over mere expressions: lazy evaluation.</p><p>Let’s consider the following sample:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> number = <span class="number">1</span> ①</span><br><span class="line"><span class="keyword">def</span> eagerGString = <span class="string">"value == $&#123;number&#125;"</span></span><br><span class="line"><span class="keyword">def</span> lazyGString = <span class="string">"value == $&#123; -&gt; number &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> eagerGString == <span class="string">"value == 1"</span> ②</span><br><span class="line"><span class="keyword">assert</span> lazyGString ==  <span class="string">"value == 1"</span> ③</span><br><span class="line"></span><br><span class="line">number = <span class="number">2</span> ④</span><br><span class="line"><span class="keyword">assert</span> eagerGString == <span class="string">"value == 1"</span> ⑤</span><br><span class="line"><span class="keyword">assert</span> lazyGString ==  <span class="string">"value == 2"</span> ⑥</span><br></pre></td></tr></table></figure><p>① We define a number variable containing 1 that we then interpolate within two GStrings, as an expression in eagerGString and as a closure in lazyGString.</p><p>② We expect the resulting string to contain the same string value of 1 for eagerGString.</p><p>③ Similarly for lazyGString</p><p>④ Then we change the value of the variable to a new number</p><p>⑤ With a plain interpolated expression, the value was actually bound at the time of creation of the GString.</p><p>⑥ But with a closure expression, the closure is called upon each coercion of the GString into String, resulting in an updated string containing the new number value.</p><p>An embedded closure expression taking more than one parameter will generate an exception at runtime. Only closures with zero or one parameters are allowed.</p><h3 id="Interoperability-with-Java"><a href="#Interoperability-with-Java" class="headerlink" title="Interoperability with Java"></a>Interoperability with Java</h3><p>When a method (whether implemented in Java or Groovy) expects a java.lang.String, but we pass a groovy.lang.GString instance, the toString() method of the GString is automatically and transparently called.</p><p>String takeString(String message) { ④<br>    assert message instanceof String ⑤<br>    return message<br>}</p><p>def message = “The message is ${‘hello’}” ①<br>assert message instanceof GString ②</p><p>def result = takeString(message) ③<br>assert result instanceof String<br>assert result == ‘The message is hello’</p><p>① We create a GString variable</p><p>② We double check it’s an instance of the GString</p><p>③ We then pass that GString to a method taking a String as parameter</p><p>④ The signature of the takeString() method explicitly says its sole parameter is a String</p><p>⑤ We also verify that the parameter is indeed a String and not a GString.</p><h3 id="GString-and-String-hashCodes"><a href="#GString-and-String-hashCodes" class="headerlink" title="GString and String hashCodes"></a>GString and String hashCodes</h3><p>Although interpolated strings can be used in lieu of plain Java strings, they differ with strings in a particular way: their hashCodes are different. Plain Java strings are immutable, whereas the resulting String representation of a GString can vary, depending on its interpolated values. Even for the same resulting string, GStrings and Strings don’t have the same hashCode.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">"one: $&#123;1&#125;"</span>.hashCode() != <span class="string">"one: 1"</span>.hashCode()</span><br></pre></td></tr></table></figure><p>GString and Strings having different hashCode values, using GString as Map keys should be avoided, especially if we try to retrieve an associated value with a String instead of a GString.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> key = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">def</span> m = [<span class="string">"$&#123;key&#125;"</span>: <span class="string">"letter $&#123;key&#125;"</span>] ①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> m[<span class="string">"a"</span>] == <span class="literal">null</span> ②</span><br></pre></td></tr></table></figure><p>① The map is created with an initial pair whose key is a GString</p><p>② When we try to fetch the value with a String key, we will not find it, as Strings and GString have different hashCode values</p><h3 id="Triple-double-quoted-string"><a href="#Triple-double-quoted-string" class="headerlink" title="Triple double quoted string"></a>Triple double quoted string</h3><p>Triple double quoted strings behave like double quoted strings, with the addition that they are multiline, like the triple single quoted strings.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name = <span class="string">'Groovy'</span></span><br><span class="line"><span class="keyword">def</span> template = <span class="string">"""</span></span><br><span class="line"><span class="string">    Dear Mr $&#123;name&#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You're the winner of the lottery!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Yours sincerly,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Dave</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> template.toString().contains(<span class="string">'Groovy'</span>)</span><br></pre></td></tr></table></figure><p>Neither double quotes nor single quotes need be escaped in triple double quoted strings.</p><h3 id="Slashy-string"><a href="#Slashy-string" class="headerlink" title="Slashy string"></a>Slashy string</h3><p>Beyond the usual quoted strings, Groovy offers slashy strings, which use / as delimiters. Slashy strings are particularly useful for defining regular expressions and patterns, as there is no need to escape backslashes.</p><p>Example of a slashy string:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> fooPattern = <span class="regexp">/.*foo.*/</span></span><br><span class="line"><span class="keyword">assert</span> fooPattern == <span class="string">'.*foo.*'</span></span><br></pre></td></tr></table></figure><p>Only forward slashes need to be escaped with a backslash:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> escapeSlash = <span class="regexp">/The character \/</span> is a forward slash/</span><br><span class="line"><span class="keyword">assert</span> escapeSlash == <span class="string">'The character / is a forward slash'</span></span><br></pre></td></tr></table></figure><p>Slashy strings are multiline:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> multilineSlashy = /one</span><br><span class="line">    two</span><br><span class="line">    three/</span><br><span class="line"><span class="keyword">assert</span> multilineSlashy.contains(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>Slashy strings can also be interpolated (ie. a GString):</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> color = <span class="string">'blue'</span></span><br><span class="line"><span class="keyword">def</span> interpolatedSlashy = <span class="regexp">/a $&#123;color&#125; car/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> interpolatedSlashy == <span class="string">'a blue car'</span></span><br></pre></td></tr></table></figure><p>There are a few gotchas to be aware of.</p><p>An empty slashy string cannot be represented with a double forward slash, as it’s understood by the Groovy parser as a line comment. That’s why the following assert would actually not compile as it would look like a non-terminated statement:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="string">''</span> == <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>As slashy strings were mostly designed to make regexp easier so a few things that are errors in GStrings like $() will work with slashy strings.</p><h3 id="Dollar-slashy-string"><a href="#Dollar-slashy-string" class="headerlink" title="Dollar slashy string"></a>Dollar slashy string</h3><p>Dollar slashy strings are multiline GStrings delimited with an opening $/ and and a closing /$. The escaping character is the dollar sign, and it can escape another dollar, or a forward slash. But both dollar and forward slashes don’t need to be escaped, except to escape the dollar of a string subsequence that would start like a GString placeholder sequence, or if you need to escape a sequence that would start like a closing dollar slashy string delimiter.</p><p>Here’s an example:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name = <span class="string">"Guillaume"</span></span><br><span class="line"><span class="keyword">def</span> date = <span class="string">"April, 1st"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> dollarSlashy = <span class="string">$/</span></span><br><span class="line"><span class="string">    Hello $name,</span></span><br><span class="line"><span class="string">    today we're $&#123;date&#125;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    $ dollar sign</span></span><br><span class="line"><span class="string">    $$ escaped dollar sign</span></span><br><span class="line"><span class="string">    \ backslash</span></span><br><span class="line"><span class="string">    / forward slash</span></span><br><span class="line"><span class="string">    $/ escaped forward slash</span></span><br><span class="line"><span class="string">    $$$/ escaped opening dollar slashy</span></span><br><span class="line"><span class="string">    $/$</span>$ escaped closing dollar slashy</span><br><span class="line">/$</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> [</span><br><span class="line">    <span class="string">'Guillaume'</span>,</span><br><span class="line">    <span class="string">'April, 1st'</span>,</span><br><span class="line">    <span class="string">'$ dollar sign'</span>,</span><br><span class="line">    <span class="string">'$ escaped dollar sign'</span>,</span><br><span class="line">    <span class="string">'\\ backslash'</span>,</span><br><span class="line">    <span class="string">'/ forward slash'</span>,</span><br><span class="line">    <span class="string">'/ escaped forward slash'</span>,</span><br><span class="line">    <span class="string">'$/ escaped opening dollar slashy'</span>,</span><br><span class="line">    <span class="string">'/$ escaped closing dollar slashy'</span></span><br><span class="line">].every &#123; dollarSlashy.contains(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="String-summary-table"><a href="#String-summary-table" class="headerlink" title="String summary table"></a>String summary table</h3><table><thead><tr><th>String name</th><th>String syntax</th><th>Interpolated</th><th>Multiline</th><th>Escape character</th></tr></thead><tbody><tr><td>Single quoted</td><td>‘…​’</td><td></td><td></td><td>\</td></tr><tr><td>Triple single quoted</td><td>‘’’…​’’’</td><td></td><td>√</td><td>\</td></tr><tr><td>Double quoted</td><td>‘’…​’’</td><td>√</td><td></td><td>\</td></tr><tr><td>Triple double quoted</td><td>“””…”””</td><td>√</td><td>√</td><td>\</td></tr><tr><td>Slashy</td><td>/…​/</td><td>√</td><td>√</td><td>\</td></tr><tr><td>Dollar slashy</td><td>\$/…​/\$</td><td>√</td><td>√</td><td>$</td></tr></tbody></table><h3 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h3><p>Unlike Java, Groovy doesn’t have an explicit character literal. However, you can be explicit about making a Groovy string an actual character, by three different means:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'A'</span> ①</span><br><span class="line"><span class="keyword">assert</span> c1 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c2 = <span class="string">'B'</span> <span class="keyword">as</span> <span class="keyword">char</span> ②</span><br><span class="line"><span class="keyword">assert</span> c2 <span class="keyword">instanceof</span> Character</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> c3 = (<span class="keyword">char</span>)<span class="string">'C'</span> ③</span><br><span class="line"><span class="keyword">assert</span> c3 <span class="keyword">instanceof</span> Character</span><br></pre></td></tr></table></figure><p>① by being explicit when declaring a variable holding the character by specifying the char type</p><p>② by using type coercion with the as operator</p><p>③ by using a cast to char operation</p><p>The first option ① is interesting when the character is held in a variable, while the other two (② and ③) are more interesting when a char value must be passed as argument of a method call.</p><h2 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h2><h3 id="Integral-literals"><a href="#Integral-literals" class="headerlink" title="Integral literals"></a>Integral literals</h3><p>The integral literal types are the same as in Java:</p><ul><li><p>byte</p></li><li><p>char</p></li><li><p>short</p></li><li><p>int</p></li><li><p>long</p></li><li><p>java.lang.BigInteger</p></li></ul><p>You can create integral numbers of those types with the following declarations:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive types</span></span><br><span class="line"><span class="keyword">byte</span>  b = <span class="number">1</span></span><br><span class="line"><span class="keyword">char</span>  c = <span class="number">2</span></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">3</span></span><br><span class="line"><span class="keyword">int</span>   i = <span class="number">4</span></span><br><span class="line"><span class="keyword">long</span>  l = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite precision</span></span><br><span class="line">BigInteger bi =  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>If you use optional typing by using the def keyword, the type of the integral number will vary: it’ll adapt to the capacity of the type that can hold that number.</p><p>For positive numbers:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> a <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> b = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">assert</span> b <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> c = <span class="number">2147483648</span></span><br><span class="line"><span class="keyword">assert</span> c <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE</span></span><br><span class="line"><span class="keyword">def</span> d = <span class="number">9223372036854775807</span></span><br><span class="line"><span class="keyword">assert</span> d <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MAX_VALUE + 1</span></span><br><span class="line"><span class="keyword">def</span> e = <span class="number">9223372036854775808</span></span><br><span class="line"><span class="keyword">assert</span> e <span class="keyword">instanceof</span> BigInteger</span><br></pre></td></tr></table></figure><p>As well as for negative numbers:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> na = <span class="number">-1</span></span><br><span class="line"><span class="keyword">assert</span> na <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MIN_VALUE</span></span><br><span class="line"><span class="keyword">def</span> nb = <span class="number">-2147483648</span></span><br><span class="line"><span class="keyword">assert</span> nb <span class="keyword">instanceof</span> Integer</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer.MIN_VALUE - 1</span></span><br><span class="line"><span class="keyword">def</span> nc = <span class="number">-2147483649</span></span><br><span class="line"><span class="keyword">assert</span> nc <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MIN_VALUE</span></span><br><span class="line"><span class="keyword">def</span> nd = <span class="number">-9223372036854775808</span></span><br><span class="line"><span class="keyword">assert</span> nd <span class="keyword">instanceof</span> Long</span><br><span class="line"></span><br><span class="line"><span class="comment">// Long.MIN_VALUE - 1</span></span><br><span class="line"><span class="keyword">def</span> ne = <span class="number">-9223372036854775809</span></span><br><span class="line"><span class="keyword">assert</span> ne <span class="keyword">instanceof</span> BigInteger</span><br></pre></td></tr></table></figure><h4 id="Alternative-non-base-10-representations"><a href="#Alternative-non-base-10-representations" class="headerlink" title="Alternative non-base 10 representations"></a>Alternative non-base 10 representations</h4><p>Numbers can also be represented in binary, octal, hexadecimal and decimal bases.</p><h5 id="Binary-literal"><a href="#Binary-literal" class="headerlink" title="Binary literal"></a>Binary literal</h5><p>Binary numbers start with a 0b prefix:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xInt = <span class="number">0b10101111</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">175</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">0b11001001</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">201</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">0b11</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">3</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0b101101101101</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">2925</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">0b111100100001</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">3873</span>g</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-0</span>b10101111</span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-175</span></span><br></pre></td></tr></table></figure><h5 id="Octal-literal"><a href="#Octal-literal" class="headerlink" title="Octal literal"></a>Octal literal</h5><p>Octal numbers are specified in the typical format of 0 followed by octal digits.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xInt = <span class="number">077</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">63</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">011</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">9</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">032</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">26</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0246</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">166</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">01111</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">585</span>g</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-077</span></span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-63</span></span><br></pre></td></tr></table></figure><h5 id="Hexadecimal-literal"><a href="#Hexadecimal-literal" class="headerlink" title="Hexadecimal literal"></a>Hexadecimal literal</h5><p>Hexadecimal numbers are specified in the typical format of 0x followed by hex digits.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> xInt = <span class="number">0x77</span></span><br><span class="line"><span class="keyword">assert</span> xInt == <span class="number">119</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> xShort = <span class="number">0xaa</span></span><br><span class="line"><span class="keyword">assert</span> xShort == <span class="number">170</span> <span class="keyword">as</span> <span class="keyword">short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> xByte = <span class="number">0x3a</span></span><br><span class="line"><span class="keyword">assert</span> xByte == <span class="number">58</span> <span class="keyword">as</span> <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> xLong = <span class="number">0xffff</span></span><br><span class="line"><span class="keyword">assert</span> xLong == <span class="number">65535</span>l</span><br><span class="line"></span><br><span class="line">BigInteger xBigInteger = <span class="number">0xaaaa</span></span><br><span class="line"><span class="keyword">assert</span> xBigInteger == <span class="number">43690</span>g</span><br><span class="line"></span><br><span class="line">Double xDouble = <span class="keyword">new</span> Double(<span class="string">'0x1.0p0'</span>)</span><br><span class="line"><span class="keyword">assert</span> xDouble == <span class="number">1.0</span>d</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xNegativeInt = <span class="number">-0x77</span></span><br><span class="line"><span class="keyword">assert</span> xNegativeInt == <span class="number">-119</span></span><br></pre></td></tr></table></figure><h3 id="Decimal-literals"><a href="#Decimal-literals" class="headerlink" title="Decimal literals"></a>Decimal literals</h3><p>The decimal literal types are the same as in Java:</p><ul><li>float</li><li>double</li><li>java.lang.BigDecimal</li></ul><p>You can create decimal numbers of those types with the following declarations:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primitive types</span></span><br><span class="line"><span class="keyword">float</span>  f = <span class="number">1.234</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">2.345</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// infinite precision</span></span><br><span class="line">BigDecimal bd =  <span class="number">3.456</span></span><br></pre></td></tr></table></figure><p>Decimals can use exponents, with the e or E exponent letter, followed by an optional sign, and a integral number representing the exponent:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1e3</span>  ==  <span class="number">1</span>_000<span class="number">.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">2E4</span>  == <span class="number">20</span>_000<span class="number">.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">3e+1</span> ==     <span class="number">30.0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">4E-2</span> ==      <span class="number">0.04</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">5e-1</span> ==      <span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>Conveniently for exact decimal number calculations, Groovy choses java.lang.BigDecimal as its decimal number type. In addition, both float and double are supported, but require an explicit type declaration, type coercion or suffix. Even if BigDecimal is the default for decimal numbers, such literals are accepted in methods or closures taking float or double as parameter types.</p><p>Decimal numbers can’t be represented using a binary, octal or hexadecimal representation.</p><h3 id="Underscore-in-literals"><a href="#Underscore-in-literals" class="headerlink" title="Underscore in literals"></a>Underscore in literals</h3><p>When writing long literal numbers, it’s harder on the eye to figure out how some numbers are grouped together, for example with groups of thousands, of words, etc. By allowing you to place underscore in number literals, it’s easier to spot those groups:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</span><br><span class="line"><span class="keyword">long</span> socialSecurityNumbers = <span class="number">999</span>_99_9999L</span><br><span class="line"><span class="keyword">double</span> monetaryAmount = <span class="number">12</span>_345_132<span class="number">.12</span></span><br><span class="line"><span class="keyword">long</span> hexBytes = <span class="number">0xFF</span>_EC_DE_5E</span><br><span class="line"><span class="keyword">long</span> hexWords = <span class="number">0xFFEC</span>_DE5E</span><br><span class="line"><span class="keyword">long</span> maxLong = <span class="number">0x7fff</span>_ffff_ffff_ffffL</span><br><span class="line"><span class="keyword">long</span> alsoMaxLong = <span class="number">9</span>_223_372_036_854_775_807L</span><br><span class="line"><span class="keyword">long</span> bytes = <span class="number">0b11010010</span>_01101001_10010100_10010010</span><br></pre></td></tr></table></figure><h3 id="Number-type-suffixes"><a href="#Number-type-suffixes" class="headerlink" title="Number type suffixes"></a>Number type suffixes</h3><p>We can force a number (including binary, octals and hexadecimals) to have a specific type by giving a suffix (see table below), either uppercase or lowercase.</p><table><thead><tr><th>Type</th><th>Suffix</th></tr></thead><tbody><tr><td>BigInteger</td><td>G or g</td></tr><tr><td>Long</td><td>L or l</td></tr><tr><td>Integer</td><td>I or i</td></tr><tr><td>BigDecimal</td><td>G or g</td></tr><tr><td>Double</td><td>D or d</td></tr><tr><td>Float</td><td>F or f</td></tr></tbody></table><p>Examples:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">42</span>I == <span class="keyword">new</span> Integer(<span class="string">'42'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">42</span>i == <span class="keyword">new</span> Integer(<span class="string">'42'</span>) <span class="comment">// lowercase i more readable</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">123</span>L == <span class="keyword">new</span> Long(<span class="string">"123"</span>) <span class="comment">// uppercase L more readable</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">2147483648</span> == <span class="keyword">new</span> Long(<span class="string">'2147483648'</span>) <span class="comment">// Long type used, value too large for an Integer</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">456</span>G == <span class="keyword">new</span> BigInteger(<span class="string">'456'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">456</span>g == <span class="keyword">new</span> BigInteger(<span class="string">'456'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">123.45</span> == <span class="keyword">new</span> BigDecimal(<span class="string">'123.45'</span>) <span class="comment">// default BigDecimal type used</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.200065</span>D == <span class="keyword">new</span> Double(<span class="string">'1.200065'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.234</span>F == <span class="keyword">new</span> Float(<span class="string">'1.234'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">1.23E23</span>D == <span class="keyword">new</span> Double(<span class="string">'1.23E23'</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">0b1111</span>L.<span class="keyword">class</span> == Long <span class="comment">// binary</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0xFF</span>i.<span class="keyword">class</span> == Integer <span class="comment">// hexadecimal</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">034</span>G.<span class="keyword">class</span> == BigInteger <span class="comment">// octal</span></span><br></pre></td></tr></table></figure><h3 id="Math-operations"><a href="#Math-operations" class="headerlink" title="Math operations"></a>Math operations</h3><p>Although operators are covered later on, it’s important to discuss the behavior of math operations and what their resulting types are.</p><p>Division and power binary operations aside (covered below),</p><ul><li><p>binary operations between byte, char, short and int result in int</p></li><li><p>binary operations involving long with byte, char, short and int result in long</p></li><li><p>binary operations involving BigInteger and any other integral type result in BigInteger</p></li><li><p>binary operations involving BigDecimal with byte, char, short, int and BigInteger result in BigDecimal</p></li><li><p>binary operations between float, double and BigDecimal result in double</p></li><li><p>binary operations between two BigDecimal result in BigDecimal</p></li></ul><p>The following table summarizes those rules:</p><table><thead><tr><th></th><th>byte</th><th>char</th><th>short</th><th>int</th><th>long</th><th>BigInteger</th><th>float</th><th>double</th><th>BigDecimal</th></tr></thead><tbody><tr><td>byte</td><td>byte</td><td>char</td><td>short</td><td>int</td><td>long</td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>char</td><td></td><td>char</td><td>short</td><td>int</td><td>long</td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>short</td><td></td><td></td><td>short</td><td>int</td><td>long</td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>int</td><td></td><td></td><td></td><td>int</td><td>long</td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>long</td><td></td><td></td><td></td><td></td><td>long</td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>BigInteger</td><td></td><td></td><td></td><td></td><td></td><td>BigInteger</td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>float</td><td></td><td></td><td></td><td></td><td></td><td></td><td>float</td><td>double</td><td>BigDecimal</td></tr><tr><td>double</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>double</td><td>BigDecimal</td></tr><tr><td>BigDecimal</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>BigDecimal</td></tr></tbody></table><p>Thanks to Groovy’s operator overloading, the usual arithmetic operators work as well with BigInteger and BigDecimal, unlike in Java where you have to use explicit methods for operating on those numbers.</p><h4 id="The-case-of-the-division-operator"><a href="#The-case-of-the-division-operator" class="headerlink" title="The case of the division operator"></a>The case of the division operator</h4><p>The division operators / (and /= for division and assignment) produce a double result if either operand is a float or double, and a BigDecimal result otherwise (when both operands are any combination of an integral type short, char, byte, int, long, BigInteger or BigDecimal).</p><p>BigDecimal division is performed with the divide() method if the division is exact (i.e. yielding a result that can be represented within the bounds of the same precision and scale), or using a MathContext with a precision of the maximum of the two operands’ precision plus an extra precision of 10, and a scale of the maximum of 10 and the maximum of the operands’ scale.</p><p>For integer division like in Java, you should use the intdiv() method, as Groovy doesn’t provide a dedicated integer division operator symbol.</p><h4 id="The-case-of-the-power-operator"><a href="#The-case-of-the-power-operator" class="headerlink" title="The case of the power operator"></a>The case of the power operator</h4><p>The power operation is represented by the ** operator, with two parameters: the base and the exponent. The result of the power operation depends on its operands, and the result of the operation (in particular if the result can be represented as an integral value).</p><p>The following rules are used by Groovy’s power operation to determine the resulting type:</p><ul><li>If the exponent is a decimal value<ul><li>if the result can be represented as an Integer, then return an Integer</li><li>else if the result can be represented as a Long, then return a Long</li><li>otherwise return a Double</li></ul></li><li>If the exponent is an integral value<ul><li>if the exponent is strictly negative, then return an Integer, Long or Double if the result value fits in that type</li><li>if the exponent is positive or zero<ul><li>if the base is a BigDecimal, then return a BigDecimal result value</li><li>if the base is a BigInteger, then return a BigInteger result value</li><li>if the base is an Integer, then return an Integer if the result value fits in it, otherwise a BigInteger</li><li>if the base is a Long, then return a Long if the result value fits in it, otherwise a BigInteger</li></ul></li></ul></li></ul><p>We can illustrate those rules with a few examples:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base and exponent are ints and the result can be represented by an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">2</span>    **   <span class="number">3</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  8</span></span><br><span class="line"><span class="keyword">assert</span>   <span class="number">10</span>    **   <span class="number">9</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  1_000_000_000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a long, so fit the result in a Long</span></span><br><span class="line"><span class="comment">// (although it could have fit in an Integer)</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">5</span>L   **   <span class="number">2</span>    <span class="keyword">instanceof</span> Long       <span class="comment">//  25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the result can't be represented as an Integer or Long, so return a BigInteger</span></span><br><span class="line"><span class="keyword">assert</span>  <span class="number">100</span>    **  <span class="number">10</span>    <span class="keyword">instanceof</span> BigInteger <span class="comment">//  10e20</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">1234</span>    ** <span class="number">123</span>    <span class="keyword">instanceof</span> BigInteger <span class="comment">//  170515806212727042875...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a BigDecimal and the exponent a negative int</span></span><br><span class="line"><span class="comment">// but the result can be represented as an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">0.5</span>  **  <span class="number">-2</span>    <span class="keyword">instanceof</span> Integer    <span class="comment">//  4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is an int, and the exponent a negative float</span></span><br><span class="line"><span class="comment">// but again, the result can be represented as an Integer</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">1</span>    **  <span class="number">-0.3</span>f <span class="keyword">instanceof</span> Integer    <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is an int, and the exponent a negative int</span></span><br><span class="line"><span class="comment">// but the result will be calculated as a Double</span></span><br><span class="line"><span class="comment">// (both base and exponent are actually converted to doubles)</span></span><br><span class="line"><span class="keyword">assert</span>   <span class="number">10</span>    **  <span class="number">-1</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">1.2</span>  **  <span class="number">10</span>    <span class="keyword">instanceof</span> BigDecimal <span class="comment">//  6.1917364224</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the base is a float or double, and the exponent is an int</span></span><br><span class="line"><span class="comment">// but the result can only be represented as a Double value</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">3.4</span>f **   <span class="number">5</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  454.35430372146965</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">5.6</span>d **   <span class="number">2</span>    <span class="keyword">instanceof</span> Double     <span class="comment">//  31.359999999999996</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the exponent is a decimal value</span></span><br><span class="line"><span class="comment">// and the result can only be represented as a Double value</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">7.8</span>  **   <span class="number">1.9</span>  <span class="keyword">instanceof</span> Double     <span class="comment">//  49.542708423868476</span></span><br><span class="line"><span class="keyword">assert</span>    <span class="number">2</span>    **   <span class="number">0.1</span>f <span class="keyword">instanceof</span> Double     <span class="comment">//  1.0717734636432956</span></span><br></pre></td></tr></table></figure><h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>Boolean is a special data type that is used to represent truth values: true and false. Use this data type for simple flags that track true/false conditions.</p><p>Boolean values can be stored in variables, assigned into fields, just like any other data type:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> myBooleanVariable = <span class="literal">true</span></span><br><span class="line"><span class="keyword">boolean</span> untypedBooleanVar = <span class="literal">false</span></span><br><span class="line">booleanField = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>true and false are the only two primitive boolean values. But more complex boolean expressions can be represented using logical operators.</p><p>In addition, Groovy has special rules (often referred to as Groovy Truth) for coercing non-boolean objects to a boolean value.</p><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Groovy uses a comma-separated list of values, surrounded by square brackets, to denote lists. Groovy lists are plain JDK java.util.List, as Groovy doesn’t define its own collection classes. The concrete list implementation used when defining list literals are java.util.ArrayList by default, unless you decide to specify otherwise, as we shall see later on.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numbers <span class="keyword">instanceof</span> List  </span><br><span class="line"><span class="keyword">assert</span> numbers.size() == <span class="number">3</span> ②</span><br></pre></td></tr></table></figure><p>① We define a list numbers delimited by commas and surrounded by square brackets, and we assign that list into a variable</p><p>② The list is an instance of Java’s java.util.List interface</p><p>③ The size of the list can be queried with the size() method, and shows our list contains 3 elements</p><p>In the above example, we used a homogeneous list, but you can also create lists containing values of heterogeneous types:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> heterogeneous = [<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>]  ①</span><br></pre></td></tr></table></figure><p>① Our list here contains a number, a string and a boolean value</p><p>We mentioned that by default, list literals are actually instances of java.util.ArrayList, but it is possible to use a different backing type for our lists, thanks to using type coercion with the as operator, or with explicit type declaration for your variables:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> arrayList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> arrayList <span class="keyword">instanceof</span> java.util.ArrayList</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> linkedList = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> LinkedList ①</span><br><span class="line"><span class="keyword">assert</span> linkedList <span class="keyword">instanceof</span> java.util.LinkedList</span><br><span class="line"></span><br><span class="line">LinkedList otherLinked = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] ②</span><br><span class="line"><span class="keyword">assert</span> otherLinked <span class="keyword">instanceof</span> java.util.LinkedList</span><br></pre></td></tr></table></figure><p>① We use coercion with the as operator to explicitly request a java.util.LinkedList implementation</p><p>② We can say that the variable holding the list literal is of type java.util.LinkedList</p><p>You can access elements of the list with the [] subscript operator (both for reading and setting values) with positive indices or negative indices to access elements from the end of the list, as well as with ranges, and use the &lt;&lt; leftShift operator to append elements to a list:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">0</span>] == <span class="string">'a'</span> ①</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>] == <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'d'</span> ②</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-2</span>] == <span class="string">'c'</span></span><br><span class="line"></span><br><span class="line">letters[<span class="number">2</span>] = <span class="string">'C'</span> ③</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2</span>] == <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line">letters &lt;&lt; <span class="string">'e'</span> ④</span><br><span class="line"><span class="keyword">assert</span> letters[ <span class="number">4</span>] == <span class="string">'e'</span></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">-1</span>] == <span class="string">'e'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">1</span>, <span class="number">3</span>] == [<span class="string">'b'</span>, <span class="string">'d'</span>] ⑤</span><br><span class="line"><span class="keyword">assert</span> letters[<span class="number">2.</span><span class="number">.4</span>] == [<span class="string">'C'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>] ⑥</span><br></pre></td></tr></table></figure><p>① Access the first element of the list (zero-based counting)</p><p>② Access the last element of the list with a negative index: -1 is the first element from the end of the list</p><p>③ Use an assignment to set a new value for the third element of the list</p><p>④ Use the &lt;&lt; leftShift operator to append an element at the end of the list</p><p>⑤ Access two elements at once, returning a new list containing those two elements</p><p>⑥ Use a range to access a range of values from the list, from a start to an end element position</p><p>As lists can be heterogeneous in nature, lists can also contain other lists to create multi-dimensional lists:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> multi = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]] ①</span><br><span class="line"><span class="keyword">assert</span> multi[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">2</span> ②</span><br></pre></td></tr></table></figure><p>① Define a list of list of numbers</p><p>② Access the second element of the top-most list, and the first element of the inner list</p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Groovy reuses the list notation for arrays, but to make such literals arrays, you need to explicitely define the type of the array through coercion or type declaration.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] arrStr = [<span class="string">'Ananas'</span>, <span class="string">'Banana'</span>, <span class="string">'Kiwi'</span>]  ①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> arrStr <span class="keyword">instanceof</span> String[] ②</span><br><span class="line"><span class="keyword">assert</span> !(arrStr <span class="keyword">instanceof</span> List)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> numArr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">int</span>[] ③</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numArr <span class="keyword">instanceof</span> <span class="keyword">int</span>[] ④</span><br><span class="line"><span class="keyword">assert</span> numArr.size() == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>① Define an array of strings using explicit variable type declaration</p><p>② Assert that we created an array of strings</p><p>③ Create an array of ints with the as operator</p><p>④ Assert that we created an array of primitive ints</p><p>You can also create multi-dimensional arrays:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> matrix3 = <span class="keyword">new</span> Integer[<span class="number">3</span>][<span class="number">3</span>] ①</span><br><span class="line"><span class="keyword">assert</span> matrix3.size() == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Integer[][] matrix2 ②</span><br><span class="line">matrix2 = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">assert</span> matrix2 <span class="keyword">instanceof</span> Integer[][]</span><br></pre></td></tr></table></figure><p>① You can define the bounds of a new array</p><p>② Or declare an array without specifying its bounds</p><p>Access to elements of an array follows the same notation as for lists:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = [<span class="string">'Cédric'</span>, <span class="string">'Guillaume'</span>, <span class="string">'Jochen'</span>, <span class="string">'Paul'</span>]</span><br><span class="line"><span class="keyword">assert</span> names[<span class="number">0</span>] == <span class="string">'Cédric'</span> ①</span><br><span class="line"></span><br><span class="line">names[<span class="number">2</span>] = <span class="string">'Blackdrag'</span> ②</span><br><span class="line"><span class="keyword">assert</span> names[<span class="number">2</span>] == <span class="string">'Blackdrag'</span></span><br></pre></td></tr></table></figure><p>① Retrieve the first element of the array</p><p>② Set the value of the third element of the array to a new value</p><p>Java’s array initializer notation is not supported by Groovy, as the curly braces can be misinterpreted with the notation of Groovy closures.</p><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>Sometimes called dictionaries or associative arrays in other languages, Groovy features maps. Maps associate keys to values, separating keys and values with colons, and each key/value pairs with commas, and the whole keys and values surrounded by square brackets.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> colors = [<span class="string">red:</span> <span class="string">'#FF0000'</span>, <span class="string">green:</span> <span class="string">'#00FF00'</span>, <span class="string">blue:</span> <span class="string">'#0000FF'</span>]①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">'red'</span>] == <span class="string">'#FF0000'</span> ②</span><br><span class="line"><span class="keyword">assert</span> colors.green  == <span class="string">'#00FF00'</span> ③</span><br><span class="line"></span><br><span class="line">colors[<span class="string">'pink'</span>] = <span class="string">'#FF00FF'</span> ④</span><br><span class="line">colors.yellow  = <span class="string">'#FFFF00'</span> ⑤</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors.pink == <span class="string">'#FF00FF'</span></span><br><span class="line"><span class="keyword">assert</span> colors[<span class="string">'yellow'</span>] == <span class="string">'#FFFF00'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> colors <span class="keyword">instanceof</span> java.util.LinkedHashMap</span><br></pre></td></tr></table></figure><p>① We define a map of string color names, associated with their hexadecimal-coded html colors</p><p>② We use the subscript notation to check the content associated with the red key</p><p>③ We can also use the property notation to assert the color green’s hexadecimal representation</p><p>④ Similarly, we can use the subscript notation to add a new key/value pair</p><p>⑤ Or the property notation, to add the yellow color</p><p>When using names for the keys, we actually define string keys in the map.<br>Groovy creates maps that are actually instances of java.util.LinkedHashMap.</p><p>If you try to access a key which is not present in the map:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> colors.unknown == <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>You will retrieve a null result.</p><p>In the examples above, we used string keys, but you can also use values of other types as keys:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> numbers = [<span class="number">1</span>: <span class="string">'one'</span>, <span class="number">2</span>: <span class="string">'two'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> numbers[<span class="number">1</span>] == <span class="string">'one'</span></span><br></pre></td></tr></table></figure><p>Here, we used numbers as keys, as numbers can unambiguously be recognized as numbers, so Groovy will not create a string key like in our previous examples. But consider the case you want to pass a variable in lieu of the key, to have the value of that variable become the key:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> key = <span class="string">'name'</span></span><br><span class="line"><span class="keyword">def</span> person = [<span class="string">key:</span> <span class="string">'Guillaume'</span>] ①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> !person.containsKey(<span class="string">'name'</span>) ②</span><br><span class="line"><span class="keyword">assert</span> person.containsKey(<span class="string">'key'</span>) ③</span><br></pre></td></tr></table></figure><p>① The key associated with the ‘Guillaume’ name will actually be the “key” string, not the value associated with the key variable</p><p>② The map doesn’t contain the ‘name’ key</p><p>③Instead, the map contains a ‘key’ key</p><p>You can also pass quoted strings as well as keys: [“name”: “Guillaume”]. This is mandatory if your key string isn’t a valid identifier, for example if you wanted to create a string key containing a hash like in: [“street-name”: “Main street”].</p><p>When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = [(key): <span class="string">'Guillaume'</span>] ①</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> person.containsKey(<span class="string">'name'</span>) ②</span><br><span class="line"><span class="keyword">assert</span> !person.containsKey(<span class="string">'key'</span>) ③</span><br></pre></td></tr></table></figure><p>① This time, we surround the key variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key</p><p>② The map does contain the name key</p><p>③ But the map doesn’t contain the key key as before</p><p>that’s all, thanks for your reading.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Reference: &lt;a href=&quot;http://groovy-lang.org/syntax.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Groovy&lt;/a&gt;&lt;br&gt;This chapter
        
      
    
    </summary>
    
      <category term="Groovy" scheme="http://duanyitao.com/categories/Groovy/"/>
    
    
      <category term="Groovy" scheme="http://duanyitao.com/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>[译] 高级 DataBinding: 绑定到 LiveData (单向绑定 &amp; 双向绑定) </title>
    <link href="http://duanyitao.com/2019/04/22/%E8%AF%91-%E9%AB%98%E7%BA%A7-DataBinding-%E7%BB%91%E5%AE%9A%E5%88%B0-LiveData-%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9A-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://duanyitao.com/2019/04/22/译-高级-DataBinding-绑定到-LiveData-单向绑定-双向绑定/</id>
    <published>2019-04-22T03:13:13.000Z</published>
    <updated>2019-04-22T05:53:35.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明： 本文翻译自<a href="https://proandroiddev.com/advanced-data-binding-binding-to-livedata-one-and-two-way-binding-dae1cd68530f?gi=bd0854b80012" target="_blank" rel="noopener">Medium 文章</a></p></blockquote><p>数据绑定库在 Android 应用程序的生产中越来越受欢迎，因为它扩大了 MVVM 架构的优势。它允许您使用声明性格式而不是以编程方式将布局中的UI组件绑定到应用程序中的数据源。自动通知UI关于数据的变化并获得传播回来的UI属性的变化，这不是很好吗？那么让我们看看我们如何通过单向和双向绑定绑定到 LiveData ！</p><h2 id="为什么绑定到-LiveData？"><a href="#为什么绑定到-LiveData？" class="headerlink" title="为什么绑定到 LiveData？"></a>为什么绑定到 LiveData？</h2><p>使用生命周期感知组件（如LiveData）的优点包括：</p><ul><li><p>没有因停止活动而崩溃。如果观察者的生命周期处于非活动状态，例如活动位于后台堆栈中，则它不会收到任何 LiveData 事件。</p></li><li><p>自适应的配置更改。如果由于配置更改（例如，设备旋转）而重新创建 Fragment 或 Activity ，则会立即接收最新的可用数据。</p></li><li><p>没有内存泄漏。无需手动处理订阅。当相关的生命周期被破坏时，观察者会自行清理。</p></li></ul><h2 id="LiveData-VS-ObservableFields"><a href="#LiveData-VS-ObservableFields" class="headerlink" title="LiveData VS ObservableFields"></a>LiveData VS ObservableFields</h2><p>与实现 Observable 的对象 （例如可观察字段）不同  ，  LiveData 对象知道订阅数据更改的观察者的生命周期。无论 LiveData 和 ObservableFields， 他们都可以实现其观察数据变化，但是在其他方面，LiveData 有它特殊的优势：</p><ul><li><p>手动生命周期处理。UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些，因为它在观察时意识到相关的生命周期状态变化。</p></li><li><p>Transformations 和 MediatorLiveData 的更多功能。使用 LiveData 将使您受益于转换的强大功能，并且还可以向 MediatorLiveData 添加多个源。因此，如果布局中有5个 EditText 视图，则无需从 Activity 或 Fragment 中观察全部 5个 视图。您只能观察一个 MediatorLiveData，这将为您节省一些代码和逻辑复杂性。</p></li><li><p>共享资源。创建扩展 LiveData 的自定义对象将允许您连接到系统服务一次，然后任何需要该资源的观察者只能观察该对象。</p></li></ul><h3 id="开始使用带数据绑定的-LiveData"><a href="#开始使用带数据绑定的-LiveData" class="headerlink" title="开始使用带数据绑定的 LiveData"></a>开始使用带数据绑定的 LiveData</h3><p>要将 LiveData 对象与绑定类一起使用，需要指定生命周期所有者以定义 LiveData 对象的范围。以下示例说明如何在实例化绑定类之后将活动设置为生命周期所有者：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inflate view and obtain an instance of the binding class.</span></span><br><span class="line"><span class="keyword">val</span> binding: MainBinding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main)</span><br><span class="line"><span class="comment">// Specify the current activity as the lifecycle owner.</span></span><br><span class="line">binding.setLifecycleOwner(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>所以现在我们可以在布局文件 main.xml 中使用 LiveData 对象，如下所示，commentText 的值将设置到 text 属性上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewModel.commentText&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在某些情况下，在数据绑定中使用 LiveData 时，可能会出现警告“…是一个盒装字段但需要取消装箱以执行…”。这表示使用可空类型作为 LiveData 对象值。要禁止警告，建议使用原语（ ObservableInt 而不是 MutableLiveData<integer> ）或使用safeUnbox，如下所示：</integer></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text="@&#123;safeUnbox(viewModel.commentText)&#125;"</span><br></pre></td></tr></table></figure><h2 id="实现双向绑定"><a href="#实现双向绑定" class="headerlink" title="实现双向绑定"></a>实现双向绑定</h2><p>在预期从 UI 更新 LiveData 值的情况下，双向绑定变得非常方便。在代码中访问它时，我们希望收到更新的值。为了能够做到这一点，我们将在绑定表达式的花括号之前添加“=”：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.design.widget.TextInputEditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@=&#123;viewModel.commentText&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>现在，只要用户在屏幕上的视图中键入新文本，LiveData 对象就会更新，当访问其值时，我们将收到最新的更新。</p><h2 id="创建自定义绑定适配器"><a href="#创建自定义绑定适配器" class="headerlink" title="创建自定义绑定适配器"></a>创建自定义绑定适配器</h2><p>为了更进一步，让我们想一个不那么通用的案例。想象一下，我们希望通过使用 LiveData 对象的数据绑定在 ViewPager 中设置当前选项卡。为此，我们需要在 BindingAdapter 的帮助下为 ViewPager 创建自定义属性 currentTab ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">   <span class="meta">@BindingAdapter(<span class="meta-string">"currentTab"</span>)</span></span><br><span class="line">   <span class="meta">@JvmStatic</span> </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">setNewTab</span><span class="params">(pager: <span class="type">ViewPager</span>, newTab: <span class="type">MutableLiveData</span>&lt;<span class="type">Int</span>&gt;)</span></span> &#123;</span><br><span class="line">       newTab.value?.let &#123;</span><br><span class="line">          <span class="comment">//don't forget to break possible infinite loops!</span></span><br><span class="line">          <span class="keyword">if</span> (pager.currentItem != itemLiveData.value) &#123;       </span><br><span class="line">              pager.setCurrentItem(newTab.value, <span class="literal">true</span>)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在我们可以将新属性添加到布局文件中，并从 LiveData 对象值设置 ViewPager 的当前项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:currentTab</span>=<span class="string">"@&#123;viewModel.pagerCurrentTab&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当新值设置为 pagerCurrentTab 对象时，将执行 BindingAdapter 正文中的代码。</p><h2 id="使用自定义属性的双向绑定"><a href="#使用自定义属性的双向绑定" class="headerlink" title="使用自定义属性的双向绑定"></a>使用自定义属性的双向绑定</h2><p>现在，在更新我们创建的 LivaData 对象中的值时，ViewPager 会滚动到新位置。这很好，除了在我们的用例中，用户还与 UI 交互并更改ViewPager 的位置，但 LiveData 对象仍保留“旧”值。我们希望收到有关此属性更改的通知，以便基于它实现某些逻辑或只检查当前值。这可以通过实现双向绑定来实现。</p><p>我们将要对布局文件进行以下更改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:currentTab</span>=<span class="string">"@=&#123;viewModel.pagerCurrentTab&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>BindingAdapter我们已经有了，另外需要创建一个 InverseBindingAdapter。此时，数据绑定知道在数据更改时要做什么（它调用使用了 @BindingAdapter 注释的方法）以及在 view 属性更改时调用的内容（它调用使用了 InverseBindingListener 注释的方法）。因此，如果用户滑动 ViewPager 选项卡，LiveData 对象将使用新值进行更新。但是，为了知道属性何时或如何更改，我们引入了自定义事件。事件的命名默认为具有后缀“AttrChanged”的属性名称。在这个场景里就是 currentTabAttrChanged。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">   <span class="meta">@BindingAdapter(<span class="meta-string">"currentTab"</span>)</span></span><br><span class="line">   <span class="meta">@JvmStatic</span> </span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">setTab</span><span class="params">(pager: <span class="type">ViewPager</span>, itemLiveData: <span class="type">MutableLiveData</span>&lt;<span class="type">Int</span>&gt;)</span></span>&#123;</span><br><span class="line">       itemLiveData.value?.let &#123; </span><br><span class="line">          <span class="comment">//don't forget to break possible infinite loops!</span></span><br><span class="line">          <span class="keyword">if</span> (pager.currentItem != itemLiveData.value) &#123;      </span><br><span class="line">              pager.setCurrentItem(itemLiveData.value, <span class="literal">true</span>)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@InverseBindingAdapter(attribute = <span class="meta-string">"currentTab"</span>, event =                     <span class="meta-string">"currentTabAttrChanged"</span>)</span></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getTab</span><span class="params">(pager: <span class="type">ViewPager</span>)</span></span> = pager.currentItem</span><br></pre></td></tr></table></figure><h2 id="一句警告"><a href="#一句警告" class="headerlink" title="一句警告"></a>一句警告</h2><p>使用双向数据绑定时，请注意不要引入无限循环。当用户更改属性时，将调用注释@InverseBindingAdapter 的方法。反过来，这将调用注释 @BindingAdapter 的方法，这将触发对注释 @InverseBindingAdapter 的方法的另一个调用，依此类推。</p><p>因此，通过比较注释 @BindingAdapter 的方法中的新旧值来打破可能的无限循环非常重要。</p><h2 id="一些最后的想法"><a href="#一些最后的想法" class="headerlink" title="一些最后的想法"></a>一些最后的想法</h2><p>Android 组件的生命周期很复杂，手动管理可能很麻烦，因为保持 UI 与数据源保持同步，因此引入 LiveData 是生命周期管理中的一大步。将数据绑定添加到项目中可以使代码更加简洁和反应，因为数据源中的更改可以自动传播到 UI，同时考虑了到配置和生命周期状态。但是，使用数据绑定库不应仅限于将数据模型的属性设置为文本字段。使用单向和双向绑定绑定到 LiveData 将允许您充分利用 Observer 模式和生命周期感知。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;声明： 本文翻译自&lt;a
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
      <category term="Databinding" scheme="http://duanyitao.com/tags/Databinding/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 MVVM</title>
    <link href="http://duanyitao.com/2019/04/12/Jetpack-%E4%B9%8B-MVVM/"/>
    <id>http://duanyitao.com/2019/04/12/Jetpack-之-MVVM/</id>
    <published>2019-04-12T09:58:18.000Z</published>
    <updated>2019-04-17T10:41:07.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前置储备：<a href="https://www.duanyitao.com/2019/04/12/Jetpack-之-LiveData/" target="_blank" rel="noopener">LiveData</a><br>可以说 MVVM 的好处那是相当多了😁，至少我个人使用来说，是方便了不少❤。</p></blockquote><p><img src="https://developer.android.google.cn/topic/libraries/architecture/images/final-architecture.png" alt="logo"></p><h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><blockquote><p>说起 MVVM ，那就要大概提一提 MVC ,MVP 。当然，本文的重点并非 MVC &amp; MVP。</p></blockquote><h3 id="先来说说-MVC"><a href="#先来说说-MVC" class="headerlink" title="先来说说 MVC"></a>先来说说 MVC</h3><blockquote><p>直接贴上维基百科的解释(<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MVC</a>)</p></blockquote><p>即 模型（Model）-视图（View）-控制器（Controller）。<br>MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>MVC模式最早由Trygve Reenskaug在1978年提出[1]，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。</p><p>专业人员可以通过自身的专长分组：</p><ul><li><p>控制器（Controller）- 负责转发请求，对请求进行处理。</p></li><li><p>视图（View） - 界面设计人员进行图形界面设计。</p></li><li><p>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</p></li></ul><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><blockquote><p>维基解释(<a href="https://zh.wikipedia.org/wiki/Model-view-presenter" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Model-view-presenter</a>)</p></blockquote><p>Model-view-presenter，简称MVP，是计算机软件设计工程中一种对针对MVC模式，再审议后所延伸提出的一种软件设计模式。</p><p>Model-View-Presenter (MVP) 是用户界面设计模式的一种，被广泛用于便捷自动化单元测试和在呈现逻辑中改良分离关注点（separation of concerns）。</p><ul><li>Model 定义用户界面所需要被显示的数据模型，一个模型包含着相关的业务逻辑。</li><li>View 视图为呈现用户界面的终端，用以表现来自 Model 的数据，和用户命令路由再经过 Presenter 对事件处理后的数据。</li><li>Presenter 包含着组件的事件处理，负责检索 Model 获取数据，和将获取的数据经过格式转换与 View 进行沟通。</li></ul><p>MVP 设计模式通常会再加上 Controller 做为整体应用程序的后端程序工作。</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>维基(<a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/MVVM</a>)</p></blockquote><ul><li>MVVM 概述</li></ul><p>MVVM（Model–view–viewmodel）是一种软件架构模式。</p><p>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。</p><p>MVVM是马丁·福勒的PM（Presentation Model）设计模式的变体。MVVM以相同的方式抽象出视图的状态和行为，但PM以不依赖于特定用户界面平台的方式抽象出视图（创建了视图模型）。</p><p>MVVM和PM都来自MVC模式。</p><p>MVVM由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用派生品）的特性来简化用户界面的事件驱动程序设计。微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。</p><p>MVVM也被称为model-view-binder，特别是在不涉及.NET平台的实现中。ZK（Java写的一个Web应用框架）和KnockoutJS（一个JavaScript库）使用model-view-binder。</p><ul><li><p>MVVM模式的组成部分</p><ul><li>模型<blockquote><p>模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p></blockquote></li><li>视图<blockquote><p>就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p></blockquote></li><li>视图模型<blockquote><p>视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</p></blockquote></li><li>绑定器<blockquote><p>声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。</p></blockquote></li></ul></li><li><p>理论基础</p></li></ul><p>MVVM旨在利用WPF中的数据绑定函数，通过从视图层中几乎删除所有GUI代码（代码隐藏），更好地促进视图层开发与模式其余部分的分离。不需要用户体验（UX）开发人员编写GUI代码，他们可以使用框架标记语言（如XAML），并创建到应用程序开发人员编写和维护的视图模型的数据绑定。角色的分离使得交互设计师可以专注于用户体验需求，而不是对业务逻辑进行编程。这样，应用程序的层次可以在多个工作流中进行开发以提高生产力。即使一个开发人员在整个代码库上工作，视图与模型的适当分离也会更加高效，因为基于最终用户反馈，用户界面通常在开发周期中经常发生变化，而且处于开发周期后期。</p><p>MVVM模式试图获得MVC提供的功能性开发分离的两个优点，同时利用数据绑定的优势和通过绑定数据的框架尽可能接近纯应用程序模型。它使用绑定器、视图模型和任何业务层的数据检查功能来验证传入的数据。结果是模型和框架驱动尽可能多的操作，消除或最小化直接操纵视图的应用程序逻辑（如代码隐藏）。</p><h2 id="MVVM-特点"><a href="#MVVM-特点" class="headerlink" title="MVVM 特点"></a>MVVM 特点</h2><h3 id="在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层："><a href="#在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层：" class="headerlink" title="在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层："></a>在说MVVM之前，简单回顾一下MVP分层，MVP总共分成三层：</h3><blockquote><p>本节参考自 <a href="https://juejin.im/post/58cf2d791b69e6006b851605" target="_blank" rel="noopener">https://juejin.im/post/58cf2d791b69e6006b851605</a></p></blockquote><ul><li>a 、View: 视图层，对应xml文件与Activity/Fragment；</li><li>b 、Presenter: 逻辑控制层，同时持有View和Model对象；</li><li><p>c 、Model: 实体层，负责获取实体数据。</p><p><img src="https://user-gold-cdn.xitu.io/2017/3/20/709a1ff353629ea41be450cda3f92137?imageView2/0/w/1280/h/960/ignore-error/1" alt="logo"></p></li></ul><p>MVP模式有其很大的优点：</p><ul><li><p>1.解耦合，业务逻辑和视图分离；</p></li><li><p>2.项目代码结构（文件夹）清晰，一看就知道什么类干什么事情；</p></li><li><p>3.便于单元测试（其实还是第一点）；</p></li><li><p>4.协同工作（例如在设计师没出图之前可以先写一些业务逻辑代码或者其他人接手代码改起来比较容易）；</p></li></ul><p>但是也有美中不足的部分，MVP模式的缺点如下：</p><ul><li><p>1.Presente层与View层是通过接口进行交互的，接口粒度不好控制。粒度太小，就会存在大量接口的情况，使代码太过碎版化;粒度太大，解耦效果不好。因为View定义的方法并不一定全部要用到，可能只是后面要用到先定义出来（后面要不要删也未知），而且如果后面有些方法要删改，Presenter和Activity都要删改，比较麻烦；</p></li><li><p>2.V层与P层还是有一定的耦合度。一旦V层某个UI元素更改，那么对应的接口就必须得改，数据如何映射到UI上、事件监听接口这些都需要转变，牵一发而动全身。如果这一层也能解耦就更好了。</p></li><li><p>3.复杂的业务同时也可能会导致P层太大，代码臃肿的问题依然不能解决，这已经不是接口粒度把控的问题了，一旦业务逻辑越来越多，View定义的方法越来越多，会造成Activity和Fragment实现的方法越来越多，依然臃肿。</p></li></ul><h3 id="MVVM-的优点"><a href="#MVVM-的优点" class="headerlink" title="MVVM 的优点"></a>MVVM 的优点</h3><p>View和Model进行了双向绑定，两者之间有一方发生变化则会反应在另一方</p><p>MVP和MVC的主要区别是，MVP的View不能直接访问Model，需要通过Presenter发送请求，View和Model 不能直接通信。</p><p>MVP和MVVM的主要区别是，MVP 的View更新需要通过Presenter，而MVVM不需要，因为View 和<br>Model进行了双向绑定，数据的修改会直接反应在View上，而View的修改也会导致数据变更<br>，此时ViewModel需要做的是业务逻辑处理，以及修改View和Model的状态</p><blockquote><p>原文：<a href="https://blog.csdn.net/Ghost_tal/article/details/82052377" target="_blank" rel="noopener">https://blog.csdn.net/Ghost_tal/article/details/82052377</a></p></blockquote><h2 id="MVVM-amp-LiveData"><a href="#MVVM-amp-LiveData" class="headerlink" title="MVVM &amp; LiveData"></a>MVVM &amp; LiveData</h2><h3 id="使用-LiveData-的好处"><a href="#使用-LiveData-的好处" class="headerlink" title="使用 LiveData 的好处"></a>使用 LiveData 的好处</h3><ul><li><p>UI 和数据保持一致性</p><p>LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。</p></li><li><p>没有内存泄漏</p><p>观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。</p></li><li><p>不会因 UI 暂停而崩溃</p><p>如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。</p></li><li><p>不再需要手动管理生命周期</p><p>UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。</p></li><li><p>始终保持最新数据</p><p>如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。</p></li><li><p>配置更改自动处理</p><p>如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。</p></li><li><p>共享资源</p><p>您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。</p></li></ul><h2 id="MVVM-每一层的处理"><a href="#MVVM-每一层的处理" class="headerlink" title="MVVM 每一层的处理"></a>MVVM 每一层的处理</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><blockquote><p>show me the code as flowing：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainRepository</span> : <span class="type">BaseRepository</span></span>() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> loadSuccess = MutableLiveData&lt;FirstCategoryResp&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        compositeDisposable.add(Flowable.just(Any())</span><br><span class="line">            .doOnNext &#123; showLoading() &#125;</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .flatMap &#123; WebApiService.getFirstCategories(FirstCategoryReq()) &#125;</span><br><span class="line">            .doOnNext &#123; loadSuccess.postValue(it) &#125;</span><br><span class="line">            .doFinally &#123; dismissLoading() &#125;</span><br><span class="line">            .subscribe(&#123; &#125;, &#123; throwable -&gt; LogUtils.e(throwable, <span class="string">"获取一级分类信息失败"</span>) &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>如上所示： Repository 持有 WebApiService, 同时，持有需要发射的后台数据。比如进行网络请求，数据库操作等。</p><h3 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">BaseViewModel</span>&lt;<span class="type">MainRepository</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initRepo</span><span class="params">()</span></span>: MainRepository &#123;</span><br><span class="line">        <span class="keyword">return</span> MainRepository()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> loadSuccess: LiveData&lt;FirstCategoryResp&gt; = Transformations.map(repository.loadSuccess) &#123; it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repository.loadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModel 持有需要发射的 LiveData 数据对象，这里比较特殊，通过  Transformations.map 直接转发来发射自 Repository 的数据 ，同时提供加载数据的方法给 View 调用。方法内部没有任何逻辑，直接转发调用 Repository 的方法进行数据加载。</p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initLiveDataObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModel.loadSuccess.observe(<span class="keyword">this</span>, androidx.lifecycle.Observer &#123; refreshUI(it) &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 View 层，持有 ViewModel，并观察 ViewMode 的数据变化。当有新的数据发射出来时，直接调用更新 UI。</p><p>综上，可以看出，从 View -&gt; ViewModel -&gt; Repository,即代表了 V -&gt; VM -&gt; M 这样的单向引用。统一标准为上层直接依赖下层，上传简介观察下层的数据变化，并非下层调用上层的业务逻辑，每一层之间的数据转发都是通过观察者的模式来连接。</p><h2 id="Repository-结合-RxJava-使用"><a href="#Repository-结合-RxJava-使用" class="headerlink" title="Repository 结合 RxJava 使用"></a>Repository 结合 RxJava 使用</h2><p>在上面的示例中，已经展示过在 Repository 里使用 RxJava 进行网络请求的流封装，并且在 BaseViewModel 的 onCleared 方法中，调用 CompositeDisable 的 clear 方法进行后台任务的取消和清除。</p><p>而且可以看到，在进行网络数据请求或者任何耗时操作的时候，不需要进行主动的线程切换，因为所有的数据发射，我们都是使用了 postValue 方法，在其内部已经帮我们进行了现场的切换。</p><h2 id="LiveData-amp-RxJava-比较"><a href="#LiveData-amp-RxJava-比较" class="headerlink" title="LiveData &amp; RxJava 比较"></a>LiveData &amp; RxJava 比较</h2><p>两者有很多相似的地方，但是侧重点有所不同。</p><ul><li><p>LiveData 侧重于生命周期的管理。</p></li><li><p>RxJava 侧重于流式 API 的支持。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，MVVM 是非常值得一试的。就目前的使用情况来看，没发现什么严重的问题。推荐一试。当然，任何东西也都不可能是完美的，始终要抱着辩证的思维去看待一个事情，但是也要保持积极地心态去拥抱新技术的不断涌现，才不至于被潮流所抛弃。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;前置储备：&lt;a href=&quot;https://www.duanyitao.com/2019/04/12/Jetpack-之-LiveData/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LiveData&lt;/a&gt;&lt;br&gt;可以说
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
      <category term="MVVM" scheme="http://duanyitao.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 LiveData</title>
    <link href="http://duanyitao.com/2019/04/12/Jetpack-%E4%B9%8B-LiveData/"/>
    <id>http://duanyitao.com/2019/04/12/Jetpack-之-LiveData/</id>
    <published>2019-04-12T08:12:28.000Z</published>
    <updated>2019-04-12T09:53:16.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-LiveData"><a href="#什么是-LiveData" class="headerlink" title="什么是 LiveData"></a>什么是 LiveData</h2><blockquote><p>LiveData是一个可观察的数据持有者类。与常规 observable 不同，LiveData 是生命周期感知的，这意味着它遵从其他应用程序组件的生命周期，例如 Activity，Fragment 或 Service。此感知确保 LiveData 仅更新处于 Activity 生命周期状态应用程序组件的观察者。</p></blockquote><h2 id="使用-LiveData-的好处"><a href="#使用-LiveData-的好处" class="headerlink" title="使用 LiveData 的好处"></a>使用 LiveData 的好处</h2><blockquote><p>既然有了 observable 系列的支持，那为什么还有 LiveData 存在的意义？正所谓存在的就是合理的，也当然就有它存在的理由，下面我们来看看 LiveData 相较于 Observable 有哪些优点：</p></blockquote><h3 id="UI-和数据保持一致性"><a href="#UI-和数据保持一致性" class="headerlink" title="UI 和数据保持一致性"></a>UI 和数据保持一致性</h3><p>  LiveData 遵循观察者模式。Observer 生命周期状态更改时，LiveData 会通知其观察的对象列表。每次应用程序数据更改时，观察者都可以在每次更改时收到消息并更新UI，而不是主动去获取状态来更新UI。</p><h3 id="没有内存泄漏"><a href="#没有内存泄漏" class="headerlink" title="没有内存泄漏"></a>没有内存泄漏</h3><p>  观察者绑定 Lifecycle 对象并在其相关生命周期被销毁后自行清理。</p><h3 id="不会因-UI-暂停而崩溃"><a href="#不会因-UI-暂停而崩溃" class="headerlink" title="不会因 UI 暂停而崩溃"></a>不会因 UI 暂停而崩溃</h3><p>  如果观察者的生命周期处于非活动（例如，在后台堆栈中的 Activity 的情况下），则它不会接收任何 LiveData 事件。</p><h3 id="不再需要手动管理生命周期"><a href="#不再需要手动管理生命周期" class="headerlink" title="不再需要手动管理生命周期"></a>不再需要手动管理生命周期</h3><p>  UI组件只是观察相关数据，不会停止或恢复观察。LiveData 自动管理所有这些动作，因为它可以感知到到相关的生命周期状态变化。</p><h3 id="始终保持最新数据"><a href="#始终保持最新数据" class="headerlink" title="始终保持最新数据"></a>始终保持最新数据</h3><p>  如果 UI 生命周期变为非活动，它将在再次变为活动时接收最新数据。例如，后台 Activity 在返回前台后立即接收最新数据。</p><h3 id="配置更改自动处理"><a href="#配置更改自动处理" class="headerlink" title="配置更改自动处理"></a>配置更改自动处理</h3><p>  如果由于配置更改（例如设备旋转）而重新创建 Activity 或 Fragment ，则会立即接收最新的可用数据。</p><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h3><p>  您可以把 LiveData 使用单例模式来包装各种系统服务，以便可以在应用程序中共享它们。该 LiveData 对象连接到系统服务一次，然后任何需要该资源的观察者只需观察该 LiveData 对象，即可拿到共享的数据资源。</p><h2 id="如何使用-LiveDate-对象"><a href="#如何使用-LiveDate-对象" class="headerlink" title="如何使用 LiveDate 对象"></a>如何使用 LiveDate 对象</h2><blockquote><p>包括以下步骤：</p></blockquote><ol><li>创建一个 LiveData 用于保存特定类型数据的实例。这通常在您的 ViewModel 内完成 。</li><li>创建一个 Observer 定义 onChanged() 方法的对象，该对象负责处理 LiveData 对象数据更改时发出的数据。通常Observer 在 UI 控制器中创建，例如 Activity 或 Fragment 。</li><li>使用 LiveData 的 observe 方法将 Observer 绑定到 LiveData 对象。通常在UI控制器中完成绑定，例如 Activity 或 Fragment 。</li></ol><h3 id="创建-LiveData-对象"><a href="#创建-LiveData-对象" class="headerlink" title="创建 LiveData 对象"></a>创建 LiveData 对象</h3><blockquote><p>在 ViewModel 中创建 LiveData 对象：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a LiveData with a String</span></span><br><span class="line">    <span class="keyword">val</span> currentName: MutableLiveData&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        MutableLiveData&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察-LiveData-对象"><a href="#观察-LiveData-对象" class="headerlink" title="观察 LiveData 对象"></a>观察 LiveData 对象</h3><blockquote><p>在 UI 中观察 LiveData:</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> model: NameViewModel</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        model = ViewModelProviders.of(<span class="keyword">this</span>).<span class="keyword">get</span>(NameViewModel::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">val</span> nameObserver = Observer&lt;String&gt; &#123; newName -&gt;</span><br><span class="line">            <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">            nameTextView.text = newName</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        model.currentName.observe(<span class="keyword">this</span>, nameObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新-LiveData-对象"><a href="#更新-LiveData-对象" class="headerlink" title="更新 LiveData 对象"></a>更新 LiveData 对象</h3><blockquote><p>如果是在非主线程中更新数据，使用 postValue 方法</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> anotherName = <span class="string">"John Doe"</span></span><br><span class="line">    model.currentName.postValue(anotherName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果是在主线程中更新数据，使用 setValue 方法</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> anotherName = <span class="string">"John Doe"</span></span><br><span class="line">    model.currentName.setValue(anotherName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LiveData-高级部分"><a href="#LiveData-高级部分" class="headerlink" title="LiveData 高级部分"></a>LiveData 高级部分</h2><h3 id="在-Room-中使用-LiviData"><a href="#在-Room-中使用-LiviData" class="headerlink" title="在 Room 中使用 LiviData"></a>在 Room 中使用 LiviData</h3><p>Room 持久库支持可观察的查询操作，返回 LiveData 对象，可观察的查询写在 DAO 中并成为 DAO 的一部分。<br>Room 将自动生成所有需要的中间代码，以达到数据库被更新时自动发出通知，所生成的中间代码运行在异步线程中，如果你的界面显示的数据源来自 Room，这个特性将显得非常有用。</p><h3 id="扩展-LiviData"><a href="#扩展-LiviData" class="headerlink" title="扩展 LiviData"></a>扩展 LiviData</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span></span>(symbol: String) : LiveData&lt;BigDecimal&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stockManager = StockManager(symbol)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> listener = &#123; price: BigDecimal -&gt;</span><br><span class="line">        value = price</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.requestPriceUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">        stockManager.removeUpdates(listener)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如上所示，如果需要扩展一个 LiveData 对象，我们需要实现以下方法：</p></blockquote><ul><li><p>onActive() 当 LiveData 对象的观察者处于活动状态时调用该方法。</p></li><li><p>onInactive() 当 LiveData 对象的所有观察者都处于非活动状态时调用该方法。</p></li><li><p>setValue(T) 此方法 LiveData 实例的值发生更新时调用，并通知所有活动的观察者。</p></li></ul><p>可以像下面这样使用上面扩展的 LiveData 对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">    <span class="keyword">val</span> myPriceListener: LiveData&lt;BigDecimal&gt; = ...</span><br><span class="line">    myPriceListener.observe(<span class="keyword">this</span>, Observer&lt;BigDecimal&gt; &#123; price: BigDecimal? -&gt;</span><br><span class="line">        <span class="comment">// Update the UI.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换-LiveData"><a href="#转换-LiveData" class="headerlink" title="转换 LiveData"></a>转换 LiveData</h3><blockquote><p>有时候希望在将 LiveData 对象分发给观察者之前对其中存储的值进行更改 ，或者可能需要此 LiveData 根据另一个实例的值返回其他实例。在这种场景下，Lifecycle 中包提供的 Transformations 包含支持这些方案的辅助方法和类。</p></blockquote><ul><li><p>Transformations.map()</p><blockquote><p>对存储在 LiveData 对象中的值应用一个转换函数，并将结果传播到下游。</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userLiveData: LiveData&lt;User&gt; = UserLiveData()</span><br><span class="line"><span class="keyword">val</span> userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) &#123;user -&gt;</span><br><span class="line">    <span class="string">"<span class="subst">$&#123;user.name&#125;</span> <span class="subst">$&#123;user.lastName&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Transformations.switchMap()</p><blockquote><p>类似于 map()，将一个函数应用于存储在 LiveData 对象中的值，并将结果解包并调度到下游。传递给 switchMap() 参数的这个函数，必须返回一个LiveData对象，如下例所示：</p></blockquote></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(id: <span class="type">String</span>)</span></span>: LiveData&lt;User&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> userId: LiveData&lt;String&gt; = ...</span><br><span class="line"><span class="keyword">val</span> user = Transformations.switchMap(userId) &#123; id -&gt; getUser(id) &#125;</span><br></pre></td></tr></table></figure><h3 id="合并多个-LiveData-源"><a href="#合并多个-LiveData-源" class="headerlink" title="合并多个 LiveData 源"></a>合并多个 LiveData 源</h3><ul><li><p>MediatorLiveData</p><blockquote><p>MediatorLiveData 是一个 LiveData 的子类，允许合并多个 LiveData 源。MediatorLiveData 只要其中任何一个原始 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p></blockquote></li></ul><p>例如，如果一个 LiveData 可以从本地数据库或网络更新的对象，则可以将以下源添加到该 MediatorLiveData 对象：</p><ul><li><p>一个与存储在数据库中的数据关联的 LiveData 对象。</p></li><li><p>一个与从网络访问的数据关联的 LiveData 对象。</p></li></ul><p>此时，UI 中只需要观察 MediatorLiveData 对象，就可以做到观察两个数据源的更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;什么是-LiveData&quot;&gt;&lt;a href=&quot;#什么是-LiveData&quot; class=&quot;headerlink&quot; title=&quot;什么是 LiveData&quot;&gt;&lt;/a&gt;什么是
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="LiveData" scheme="http://duanyitao.com/tags/LiveData/"/>
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>DataBinding - 使用可观察的数据对象</title>
    <link href="http://duanyitao.com/2019/04/09/DataBinding%20-%20%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1/"/>
    <id>http://duanyitao.com/2019/04/09/DataBinding - 使用可观察的数据对象/</id>
    <published>2019-04-09T06:22:48.000Z</published>
    <updated>2019-04-17T07:48:59.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是可观察对象"><a href="#什么是可观察对象" class="headerlink" title="什么是可观察对象"></a>什么是可观察对象</h1><blockquote><p>注：本文参考并翻译自<a href="https://developer.android.com/topic/libraries/data-binding/observability" target="_blank" rel="noopener">官网链接</a></p></blockquote><hr><ul><li><p>可观察性是指对象具备通知外部其数据发生变化的能力。Databinding 支持对象、字段或集合的可观察。</p></li><li><p>当其中一个可观察数据对象绑定到UI并且数据对象的属性发生更改时，UI将自动更新。</p></li></ul><h1 id="可观察的类型"><a href="#可观察的类型" class="headerlink" title="可观察的类型"></a>可观察的类型</h1><blockquote><p>任何普通对象都可用于数据绑定，但修改对象不会自动导致UI更新。Databinding 可用于为数据对象提供在数据更改时通知其他对象（称为侦听器）的能力。有三种不同类型的可观察类： 对象，字段和 集合。</p></blockquote><h2 id="可观察字段"><a href="#可观察字段" class="headerlink" title="可观察字段"></a>可观察字段</h2><blockquote><p>有时候你的类中如果有一些需要更新的字段，并且只包含以下这些属性，那么可以直接使用系统的实现，而不需要重新实现。这时候，你字需要使用可观察对象作为其字段，或者直接使用可观察字段。</p></blockquote><ul><li>ObservableBoolean</li><li>ObservableByte</li><li>ObservableChar</li><li>ObservableShort</li><li>ObservableInt</li><li>ObservableLong</li><li>ObservableFloat</li><li>ObservableDouble</li><li>ObservableParcelable</li></ul><blockquote><p>可观察字段是具有单个字段的自包含可观察对象。原始版本在访问操作期间避免装箱和拆箱。要使用此机制，请public final在 Java 编程语言中创建属性或在 Kotlin 中创建只读属性，如以下示例所示：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> firstName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> lastName = ObservableField&lt;String&gt;()</span><br><span class="line">    <span class="keyword">val</span> age = ObservableInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要访问字段值，请使用 set() and get() 方法，如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName = <span class="string">"Google"</span></span><br><span class="line"><span class="keyword">val</span> age = user.age</span><br></pre></td></tr></table></figure><blockquote><p>Note: Android Studio 3.1 and higher allow you to replace observable fields with LiveData objects, which provide additional benefits to your app. For more information, <a href="https://developer.android.com/topic/libraries/data-binding/architecture.html#livedata" target="_blank" rel="noopener">see Use LiveData to notify the UI about data changes</a>.</p></blockquote><h2 id="可观察集合"><a href="#可观察集合" class="headerlink" title="可观察集合"></a>可观察集合</h2><ul><li><p>可以使用可观察的集合，来存放一些列的数据。通过示例来使用 ObservableArrayMap 类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Any&gt;().apply &#123;</span><br><span class="line">  put(<span class="string">"firstName"</span>, <span class="string">"Google"</span>)</span><br><span class="line">  put(<span class="string">"lastName"</span>, <span class="string">"Inc."</span>)</span><br><span class="line">  put(<span class="string">"age"</span>, <span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在布局文件中，可以直接使用 key 去拿到这个存储的值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableMap"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableMap&lt;String, Object&gt;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;user.lastName&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;String.valueOf(1 + (Integer)user.age)&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果 Key 是无序的 int 时，可以使用 ObservableArrayList 类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Any&gt;().apply &#123;  </span><br><span class="line">add(<span class="string">"Google"</span>)</span><br><span class="line">add(<span class="string">"Inc."</span>)</span><br><span class="line">add(<span class="number">17</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 layout 文件中，可以直接通过索引的方式获取：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"android.databinding.ObservableList"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">import</span> <span class="attr">type</span>=<span class="string">"com.example.my.app.Fields"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"ObservableList&lt;Object&gt;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">'@&#123;user[Fields.LAST_NAME]&#125;'</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">'@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;'</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="可观察的对象"><a href="#可观察的对象" class="headerlink" title="可观察的对象"></a>可观察的对象</h2><blockquote><p>实现 Observable 接口的类，允许注册对象属性更改的侦听器。<br>该 Observable 接口具有添加和删除侦听器的机制，但您必须决定何时发送通知。为了使开发更容易，Databinding 库提供了 BaseObservable 实现侦听器注册机制的类。实现了 BaseObservable 的类，负责在属性更改时发出通知。这是通过 Bindable 为 getter 添加注解，并在 setter 中调用 notifyPropertyChanged() 方法来完成的，如以下示例所示：</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> : <span class="type">BaseObservable</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> firstName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.firstName)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Bindable</span></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            notifyPropertyChanged(BR.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Databinding 在模块包中生成BR命名的类，该类包含用于 Databinding 的资源的ID。 Bindable 注解会在编译期生成一个 BR类 中的的条目。如果无法更改数据类的基类，则 Observable可以使用PropertyChangeRegistry 对象来实现接口， 以便有效地注册和通知侦听器。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;什么是可观察对象&quot;&gt;&lt;a href=&quot;#什么是可观察对象&quot; class=&quot;headerlink&quot; title=&quot;什么是可观察对象&quot;&gt;&lt;/a&gt;什么是可观察对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注：本文参考并翻译自&lt;a
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
      <category term="Databinding" scheme="http://duanyitao.com/tags/Databinding/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 Databinding</title>
    <link href="http://duanyitao.com/2019/04/04/Jetpack-%E4%B9%8B-Databinding/"/>
    <id>http://duanyitao.com/2019/04/04/Jetpack-之-Databinding/</id>
    <published>2019-04-04T13:33:03.000Z</published>
    <updated>2019-04-12T10:00:02.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于DataBinding"><a href="#关于DataBinding" class="headerlink" title="关于DataBinding"></a>关于DataBinding</h1><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>  DataBinding 是一个支持库，允许使用声明格式(而不是编程方式)将布局中的UI组件绑定到应用程序中的数据源。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>  布局通常在 Activity 中定义。例如，下面的代码调用findViewById()查找TextView并将其绑定到 viewModel 变量的 userName 属性:</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;TextView&gt;(R.id.sample_text).apply &#123;</span><br><span class="line">    text = viewModel.userName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以下示例说明如何使用 DataBinding 直接在布局文件中将 <code>text</code> 赋值为 <code>viewmodel.userName</code>。这消除了上面显示调用任何Java代码的需要。注意<code>@{}</code>在赋值表达式中使用语法：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewmodel.userName&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>  在布局文件中进行数据绑定可以删除在 Activity 中许多的UI框架调用，使其更简单，更易于维护。这还可以提高应用程序的性能，并有助于防止内存泄漏和空指针异常。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>  当然任何东西都不是完美无缺的，DataBinding 在使用的时候，因为 APT 会帮助我们生产很多中间模板代码，所在开发调试过程中、以及线上问题跟踪时，有可能定位不到准确的错误点。当然，你要是熟练使用 DataBinding 的话，这些缺点在优点面前就显得微不足道了。所以在这里还是要墙裂推荐这个库的使用。能大量减少繁琐的模板代码。</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li>仅支持 Android 4.0（API级别14）或更高版本的设备。</li><li>推荐使用最新的 Gradle 插件版本 Android Plugin。因为 DataBinding 支持 1.5.0 或更高版本。</li></ul><h2 id="设置构建环境"><a href="#设置构建环境" class="headerlink" title="设置构建环境"></a>设置构建环境</h2><p>  在 moudule 级别的 build 脚本中，adnroid 节点下配置如下：</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  dataBinding &#123;</span><br><span class="line">      enabled = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Android-Studio-支持数据绑定"><a href="#Android-Studio-支持数据绑定" class="headerlink" title="Android Studio 支持数据绑定"></a>Android Studio 支持数据绑定</h2><p>  Android Studio支持许多用于数据绑定代码的编辑功能。例如，它支持数据绑定表达式的以下功能：</p><ul><li>语法突出显示</li><li>标记表达式语言语法错误</li><li>XML代码补全</li><li><p>如果使用了 Navigation，那么在视图设计中可以直接预览默认值效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;user.firstName, default=my_default&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>  如果只需要在项目的设计阶段显示默认值，则可以使用tools属性而不是默认表达式值。</p></li></ul><h1 id="在布局中使用"><a href="#在布局中使用" class="headerlink" title="在布局中使用"></a>在布局中使用</h1><h2 id="编写布局文件并绑定表达式"><a href="#编写布局文件并绑定表达式" class="headerlink" title="编写布局文件并绑定表达式"></a>编写布局文件并绑定表达式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">"viewmodel"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"com.myapp.data.ViewModel"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintLayout...</span> /&gt;</span> <span class="comment">&lt;!-- UI layout's root element --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上所示，不同于以往的常规布局方式，在最外层嵌套了一个 <code>layout</code> ,然后下面有一个 <code>data</code> 节点，再下面一个节点才是我们以往的布局根节点。</p><p>其中，<code>data</code> 节点下可以做很多事情，包括：</p><ul><li><p>数据声明</p></li><li><p>使用 <code>import</code> 导包</p></li></ul><p>在根布局节点下面，可以直接使用 <code>data</code> 中声明的变量、使用表达式等很多强大的功能。</p><h2 id="使用可观察数据对象"><a href="#使用可观察数据对象" class="headerlink" title="使用可观察数据对象"></a>使用可观察数据对象</h2><p>  DataBinding 提供了一些列的类和方法，可以轻松地观察数据变更以进行 UI 更改。不再担心在基础数据源发生更改时需要手动刷新UI。您可以观察变量或其属性。该库允许您使对象，字段或集合可观察。</p><h2 id="生成绑定数据类"><a href="#生成绑定数据类" class="headerlink" title="生成绑定数据类"></a>生成绑定数据类</h2><ul><li><p>DataBinding 生成用于访问布局中变量和视图的绑定类。</p></li><li><p>生成的绑定类将布局变量与布局中的视图链接起来，绑定类的名称和包可以自定义。</p></li><li><p>所有生成的绑定类都继承自 ViewDataBinding类。</p></li><li><p>默认情况下，生成绑定数据类的名称基于布局文件的名称，将其转换为Pascal大小写并向其添加Binding后缀。</p><p>例如 <code>activity_main.xml</code> 生成的目标类名是：<code>ActivityMainBinding</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;关于DataBinding&quot;&gt;&lt;a href=&quot;#关于DataBinding&quot; class=&quot;headerlink&quot; title=&quot;关于DataBinding&quot;&gt;&lt;/a&gt;关于DataBinding&lt;/h1&gt;&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot;
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
      <category term="Databinding" scheme="http://duanyitao.com/tags/Databinding/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 框架研究计划</title>
    <link href="http://duanyitao.com/2019/04/02/Jetpack-%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6%E8%AE%A1%E5%88%92/"/>
    <id>http://duanyitao.com/2019/04/02/Jetpack-框架研究计划/</id>
    <published>2019-04-02T14:55:37.000Z</published>
    <updated>2019-06-22T02:59:35.083Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>最近一直在做框架方面得预研工作，工作中使用的 MVP 框架到目前为止已经一年多，确实发现 MVP 框架在某些情况下看来，代码冗余量还是比较严重的。</p><ul><li><p>目前公司的项目基本都是一两个人维护并进行迭代，所以 MVP 的分层架构在开发阶段并没有突出多少优势来。</p></li><li><p>加上 MVP 的接口太多太冗余，这个问题确实是非常突出了。一个项目里面，基本上打开都是接口类。有的甚至都没任何实现的空页面，但是为了遵循 MVP 的设计原则，不得不产生很多类似的模板代码类。</p></li><li><p>另外一点也是极为重要的，就是 MVP 继承体系，如果抽取多个 Base 类的话，一大堆的泛型传递也是非常繁琐的事情了。</p></li></ul></li><li><p>在 2018 年 Google 全新推出的 Jetpack 框架集合，其中就包含了对 MVVM 架构的支持。如下图所示：</p><p><img src="/../images/todoapp.png" alt="todoapp"></p></li><li><p>基于以上存在的问题和现状，是时候好好研究一下 google 强大的开发框架集合了。</p></li><li><p>后续会陆续更新一系列的文章，来记录学习的路径。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;ul&gt;
&lt;li&gt;&lt;p&gt;最近一直在做框架方面得预研工作，工作中使用的 MVP 框架到目前为止已经一年多，确实发现 MVP 框架在某些情况下看来，代码冗余量还是比较严重的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目前公司的项目基本都是一两个人维护并进行迭代，所以 MVP
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack 之 Navigation</title>
    <link href="http://duanyitao.com/2019/03/31/Jetpack-%E4%B9%8B-Navigation/"/>
    <id>http://duanyitao.com/2019/03/31/Jetpack-之-Navigation/</id>
    <published>2019-03-31T04:44:40.470Z</published>
    <updated>2019-04-12T10:02:42.751Z</updated>
    
    <content type="html"><![CDATA[<p>Navigation 是 Jetpack 组件中用于页面路由导航。在 Fragment 应用场景下，特别适合把各种页面逻辑调转和传参等繁琐无畏的模板代码交给 Navigation 来处理，同时能大幅度减少代码的数量和出错的问题。</p><p>类比 iOS 的 storyboard 有着很多相似的地方，下面就让我来看看具体如何来实现 Navigation 在项目中的应用。</p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="module-中的-build-脚本："><a href="#module-中的-build-脚本：" class="headerlink" title="module 中的 build 脚本："></a>module 中的 build 脚本：</h2><pre><code>def nav_version = &quot;2.0.0&quot;implementation &quot;androidx.navigation:navigation-fragment:$nav_version&quot; // For Kotlin use navigation-fragment-ktximplementation &quot;androidx.navigation:navigation-ui:$nav_version&quot; // For Kotlin use navigation-ui-ktx</code></pre><h2 id="root-的-build-脚本："><a href="#root-的-build-脚本：" class="headerlink" title="root 的 build 脚本："></a>root 的 build 脚本：</h2><pre><code>buildscript {    ...    dependencies {        ...        classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0&quot;    }}</code></pre><h1 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h1><h2 id="导航容器（navigation-container）"><a href="#导航容器（navigation-container）" class="headerlink" title="导航容器（navigation container）"></a>导航容器（navigation container）</h2><ul><li>系统已经为我们实现了一个导航容器，<strong>androidx.navigation.fragment.NavHostFragment</strong>。</li><li>使用方式:将以下代码加入到 Activity 中的 layout 文件内</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;fragment</span><br><span class="line">        android:id=&quot;@+id/nav_host_fragment&quot;</span><br><span class="line">        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        app:defaultNavHost=&quot;true&quot;</span><br><span class="line">        app:navGraph=&quot;@navigation/nav_graph&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="导航控制器（navigation-controller）"><a href="#导航控制器（navigation-controller）" class="headerlink" title="导航控制器（navigation controller）"></a>导航控制器（navigation controller）</h2><ul><li>通过导航容器，即可拿到导航控制器对象。获取方式见 3.4。</li></ul><h2 id="目标页面（destination）"><a href="#目标页面（destination）" class="headerlink" title="目标页面（destination）"></a>目标页面（destination）</h2><pre><code>App 中所有的 Fragment 都可作为目标页面。</code></pre><h2 id="跳转动作（action）"><a href="#跳转动作（action）" class="headerlink" title="跳转动作（action）"></a>跳转动作（action）</h2><pre><code>App 中任意两个目标页面之间的逻辑跳转，都称作一个跳转动作。</code></pre><h2 id="导航视图（navigation-graph）"><a href="#导航视图（navigation-graph）" class="headerlink" title="导航视图（navigation graph）"></a>导航视图（navigation graph）</h2><pre><code>导航控制器需要指定一个导航视图，导航视图包括了所有的目标页面以及跳转动作。</code></pre><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="如何创建导航视图（navigation-graph）？"><a href="#如何创建导航视图（navigation-graph）？" class="headerlink" title="如何创建导航视图（navigation graph）？"></a>如何创建导航视图（navigation graph）？</h2><pre><code>res -&gt; 右键 -&gt; new -&gt; Android Resources File，在 Resource Type 中选择 Navigation。</code></pre><h2 id="如何创建一个目标页面（destination）？"><a href="#如何创建一个目标页面（destination）？" class="headerlink" title="如何创建一个目标页面（destination）？"></a>如何创建一个目标页面（destination）？</h2><pre><code>res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式-&gt; 点击导航视图面板中的加号（New Destination)-&gt;（Create new destination) -&gt; 输入目标页面名称注：取消勾选 「Include fragment factory methods」 和 「Include interface callbacks」这两个选项,一般用不到。</code></pre><h2 id="如何创建一个跳转动作（action）？"><a href="#如何创建一个跳转动作（action）？" class="headerlink" title="如何创建一个跳转动作（action）？"></a>如何创建一个跳转动作（action）？</h2><pre><code>res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式-&gt; 选中一个目标页面 -&gt; 目标页面右侧会有一个圆点-&gt; 拖动这个圆点链接到另一个目标页面这样一个跳转动作就完成了。</code></pre><h2 id="如何获取导航控制器（navigation-controller）？"><a href="#如何获取导航控制器（navigation-controller）？" class="headerlink" title="如何获取导航控制器（navigation controller）？"></a>如何获取导航控制器（navigation controller）？</h2><pre><code>有三种方式可以获取到导航控制器</code></pre><ul><li>通过 View 获取<ul><li>Kotlin<br><code>View.findNavController()</code></li><li>Java<br><code>Navigation.findNavController(View)</code></li></ul></li><li>通过 Fragment 获取<ul><li>Kotlin<br><code>Fragment.findNavController()</code></li><li>Java<br><code>NavHostFragment.findNavController(Fragment)</code></li></ul></li><li>通过 Activity 获取<ul><li>Kotlin<br><code>Activity.findNavController(viewId: Int)</code></li><li>Java<br><code>Navigation.findNavController(Activity, @IdRes int viewId)</code></li></ul></li></ul><h2 id="如何执行跳转？"><a href="#如何执行跳转？" class="headerlink" title="如何执行跳转？"></a>如何执行跳转？</h2><ul><li>首先，所有的跳转都是通过导航控制器（navigation controller）来完成的，所以，我们先要拿到 navigation controller 对象，见 3.4。</li><li>拿到 navigation controller 对象之后，我们就可以执行它的 navigate 方法，传入跳转动作的 int 类型 ID，进行相应的跳转。</li><li>示例：<code>findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment )</code></li><li>传递参数：只需要添加参数即可：<ul><li><code>val args = Bundle()</code></li><li><code>args.putString(ARG,&quot;TEST DATA....&quot;)</code></li><li><code>findNavController().navigate(R.id.action_page1Fragment_to_page2Fragment ,args)</code></li></ul></li></ul><h2 id="如何控制页面的栈？"><a href="#如何控制页面的栈？" class="headerlink" title="如何控制页面的栈？"></a>如何控制页面的栈？</h2><ul><li>正常情况下，每次导航一个新的目标页面，都把目标页面置为栈顶。</li><li>如果某一个跳转（action）执行之后，希望把它的目标页面（destination）置顶并清除原来的栈，就需要在它对应的 action 上加入下面两个属性：<ul><li><code>app:popUpToInclusive=&quot;true&quot;</code></li><li><code>app:popUpTo=&quot;@+id/page1Fragment&quot;</code></li></ul></li></ul><h2 id="控制栈的回退"><a href="#控制栈的回退" class="headerlink" title="控制栈的回退"></a>控制栈的回退</h2><ul><li>调用 <code>findNavController().navigateUp()</code> 执行一次栈顶出栈操作。</li></ul><h2 id="跳转动画可以自定义么？"><a href="#跳转动画可以自定义么？" class="headerlink" title="跳转动画可以自定义么？"></a>跳转动画可以自定义么？</h2><p>可以的。在 action 节点下添加以下属性指定页面跳转动画：、</p><ul><li><code>app:enterAnim=&quot;@anim/nav_default_enter_anim&quot;</code></li><li><code>app:exitAnim=&quot;@anim/nav_default_exit_anim&quot;</code></li><li><code>app:popEnterAnim=&quot;@anim/nav_default_pop_enter_anim&quot;</code></li><li><code>app:popExitAnim=&quot;@anim/nav_default_pop_exit_anim&quot;</code></li></ul><h2 id="如何设置启动页？"><a href="#如何设置启动页？" class="headerlink" title="如何设置启动页？"></a>如何设置启动页？</h2><p>每一个导航视图，都必须有且只有一个启动页（start destination）</p><ul><li>res -&gt; navigation -&gt; 打开一个导航视图 -&gt; 切换到 Design 模式 -&gt; 选中一个目标页面 -&gt; 点击导航编辑器面板上的 「小房子」图标即可设置当前页面为启动页。</li></ul><h2 id="如何传递参数"><a href="#如何传递参数" class="headerlink" title="如何传递参数"></a>如何传递参数</h2><p>可以参考我的Github示例代码<br><a href="https://github.com/duanyitao/NavigationDemo" target="_blank" rel="noopener">https://github.com/duanyitao/NavigationDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Navigation 是 Jetpack 组件中用于页面路由导航。在 Fragment 应用场景下，特别适合把各种页面逻辑调转和传参等繁琐无畏的模板代码交给 Navigation 来处理，同时能大幅度减少代码的数量和出错的问题。&lt;/p&gt;
&lt;p&gt;类比 iOS 的
        
      
    
    </summary>
    
      <category term="Android" scheme="http://duanyitao.com/categories/Android/"/>
    
    
      <category term="Jetpack" scheme="http://duanyitao.com/tags/Jetpack/"/>
    
      <category term="Navigation" scheme="http://duanyitao.com/tags/Navigation/"/>
    
  </entry>
  
</feed>
